## Интерпретатор командной строки

Мы познакомились с интерпретаторами. Они позволяют загружать с жёсткого диска и исполнять текстовые файлы с исходным кодом программ. Но это не единственный способ применения интерпретатора. Альтернативный способ заключается в его запуске в интерактивном режиме. В таком режиме команды для исполнения будут читаться не из файла, а из командной строки. То есть пользователь может набирать команды и сразу их исполнять. Программы поддерживающие такую возможность называются [**интерпретаторами командной строки**](https://ru.wikipedia.org/wiki/Интерпретатор_командной_строки).

Как правило, интерпретаторы командной строки являются частью ОС и предоставляют пользователю интерфейс для доступа к её функциям. Также через командную строку происходит запуск других приложений.


Как было отмечено ранее, интерфейс командной строки возник раньше чем GUI. Поэтому он был единственным средством управления компьютером в ОС 70-х и 80-х годов.

### Востребованность

Прежде чем начать писать скрипты на Bash, было бы полезно освоить работу его интерпретатора в режиме командной строки. Мы уже рассматривали этот тип интерфейса с исторической точки зрения. Он был повсеместно распространён 40 лет назад на относительно слабых по современным меркам компьютерах. Возникший позднее GUI полностью его вытеснил, по крайней мере на платформе PC.

Может возникнуть вопрос - есть ли какая-то практическая польза от изучения Bash сегодня? Ведь судя по всему следует, что это устаревшая технология, давно отжившая свой век. Это утверждение ошибочно. Не просто так Bash входит в [дистрибутивы](https://ru.wikipedia.org/wiki/Дистрибутив_операционной_системы) современных версий macOS и Linux. В Windows тоже есть редко используемый обычными пользователями интерпретатор командной строки [Cmd.exe](https://ru.wikipedia.org/wiki/Cmd.exe), поддерживающий исполнение [пакетных файлов](https://ru.wikipedia.org/wiki/Пакетный_файл). Впоследствии он был заменён на более мощный [PowerShell](https://ru.wikipedia.org/wiki/PowerShell). Задумайтесь над этим: в 2006 году Microsoft разрабатывает новый интерпретатор командной строки. На это определённо были свои причины.

Для чего же используется интерфейс командной строки сегодня? Прежде всего для задач [администрирования](https://ru.wikipedia.org/wiki/Системный_администратор) ОС. Современная ОС представляет собой множество взаимодействующих программ, у многих из которых есть свои параметры и настройки. Было бы очень трудоёмко разрабатывать GUI для конфигурации каждого из этих параметров, особенно если в обычной работе они используются редко. Но доступ к такой внутренней конфигурации и функциям становится крайне необходим, чтобы восстановить вышедшую из строя ОС. Кроме того, при сбое системы, её GUI может оказаться недоступен. Утилиты же восстановления часто имеют только интерфейс командной строки.

I> Интерпретатор Bash хорошо интегрирован в операционные системы семейств Linux и macOS. Через него можно получить доступ практически ко всем важным функциям ОС. Однако, интеграция Bash с Windows достаточно слабая. Вместо него для целей администрирования системы лучше подойдёт PowerShell. Почему же тогда мы изучаем Bash? Потому что он совместим со стандартом [POSIX](https://ru.wikipedia.org/wiki/POSIX) и на практике встречается чаще, чем PowerShell. Кроме того, в отличие от PowerShell, Bash доступен на всех популярных сегодня ОС.

CLI удобен при [подключении](https://ru.wikipedia.org/wiki/Программы_удалённого_администрирования) к удалённому компьютеру по сети. В этом случае для нормальной работы GUI требуется стабильное и быстрое сетевое соединения, которое доступно не всегда.

Когда возникают неполадки, знание интерфейса командной строки окажется полезным. Но нужно ли оно рядовому пользователю? На самом деле, CLI может значительно ускорить работу и рутинные операции. Хорошим примером служит обработка большого количества файлов. Представтье себе, что у вас есть десять файлов. К имени каждого из них вам нужно добавить некоторый суффикс. Эти переименования можно достаточно быстро выполнить вручную через [Проводник Windows](https://ru.wikipedia.org/wiki/Проводник_Windows). Теперь допустим, что вам надо переименовать не десять файлов, а пять тысяч. Как долго вы будете заниматься этим через GUI? Этот пример демонстрирует одну из сильных сторон CLI - многие команды интерпретатора хорошо [масштабируются](https://wiki.monavista.ru/Масштабируемость). В данном случае это означает, что они не требуют дополнительных действий от пользователя при значительном увеличении входных данных.

Программисты в своей профессиональной деятельности часто сталкиваются с большим количеством текстовых файлов с исходным кодом. Для работы с ними есть много удобных редакторов. Но эти редакторы опять же предоставляют графический интерфейс. Часто возникают ситуации, когда требуется внести изменение во все файлы проекта разом. В этом случае мы опять сталкиваемся с проблемой масштабируемости и многократного повторения одних и тех же действий вручную. Интерпретатор командной строки значительно ускоряет работу в подобных случаях.

Есть ещё одна важная особенность разработки [программного обеспечения](https://ru.wikipedia.org/wiki/Программное_обеспечение) (ПО), малоизвестная обычным пользователям. Практически все компиляторы и интерпретаторы имеют только интерфейс командной строки. Это связано с особенностями решаемой ими задачи, котоаря заключается в обработке большого числа файлов. Как мы уже выяснили, GUI плохо с ней справляется. Он неэффективен, и именно поэтому почти всегда отсутствует.

I> Некоторые читатели могут возразить, что большинство [**интегрированных сред разработки**](https://ru.wikipedia.org/wiki/Интегрированная_среда_разработки) (integrated development environment, IDE) предоставляет возможность компиляции и запуска программ из графического интерфейса. Это так. Но на самом деле, когда вы нажимаете на соответствующую кнопку GUI среды, происходит вызов компилятора с CLI интерфейсом. Список файлов и флаги компиляции передаются ему как параметры командной строки.

С разработкой связано ещё одно полезное, но неочевидное свойство командной строки. Программу, имеющую только текстовый интерфейс, обычно быстрее и проще разрабатывать, чем аналогичную с GUI. Почему это важно? Разработчики часто сталкиваются в своей работе с объёмными задачами, требующими большого количества действий. В этом случае принято подсчитывать: сколько времени уйдёт на выполнение задачи вручну и сколько на написание скрипта для автоматизации. Поскольку программы с текстовым интерфейсом быстрее писать, чаще выбор будет сделан в пользу вспомогательных скриптов. Это в свою очередь позволит избежать ошибок при ручной работе.

Надеюсь, я смог вас убедить, что базовые навыки работы с интерфейсом командной строки крайне важны для любого ИТ специалиста.

### Навигация по файловой системе

После запуска приложения `git-bash.exe` откроется окно [**терминала**](https://ru.wikipedia.org/wiki/Эмулятор_терминала**). Терминал - это программа, эмулирующая [устройство для подключения](https://ru.wikipedia.org/wiki/Компьютерный_терминал) к мэйнфрейму. Такие относительно дешевые устройства применялись в 70-е и 80-е года для подключениея нескольких пользователей к одному компьютеру. Благодаря этому, удавалось эффективнее использовать вычислительные ресурсы дорогих мэйнфреймов.

В окне терминала сразу после запуска выводятся две строчки (см. иллюстрацию 2-3):
```
ilya.shpigor@DESKTOP-1NBVQM$ MinGW64 /
$
```

Рассмотрим их подробнее. Первая строка начинается с имени пользователя. В моём случае это `ilya.shpigor`. Далее через символ `@` следует имя компьютера. Его можно изменить в настройках ОС. Затем идёт `MinGW64`. Это название платформы, на которой запущен Bash. В конце строки стоит символ `/`. Он означает **абсолютный путь** до текущего каталога. Остановимся на этом пункте поподробнее.

I> При навигации по файловой системе через графический интерфейс, вы, как правило, сталкиваетесь с абсолютными путями. Абсолютным называется путь к одному и тому же месту файловой системы вне зависимости от текущего каталога. **Относительный путь** напротив указывается по отношению к текущему каталогу.

#### Структура каталогов

В верхней части Проводника Windows есть адресная строка. В ней отображается абсолютный путь открытой в данный момент [**папки**](https://ru.wikipedia.org/wiki/Каталог_(файловая_система)#Термин_«Папка») (альтернативное название каталогов в Windows). Например, на иллюстрации 2-4 текущим путём является `This PC > Local Disk (C:) > MinGW`. Это означает, что в данный моменты в окне проводника отображается содержимое папки `MinGW`. Она хранится на локальном диске `C`. Диск называется локальным, если он физически подключён к вашему компьютеру. Если мы представим полный путь до папки в виде строки, то получим `C:\MinGW`.

{caption: "Иллюстрация 2-4. Окно Проводника Windows"}
![Окно Проводника Windows](images/Bash/explorer.png)

В окне терминала выводится та же самая информация: какая папка "открыта" в данный момент. Но между путём в Bash и Проводнике есть важное различие. Структуры каталогов в ОС Windows и Linux различаются. В Windows каждому физическому или логческому диску соответствует буква латинского алфавита. По умолчанию системный диск, на который была установлена ОС, обозначается буковой `C`. На нём вы можете найти [стандартные каталоги](https://en.wikipedia.org/wiki/Directory_structure#Windows_10): `Windows`, `Program Files`, `Program Files (x86)`, `Users`, `PerfLogs`. Другие логические и физические диски будут обозначаться буквами: `D`, `E`, `F` и т.д. Структуру каталогов на них пользователь выбирает произвольно. Такая организация файловой системы была разработана компанией Microsoft и не соответствует какому-либо стандарту.

Структура каталогов Linux придерживается [стандарта POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap10.html#tag_10). Поскольку Bash разрабатывался для POSIX-совместимых ОС, ему требуется соответствующая структура каталогов для корректной работы.

В чём же различие структуры каталогов Windows и Linux? Ключевая особенность Linux в том, что все логические и физические диски монтируются (т.е. подключаются) в [корневую файловую систему](https://en.wikipedia.org/wiki/Root_directory). То есть у компьютера есть специальный каталог, который обозначается символом `/`. Он включает в себя все остальные каталоги файловой системы.

Рассмотрим пример. Предположим, что у нас есть Windows система с 2-мя физическими дисками, обозначенными буквами `C` и `D`. Тогда структура каталогов первого уровня иерархии может выглядеть так, как демонстрирует листинг 2-1.

{caption: "Листинг 2-1. Структура каталогов первого уровня в ОС Windows", line-numbers: false}
```
C:\
    PerfLogs\
    Windows\
    Program Files\
    Program Files (x86)\
    Users\

D:\
    Data\
    Install\
```

В Linux эта же самая иерархия каталогов будет выглядеть согласно листингу 2-2.

{caption: "Листинг 2-2. Структура каталогов в ОС Linux", line-numbers: false}
```
/
    c/
        PerfLogs/
        Windows/
        Program Files/
        Program Files (x86)/
        Users/

    d/
        Data/
        Install/
```

Помните, что как только вы запускаете терминал MinGW, вы оказываетесь в структуре каталогов Linux. Поэтому, например, путь `C:\Windows` станет недоступным. Вместо него вы должны использовать путь `/c/Windows`.

I> Важная особенность POSIX совместимых систем заключается в [чувствительности к регистру символов](https://ru.wikipedia.org/wiki/Чувствительность_к_регистру_символов). Это означает, что строки `Data` и `data` различаются. В Windows чувствительности к регистру нет. Поэтому вы можете задать в адресной строке Проводника путь `c:\windows`. В результате будет открыт системный каталог `Windows`. В Linux и Bash это не сработает. Вам нужно вводить все символы пути в правильном регистре. Так же обратите внимание, что в Bash в качестве разделителя между именами каталогов и файлов спользуется символ [**слэш**](https://ru.wikipedia.org/wiki/Косая_черта) `/`, а не [**обратный слэш**](https://ru.wikipedia.org/wiki/Обратная_косая_черта) `\`, как в Windows.

#### Команды навигации по файловой системе

Вернёмся к нашему окну терминала, изображённому на иллюстрации 2-3. Последняя отображаемая в нём строка состоит из единственного смвола `$`. Он называется приглашением командной строки. Если последним напечатанным символом в терминале было приглашение, значит интерпретатор готов прочитать и исполнить очередную команду от пользователя. В противном случае интерпретатор занят и ваш ввод не будет обработан.

Рассмотрим наиболее часто используемые команды для навигации по файловой системе. Они приведены в таблице 2-1.

{caption: "Таблица 2-1. Команды для навигации по файловой системе", width: "100%"}
| Команда | Описание | Примеры |
| --- | --- | --- |
| `ls` | Вывод на экран содержимого указанного каталога. Если каталог не указан, быдет выведено содержимое текущего. | `ls` |
| | | `ls /c/Windows` |
| --- | --- | --- |
| `pwd` | Вывести на экран пути до текущего каталога. Ключ `-W` позволяет вывести путь в структуре каталогов Windows | `pwd` |
| | | `pwd -W` |
| --- | --- | --- |
| `cd` | Перейти в указанный каталог по относительному или абсолютному пути. | `cd tmp` |
| | | `cd \c\Windows` |
| --- | --- | --- |
| `mount` | Выполнить подключение файловой системы в корневую. При запуске без параметров выводится список всех подключенных в данный момент систем. | `mount` |
| --- | --- | --- |
| `find` | Найти указанный файл или каталог. Первым параметром команды указывается каталог, начиная с которого будет вестись поиск. Если он не указан, используется текущий каталог. | `find -name vim` |
| | | `find \c\Windows -name *vim*` |
| --- | --- | --- |
| `cat` | Вывести на экран содержимое указанного файла. | `cat README.md` |

I> Есть простое правило, чтобы отличить в Bash абсолютный путь от относительного. Если он начинается с символа `\` (например, `\c\Windows`), перед вами абсолютный путь. Если же путь начинается с имени каталога (например, `c\Windows`), то он относительный.

Рассмотрим каждую из команд таблицы 2-1. Мы только что запустили терминал. Первым делом всегда полезно уточнить текущий каталог. Терминал MinGW выводит эту информацию перед приглашением командной строки. Преположим, что этого не происходит. Воспользуемся командой `pwd`. Мы получим результат, приведённый на иллюстрации 2-5. Он означает, что сейчас мы находимся в корневом каталоге `/`.

{caption: "Иллюстрация 2-5. Вывод команды `pwd`"}
![Вывод pwd](images/Bash/pwd-command.png)

В интерпретаторе командной строки Bash есть функция автодополнения, которая значительно ускоряет набор текста. Она вызывается по нажатию клавиши `Tab`. Если вы набрали текст и по нему Bash может однозначно определить, какая команда имеется ввиду, он допишет её за вас. Если же есть несколько команд, которые начнаются с введёных букв, автодополнение не произойдёт. В этом случае нажмите Tab повторно, чтобы увидеть список всех доступных команд. Иллюстрация 2-6 демонстрирует вывод по двойному нажатию Tab после ввода текста `pw`.

{caption: "Иллюстрация 2-6. Автодополнение для команды `pw`"}
![Автодополнение pw](images/Bash/pw-autocompletion.png)

После уточнения текущего каталога, будет полезно узнать его содержимое. Для этого воспользуемся командой `ls`. Её вывод для корневого каталога `/` приведён в верхней части иллюстрации 2-7. Если вам надо вывести содержимое одного из подкаталогов, просто укажите его параметром команды `ls`. Нижняя часть иллюстрации 2-7 демонстриурет вывод для команды `ls dev`.

{caption: "Иллюстрация 2-7. Вывод команды `ls`"}
![Вывод ls](images/Bash/ls-command.png)

I> Чтобы очистить окно терминала от текста, нажмите комбинацию клавиш Ctrl+L. Чтобы очистить поле ввода или прервать выполнение работающей команды, нажмите Ctrl+C.

После того как мы опредеились с текущим местоположением, можно перейти в нужный нам каталог. Допустим, что нас интересует документация по окружению MinGW. Попробуем её найти в соответствующем каталоге. Наберите команду `cd mingw64`. Не забывайте про автодополнение. Оно работает как для самих команд, так и для их аргументов. В нашем случае будет достаточно набрать `cd m` и нажать клавишу Tab. Имя каталога `mingw64` будет введено автоматически. Результат выполнения команды приведён на иллюстрации 2-8.

{caption: "Иллюстрация 2-8. Результат выполнения команды `cd`"}
![Результат cd](images/Bash/cd-command.png)

Обратите внимание, что команда `cd` в случае успешного выполнения ничего не выводит. Единственное, что изменилось - это текущий каталог, который выводится перед приглашением командной строки. Теперь мы находимся в `/mingw64`.

Если вы воспользуетесь командой `ls`, то обнаружите каталог `doc`, а в нём `git-credential-manager`. Перейдите в него командой `cd doc/git-credential-manager`. По `ls` вы обнаружите там два файла: `LICENSE.txt` и `README.md`. Нас интересует второй. Выведите его содержимое на экран командой ` cat README.md`. Её результат приведён на иллюстрации 2-9.

{caption: "Иллюстрация 2-9. Результат выполнения команды `cat`"}
![Результат cat](images/Bash/cat-command.png)

Обратите внимание, что из-за большого размера файла весь вывод команды не поместился на экране. Но он остался в истории терминала. Вы можете воспользоваться полосой прокрутки в правой части окна, чтобы прочитать начало файла `README.md`.

Каждая введённая в терминал команда сохраняется в [истории команд](https://ru.wikipedia.org/wiki/History). Вы можете прокручивать историю назад и вперёд стрелками вверх и вниз соответственно. Например, вы ввели команду `cat README.md`. Чтобы её повторить, нажмите стрелку вверх и клавишу Enter. Комбинация клавиш Ctrl+R вызывает поиск по истории. Нажмите комбинацию и начните набирать текст. Bash предложит вам последнюю введёную команду, которая начинается так же. Чтобы исполнить её просто нажмите Enter.

Когда к вашему компьютеру подключено несколько дисков, может быть полезно вывести на экран их [**точки монтирования**](https://ru.wikipedia.org/wiki/Точка_монтирования). Точкой монтирования называется каталог, перейдя в который, вы оказываетесь в другой файловой системе. Иллюстрация 2-10 демонстрирует результат выполнения команды `mount` на моей системе.

{caption: "Иллюстрация 2-10. Результат выполнения команды `mount`"}
![Результат mount](images/Bash/mount-command.png)

Рассмотрим вывод команды подробнее. Его следует рассматривать как таблицу из четырёх столбцов. Первый из них означает


C:/MinGW/git on / type ntfs (binary,noacl,auto)
C:/MinGW/git/usr/bin on /bin type ntfs (binary,noacl,auto)
C:/Users/ILYA~1.SHP/AppData/Local/Temp on /tmp type ntfs (binary,noacl,posix=0,usertemp)
C: on /c type ntfs (binary,noacl,posix=0,user,noumount,auto)
Z: on /z type hgfs (binary,noacl,posix=0,user,noumount,auto)


I> Копирование текста из командной строки и вставка по средней кнопке мыши.

### Работа с файлами

### Конвейр команд

https://ru.wikipedia.org/wiki/Конвейер_(Unix)

// TODO: начать разбор pipe и вывод в файл с примера cat.
## Интерпретатор командной строки

Мы познакомились с интерпретаторами. Они позволяют загружать с жёсткого диска и исполнять текстовые файлы с исходным кодом программ. Но это не единственный способ применения интерпретатора. Альтернативный способ заключается в его запуске в интерактивном режиме. В таком режиме команды для исполнения будут читаться не из файла, а из командной строки. То есть пользователь может набирать команды и сразу их исполнять. Программы поддерживающие такую возможность называются [**интерпретаторами командной строки**](https://ru.wikipedia.org/wiki/Интерпретатор_командной_строки).

Как правило, интерпретаторы командной строки являются частью ОС и предоставляют пользователю интерфейс для доступа к её функциям. Также через командную строку происходит запуск других приложений.

Как было отмечено ранее, интерфейс командной строки возник раньше чем GUI. Поэтому он был единственным средством управления компьютером в ОС 70-х и 80-х годов.

### Востребованность

Прежде чем начать писать скрипты на Bash, было бы полезно освоить работу его интерпретатора в режиме командной строки. Мы уже рассматривали этот тип интерфейса с исторической точки зрения. Он был повсеместно распространён 40 лет назад на относительно слабых по современным меркам компьютерах. Возникший позднее GUI полностью его вытеснил, по крайней мере на платформе PC.

Может возникнуть вопрос - есть ли какая-то практическая польза от изучения Bash сегодня? Ведь судя по всему следует, что это устаревшая технология, давно отжившая свой век. Это утверждение ошибочно. Не просто так Bash входит в [дистрибутивы](https://ru.wikipedia.org/wiki/Дистрибутив_операционной_системы) современных версий macOS и Linux. В Windows тоже есть редко используемый обычными пользователями интерпретатор командной строки [Cmd.exe](https://ru.wikipedia.org/wiki/Cmd.exe), поддерживающий исполнение [пакетных файлов](https://ru.wikipedia.org/wiki/Пакетный_файл). Впоследствии он был заменён на более мощный [PowerShell](https://ru.wikipedia.org/wiki/PowerShell). Задумайтесь над этим: в 2006 году Microsoft разрабатывает новый интерпретатор командной строки. На это определённо были свои причины.

Для чего же используется интерфейс командной строки сегодня? Прежде всего для задач [администрирования](https://ru.wikipedia.org/wiki/Системный_администратор) ОС. Современная ОС представляет собой множество взаимодействующих программ, у многих из которых есть свои параметры и настройки. Было бы очень трудоёмко разрабатывать GUI для конфигурации каждого из этих параметров, особенно если в обычной работе они используются редко. Но доступ к такой внутренней конфигурации и функциям становится крайне необходим, чтобы восстановить вышедшую из строя ОС. Кроме того, при сбое системы, её GUI может оказаться недоступен. Утилиты же восстановления часто имеют только интерфейс командной строки.

I> Интерпретатор Bash хорошо интегрирован в операционные системы семейств Linux и macOS. Через него можно получить доступ практически ко всем важным функциям ОС. Однако, интеграция Bash с Windows достаточно слабая. Вместо него для целей администрирования системы лучше подойдёт PowerShell. Почему же тогда мы изучаем Bash? Потому что он совместим со стандартом [POSIX](https://ru.wikipedia.org/wiki/POSIX) и на практике встречается чаще, чем PowerShell. Кроме того, в отличие от PowerShell, Bash доступен на всех популярных сегодня ОС.

CLI удобен при [подключении](https://ru.wikipedia.org/wiki/Программы_удалённого_администрирования) к удалённому компьютеру по сети. В этом случае для нормальной работы GUI требуется стабильное и быстрое сетевое соединения, которое доступно не всегда.

Когда возникают неполадки, знание интерфейса командной строки окажется полезным. Но нужно ли оно рядовому пользователю? На самом деле, CLI может значительно ускорить работу и рутинные операции. Хорошим примером служит обработка большого количества файлов. Представтье себе, что у вас есть десять файлов. К имени каждого из них вам нужно добавить некоторый суффикс. Эти переименования можно достаточно быстро выполнить вручную через [Проводник Windows](https://ru.wikipedia.org/wiki/Проводник_Windows). Теперь допустим, что вам надо переименовать не десять файлов, а пять тысяч. Как долго вы будете заниматься этим через GUI? Этот пример демонстрирует одну из сильных сторон CLI - многие команды интерпретатора хорошо [масштабируются](https://wiki.monavista.ru/Масштабируемость). В данном случае это означает, что они не требуют дополнительных действий от пользователя при значительном увеличении входных данных.

Программисты в своей профессиональной деятельности часто сталкиваются с большим количеством текстовых файлов с исходным кодом. Для работы с ними есть много удобных редакторов. Но эти редакторы опять же предоставляют графический интерфейс. Часто возникают ситуации, когда требуется внести изменение во все файлы проекта разом. В этом случае мы опять сталкиваемся с проблемой масштабируемости и многократного повторения одних и тех же действий вручную. Интерпретатор командной строки значительно ускоряет работу в подобных случаях.

Есть ещё одна важная особенность разработки [программного обеспечения](https://ru.wikipedia.org/wiki/Программное_обеспечение) (ПО), малоизвестная обычным пользователям. Практически все компиляторы и интерпретаторы имеют только интерфейс командной строки. Это связано с особенностями решаемой ими задачи, котоаря заключается в обработке большого числа файлов. Как мы уже выяснили, GUI плохо с ней справляется. Он неэффективен, и именно поэтому почти всегда отсутствует.

I> Некоторые читатели могут возразить, что большинство [**интегрированных сред разработки**](https://ru.wikipedia.org/wiki/Интегрированная_среда_разработки) (integrated development environment, IDE) предоставляет возможность компиляции и запуска программ из графического интерфейса. Это так. Но на самом деле, когда вы нажимаете на соответствующую кнопку GUI среды, происходит вызов компилятора с CLI интерфейсом. Список файлов и флаги компиляции передаются ему как параметры командной строки.

С разработкой связано ещё одно полезное, но неочевидное свойство командной строки. Программу, имеющую только текстовый интерфейс, обычно быстрее и проще разрабатывать, чем аналогичную с GUI. Почему это важно? Разработчики часто сталкиваются в своей работе с объёмными задачами, требующими большого количества действий. В этом случае принято подсчитывать: сколько времени уйдёт на выполнение задачи вручну и сколько на написание скрипта для автоматизации. Поскольку программы с текстовым интерфейсом быстрее писать, чаще выбор будет сделан в пользу вспомогательных скриптов. Это в свою очередь позволит избежать ошибок при ручной работе.

Надеюсь, я смог вас убедить, что базовые навыки работы с интерфейсом командной строки крайне важны для любого ИТ специалиста.

### Навигация по файловой системе

После запуска приложения `msys2.exe` откроется окно [**терминала**](https://ru.wikipedia.org/wiki/Эмулятор_терминала**). Терминал - это программа, эмулирующая [устройство для подключения](https://ru.wikipedia.org/wiki/Компьютерный_терминал) к мэйнфрейму. Такие относительно дешевые устройства применялись в 70-е и 80-е года для подключениея нескольких пользователей к одному компьютеру. Благодаря этому, удавалось эффективнее использовать вычислительные ресурсы дорогих мэйнфреймов.

В окне терминала сразу после запуска выводятся две строчки (см. иллюстрацию 2-4):
{line-numbers: false}
```
ilya.shpigor@DESKTOP-1NBVQM4 MSYS ~
$
```

Рассмотрим их подробнее. Первая строка начинается с имени пользователя. В моём случае это `ilya.shpigor`. Далее через символ `@` следует имя компьютера `DESKTOP-1NBVQM4`. Его можно изменить в настройках ОС. Затем идёт `MSYS`. Это название платформы, на которой запущен Bash. В конце строки стоит символ `~`. Он означает **абсолютный путь** до текущего каталога. Остановимся на этом пункте поподробнее.

I> При навигации по файловой системе через графический интерфейс, вы чаще сталкиваетесь с абсолютными путями. Абсолютным называется путь к одному и тому же месту файловой системы вне зависимости от текущего каталога. **Относительный путь** напротив указывается по отношению к текущему каталогу.

#### Структура каталогов

В верхней части Проводника Windows есть адресная строка. В ней отображается абсолютный путь открытой в данный момент [**папки**](https://ru.wikipedia.org/wiki/Каталог_(файловая_система)#Термин_«Папка») (альтернативное название каталогов в Windows). Например, на иллюстрации 2-5 текущим путём является `This PC > Local Disk (C:) > msys64`. Это означает, что в данный моменты в окне проводника отображается содержимое папки `msys64`, которая хранится на локальном диске `C`. Диск называется локальным, если он физически подключён к вашему компьютеру. Если мы представим полный путь до папки в виде строки, то получим `C:\msys64`.

{caption: "Иллюстрация 2-5. Окно Проводника Windows"}
![Окно Проводника Windows](images/Bash/explorer.png)

В окне терминала выводится та же самая информация: какая папка "открыта" в данный момент. Но между путём в Bash и Проводнике есть важное различие. Структуры каталогов в ОС Windows и Linux различаются. В Windows каждому физическому или логческому диску соответствует буква латинского алфавита. По умолчанию системный диск, на который была установлена ОС, обозначается буковой `C`. Он представляет собой папку в Проводнике. Внутри неё находятся все файлы и папки, хранящиеся на соответствующем диске.

Диск на который была установлена ОС называется **системным**. На нём Windows создаёт [стандартные каталоги](https://en.wikipedia.org/wiki/Directory_structure#Windows_10), необходимые для её работы: `Windows`, `Program Files`, `Program Files (x86)`, `Users`, `PerfLogs`. Другие логические и физические диски будут обозначаться буквами: `D`, `E`, `F` и т.д. Структуру каталогов на них пользователь выбирает произвольно. Такая организация файловой системы была разработана компанией Microsoft и не соответствует какому-либо стандарту.

Структура каталогов Linux придерживается [стандарта POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap10.html#tag_10). Поскольку Bash разрабатывался для POSIX-совместимых ОС, ему требуется соответствующая структура каталогов для корректной работы.

В чём же различие структуры каталогов Windows и Linux? Ключевая особенность Linux в том, что все логические и физические диски монтируются (т.е. подключаются) в [корневую файловую систему](https://en.wikipedia.org/wiki/Root_directory). То есть у компьютера есть специальный каталог верхнего уровня, который обозначается символом `/` и называется [**корневым**](https://ru.wikipedia.org/wiki/Каталог_(файловая_система)#Корневой_каталог). Он включает в себя файлы и каталоги всех физических и логических дисков, подключённых к системе. Путь по которому находится структура каталогов подключённого диска называется его [**точкой монтирования**](https://ru.wikipedia.org/wiki/Точка_монтирования). Перейдя по этому пути, вы окажетесь в другой файловой системе. Все точки монтирования находятся внутри корневого каталога.

Рассмотрим пример. Предположим, что у нас есть Windows система с 2-мя физическими дисками, обозначенными буквами `C` и `D`. Тогда структура каталогов первого уровня иерархии может выглядеть так, как демонстрирует листинг 2-1.

{caption: "Листинг 2-1. Структура каталогов первого уровня в ОС Windows", line-numbers: false}
```
C:\
    PerfLogs\
    Windows\
    Program Files\
    Program Files (x86)\
    Users\

D:\
    Data\
    Install\
```

В Linux эта же самая иерархия каталогов будет выглядеть согласно листингу 2-2.

{caption: "Листинг 2-2. Структура каталогов в ОС Linux", line-numbers: false}
```
/
    c/
        PerfLogs/
        Windows/
        Program Files/
        Program Files (x86)/
        Users/

    d/
        Data/
        Install/
```

Помните, что как только вы запускаете терминал MSYS2, вы оказываетесь в структуре каталогов Linux. Поэтому, например, путь `C:\Windows` станет недоступным. Вместо него вы должны использовать путь `/c/Windows`.

I> Важная особенность POSIX совместимых систем заключается в [чувствительности к регистру символов](https://ru.wikipedia.org/wiki/Чувствительность_к_регистру_символов). Это означает, что строки `Data` и `data` различаются. В Windows чувствительности к регистру нет. Поэтому вы можете задать в адресной строке Проводника путь `c:\windows`. В результате будет открыт системный каталог `Windows`. В Linux и Bash это не сработает. Вам нужно вводить все символы пути в правильном регистре. Так же обратите внимание, что в Bash в качестве разделителя между именами каталогов и файлов спользуется символ [**слэш**](https://ru.wikipedia.org/wiki/Косая_черта) `/`, а не [**обратный слэш**](https://ru.wikipedia.org/wiki/Обратная_косая_черта) `\`, как в Windows.

#### Команды навигации по файловой системе

Вернёмся к нашему окну терминала, изображённому на иллюстрации 2-3. Последняя отображаемая в нём строка состоит из единственного смвола `$`. Он называется приглашением командной строки. Если последним напечатанным символом в терминале было приглашение, значит интерпретатор готов прочитать и исполнить очередную команду от пользователя. В противном случае интерпретатор занят и ваш ввод не будет обработан.

Рассмотрим наиболее часто используемые команды для навигации по файловой системе. Они приведены в таблице 2-1.

{caption: "Таблица 2-1. Команды для навигации по файловой системе", width: "100%"}
| Команда | Описание | Примеры |
| --- | --- | --- |
| `ls` | Вывод на экран содержимого указанного каталога. Если каталог не указан, быдет выведено содержимое текущего. | `ls` |
| | | `ls /c/Windows` |
| --- | --- | --- |
| `pwd` | Вывести на экран пути до текущего каталога. Ключ `-W` позволяет вывести путь в структуре каталогов Windows | `pwd` |
| | | `pwd -W` |
| --- | --- | --- |
| `cd` | Перейти в указанный каталог по относительному или абсолютному пути. | `cd tmp` |
| | | `cd /c/Windows` |
| | | `cd ..` |
| --- | --- | --- |
| `mount` | Выполнить подключение файловой системы в корневую. При запуске без параметров выводится список всех подключенных в данный момент систем. | `mount` |
| --- | --- | --- |
| `find` | Найти указанный файл или каталог. Первым параметром команды указывается каталог, начиная с которого будет вестись поиск. Если он не указан, используется текущий каталог. | `find . -name vim` |
| | | `find /c/Windows -name *vim*` |
| `grep` | Найти файл по его содержимому. | `grep "PATH" *` |
| | | `grep -Rn "PATH" .` |
| | | `grep "PATH" * .*` |

I> Есть простое правило, чтобы отличить в Bash абсолютный путь от относительного. Если он начинается с символа `/` (например, `/c/Windows`), перед вами абсолютный путь. Если же путь начинается с имени каталога (например, `c/Windows`), то он относительный.

##### pwd

Рассмотрим каждую из команд таблицы 2-1. Мы только что запустили терминал. Первым делом всегда полезно уточнить текущий каталог. Терминал MSYS2 выводит эту информацию перед приглашением командной строки. Преположим, что этого не происходит. Воспользуемся командой `pwd`. Мы получим результат, приведённый в верхней части иллюстрации 2-6. Он означает, что сейчас мы находимся в домашнем каталоге пользователя `/home/ilya.shpigor`. Если вы укажете ключ `-W`, то будет выведен текущий путь в структуре каталогов Windows. Это может быть полезно, если вы создали какие-то файлы в окружени MSYS2 и хотите открыть их в Windows приложении.

{caption: "Иллюстрация 2-6. Вывод команды `pwd`"}
![Вывод pwd](images/Bash/pwd-command.png)

I> При запуске терминала MSYS2 текущим каталогом является домашний каталог пользователя. Перед приглашением командной строки он указан как `~`. Это сокращённое обозначение каталога текущего пользователя. Вы можете работать с ним также, как и с любым другим абсолютным путём.

В интерпретаторе командной строки Bash есть функция автодополнения, которая значительно ускоряет набор текста. Она вызывается по нажатию клавиши `Tab`. Если вы набрали текст и по нему Bash может однозначно определить, какая команда имеется ввиду, он допишет её за вас. Если же есть несколько команд, которые начнаются с введёных букв, автодополнение не произойдёт. В этом случае нажмите Tab повторно, чтобы увидеть список всех доступных команд. Иллюстрация 2-7 демонстрирует вывод по двойному нажатию Tab после ввода текста `pw`.

{caption: "Иллюстрация 2-7. Автодополнение для команды `pw`"}
![Автодополнение pw](images/Bash/pw-autocompletion.png)

##### ls

После уточнения текущего каталога, будет полезно узнать его содержимое. Для этого воспользуемся командой `ls`. Её вывод для домашнего каталога `~` будет пустым, как в верхней части иллюстрации 2-8. Попробуем выполнить эту команду с параметром `-a`. Вы увидите восемь файлов, начинающихся с точки, как в нижней части иллюстрации 2-8.

{caption: "Иллюстрация 2-8. Вывод команды `ls`"}
![Вывод ls](images/Bash/ls-command.png)

Файлы и каталоги являются скрытыми, если их имена начинаются с точки. Как правило, они создаются приложениями автоматически и хранят их конфигурацию. Ключ `-a` команды `ls` позволяет вывести скрытые файлы и каталоги.

Если вам надо вывести содержимое одного из подкаталогов, просто укажите его абсолютный или относительный путь параметром команды `ls`. Иллюстрация 2-9 демонстриурет вывод для команды `ls /`.

{caption: "Иллюстрация 2-9. Вывод команды `ls`"}
![Вывод ls](images/Bash/ls-root-command.png)

Обратите внимание, что в полученом нами выводе нет подкаталогов `/c` и `/d`, которые упоминались в листинге 2-2. На самом деле эти каталоги представляют собой точки монтирования соответствующих дисков. То есть в структуре каталогов Windows этих путей нет. Они создаются в окружении Linux, чтобы вы смогли перейти в корневые каталоги дисков `C` и `D`. Утилита `ls` читает содержимое каталога в окружении Windows, поэтому и не отображает точки монтирования.

##### mount

Когда к вашему компьютеру подключено несколько дисков, может быть полезно вывести на экран их точки монтирования. Эту задачу выполняет команда [`mount`](https://ru.wikipedia.org/wiki/Mount), запущенная без параметров. Иллюстрация 2-10 демонстрирует результат выполнения этой команды в моём случае.

{caption: "Иллюстрация 2-10. Результат выполнения команды `mount`"}
![Результат mount](images/Bash/mount-command.png)

Рассмотрим этот вывод подробнее. Его следует рассматривать как таблицу из четырёх столбцов. В первом из них указывается диск, его раздел или просто каталог, который был смонтирован в корневую [**файловую систему**](https://ru.wikipedia.org/wiki/Файловая_система) (ФС). Второй столбец указывает точку монтирования, то есть путь по которому доступен смонтированный диск. В третьем столбце указывается тип его файловой системы. Четвёртый столбец содержит атрибуты доступа (например, только для чтения или для чтения и записи).

Таблица 2-2 представляет собой вывод команды `mount` с иллюстрации 2-8, разделённый на столбцы.

{caption: "Таблица 2-2. Результат выполнения команды `mount`", width: "100%"}
| Монтируемый раздел | Точка монтирования | Тип ФС | Атрибуты доступа |
| --- | --- | --- | --- |
| `C:/msys64` | `/` | `ntfs` | `binary,noacl,auto` |
| `C:/msys64/usr/bin` | `/bin` | `ntfs` | `binary,noacl,auto` |
| `C:` | `/c` | `ntfs` | `binary,noacl,posix=0,user,noumount,auto` |
| `Z:` | `/z` | `hgfs` | `binary,noacl,posix=0,user,noumount,auto` |

Таблица 2-2 может вызвать недоумение у Windows-пользователей. Корневым каталогом для Bash является `C:/msys64`. Но поскольку все точки монтирования находятся в нём, то диск `C` также является его подкаталогом с путём `/c`. С точки зрения файловой системы Windows зависимость обратная: `C:/msys64` является подкаталогом диска `C`. Такое противоречие не вызывает проблем. Как мы уже выяснили, путь `/c` является точкой монтирования. То есть такой каталог в окружении Windows не существует. Его можно рассматривать просто как [**ссылку**](https://ru.wikipedia.org/wiki/Символическая_ссылка) на диск `C` в окружени MSYS2.

I> Чтобы очистить окно терминала от текста, нажмите комбинацию клавиш Ctrl+L. Чтобы очистить поле ввода или прервать выполнение работающей команды, нажмите Ctrl+C.

##### cd

После того как мы опредеились с текущим местоположением, можно перейти в нужный нам каталог. Допустим, что нас интересует документация по интерпретатору Bash. Попробуем её найти в соответствующем каталоге. Наберите команду `cd /usr`. Не забывайте про автодополнение. Оно работает как для самих команд, так и для их аргументов. В нашем случае будет достаточно набрать `cd /u` и нажать клавишу Tab. Имя каталога `usr` будет введено автоматически. Результат выполнения команды приведён на иллюстрации 2-11.

{caption: "Иллюстрация 2-11. Результат выполнения команды `cd`"}
![Результат cd](images/Bash/cd-command.png)

Обратите внимание, что команда `cd` в случае успешного выполнения ничего не выводит. Единственное, что изменилось - это текущий каталог, который выводится перед приглашением командной строки. Теперь мы находимся в `/usr`. 

Команда`cd` работает как с абсолютными путями, так и относительными. Относительные пути короче и удобнее в наборе. Только что мы перешли в каталог `/usr` по его абсолютному пути. Вопрос - как нам вернуться обратно в корневой каталог? Можно воспользоваться его абсолютным путём: `cd /`. Либо специальным относительным путём `..`, который означает каталог на уровень выше по иерархии. Тогда команда перехода будет выглядеть как `cd ..`.

I> Кроме `..` в Bash есть еще один специальный путю `.`, который означает текущий каталог. То есть если вывполните `cd .`, то ничего не произойдёт. Вы останетесь в том же текущем каталоге.

Если вы воспользуетесь командой `ls`, то обнаружите несколько подкаталогов, среди которых есть `share`. В нём есть подкаталог `doc/bash`. Перейдите в него командой `cd share/doc/bash`. По `ls` вы обнаружите там файл: `README`. Нас интересует второй. Выведите его содержимое на экран командой `cat README`. Её результат приведён на иллюстрации 2-12.

{caption: "Иллюстрация 2-12. Результат выполнения команды `cat`", height: "30%"}
![Результат cat](images/Bash/cat-command.png)

Обратите внимание, что из-за большого размера файла весь вывод команды не поместился на экране. Но он остался в истории терминала. Вы можете воспользоваться полосой прокрутки в правой части окна, чтобы прочитать начало файла `README`. Так же для прокрутки по [страницам](https://en.wikipedia.org/wiki/Page_Up_and_Page_Down_keys) можно использовать горячие клавиши Shift+PageUp и Shift+PageDown, а по строкам - Shift+↑ и Shift+↓.

Каждая введённая в терминал команда сохраняется в [истории команд](https://ru.wikipedia.org/wiki/History). Вы можете прокручивать историю назад и вперёд стрелками вверх и вниз соответственно. Например, вы только что ввели команду `cat README`. Чтобы её повторить, нажмите стрелку вверх и клавишу Enter. Комбинация клавиш Ctrl+R вызывает поиск по истории. Нажмите комбинацию и начните набирать текст. Bash предложит вам последнюю введёную команду, которая начинается так же. Чтобы исполнить её, просто нажмите Enter.

I> В терминале MSYS2 работает [буфер обмена](https://ru.wikipedia.org/wiki/Буфер_обмена). Он представляет собой промежуточное хранилище данных. Вы можете поместить в него выбранный текст, а затем вставить его в другое место или приложение. Для копирования текста из терминала в буфер обмена, его достаточно просто выделить мышью, зажав её левую кнопку. Чтобы вставить текст в окно терминала, нажмите среднюю кнопку мыши. В другие приложения вы можете вставить текст, нажав правую кнопку мыши и выбрав пункт "Вставить".

##### find

Ещё команда для навигации по файловой системе, которую мы рассмотрим, называется `find`. Это мощный инструмент для обработки большого числа файлов и каталогов, но обычно он используется для поиска.

Если вы запустите `find` без параметров, она выведет всё содержимое текущего каталога и его подкаталогов. Иллюстрация 2-13 демонстрирует результат выполнения `find` для домашнего каталога пользователя `~`.

{caption: "Иллюстрация 2-13. Результат выполнения команды `find`", height: "30%"}
![Результат find](images/Bash/find-command.png)

Первым параметром команды `find` можно указать относительный или абсолютный каталог, в котором она будет исполнена. Например, для корневого каталога вызов будет выглядеть как `find /`. Вторым параметром указывается выражение из одного и более элементов. Оно определяет, какие именно файлы и каталоги попадут в вывод команды. Для обработки выражений в `find` встроен собственный небольшой интерпретатор.

Наиболее часто используемые выражения приведены в таблице 2-3.

{caption: "Таблица 2-3. Часто используемые выражения команды `find`", width: "100%"}
| Выражение | Значение | Пример |
| --- | --- | --- |
| `-type f` | Искать только файлы. | `find -type f` |
| `-type d` | Искать только каталоги. | `find -type d` |
| `-name шаблон` | [**Шаблон имени**](https://ru.wikipedia.org/wiki/Шаблон_поиска) файла или каталога, чувствительный к регистру. | `find -name README` |
| | | `find -name READ*` |
| | | `find -name READ??` |
| `-iname шаблон` | Шаблон имени файла или каталога, нечувствительный к регистру. | `find -iname readme` |
| `-path шаблон` | Шаблон пути к файлу или каталогу, чувствительный к регистру. | `find -path */doc/bash/*` |
| `-ipath шаблон` | Шаблон пути к файлу или каталогу, нечувствительный к регистру. | `find . -ipath */DOC/BASH/*` |
| `-a` или `-and` | Скомбинировать несколько выражений по условию логического И. Это означает, что в вывод команды попадут только файлы и каталоги, удовлетворяющие всем выражениям. | `find -name README -a -path */doc/bash/* ` |
| `-o` или `-or` | Скомбинировать несколько выражений по условию логического ИЛИ. То есть выполнения одного из выражений будет достаточно. | `find -name README -o -path */doc/bash/* ` |
| `!` или `-not` | Логическое отрицание (НЕ) последующего выражения. То есть в вывод попадут только файлы и каталоги, которые не удовлетворяют выражению. | `find -not -name README` |
| | | `find ! -name README` |

I> Во всех шаблонах команды `find` можно использовать [**символы подстановки**](https://ru.wikipedia.org/wiki/Символ_подстановки). Всего в Bash таких символов два: `*` и `?`. Звёздочка означает любое количество любых символов. Знак вопроса - один любой символ. Например, строка `README` будет соответствовать следующим шаблонам: `*ME`, `READM?`, `*M?`, `R*M?`.

{caption: "Упражнение 2-1. Шаблоны поиска", line-numbers: false}
```
Какая из следующих строк соответствует шаблону `*ME.??`:
* 00_README.txt
* README
* README.md
```

{caption: "Упражнение 2-2. Шаблоны поиска", line-numbers: false}
```
Какая из следующих строк соответствует шаблону `*/doc?openssl*`:
* /usr/share/doc/openssl/IPAddressChoice_new.html
* /usr/share/doc_openssl/IPAddressChoice_new.html
* doc/openssl
* /doc/openssl
```

Рассмотрим подробнее использование выражений `find`. Вернёмся к нашему примеру с поиском документации по Bash. Предположим, что мы находимся в корневом каталоге. Можно начать наш поиск с указания пути. В Linux обычно все документы хранятся в каталогах с именем `doc`. Поэтому будет логично использовать следующую команду для поиска:
{line-numbers: false}
```
find / -path */doc/*
```
Мы получим список всех файлов документации в системе. Чтобы ограничить его только файлами относящимися к Bash, воспользуемся условием И:
{line-numbers: false}
```
find / -path */doc/* -path */bash/*
```
Обратите внимание, что мы опустили параметр `-a`. Если не указан никакой параметр, то `find` по умолчанию будет использовать условие логического И. Следующая команда вернёт точно такой же результат (см. иллюстрацию 2-14):
{line-numbers: false}
```
find / -path */doc/* -a -path */bash/*
```

{caption: "Иллюстрация 2-14. Результат выполнения команды `find`", height: "30%"}
![Результат find](images/Bash/find-path-path.png)

I> В конце своего вывода команда `find` сообщает об ошибке. Проблем в том, что некоторые файлы из корневого каталога не могут быть прочитаны. Речь идёт о точках монтирования дисков `C` и `Z`: `/c` и `/z` соответственно. Чтобы искать файлы и каталоги на этих дисках с помощью `find`, вам надо сначала перейти в их файловые системы командой `cd`.

В результате мы получили относительно небольшой список документов, среди которых легко найти нужный нам `README`.

Мы могли бы следовать другой стратегии поиска. Предположим, что нам известно имя искомого файла. Тогда имеет смысл указать его вместе с предполагаемым путём:
{line-numbers: false}
```
find / -path */doc/* -name README
```
Иллюстрация 2-15 демонстрирует результат такого поиска.

{caption: "Иллюстрация 2-15. Результат выполнения команды `find`", height: "30%"}
![Результат find](images/Bash/find-path-name.png)

Мы снова получили относительно небольшой список, в котором легко найти `README` файл, относящийся к Bash.

Выражения `find` можно группировать. Для этого следует использовать [экранированные](https://ru.wikipedia.org/wiki/Экранирование_символов) скобки. Напримерм следующая команда ищет файлы `README` с путём `*/doc/*` или файлы LICENSE с произвольным путём.
{line-numbers: false}
```
find / \( -path */doc/* -name README \) -o -name LICENSE
```

I> Почему скобки, передаваемые в команду `find`, должны экранироваться обратным слэшем? Дело в том, что для языка Bash это [управляющие символы](https://ru.wikipedia.org/wiki/Управляющие_символы), т.е. они имеют некоторое синтаксическое значение. Поэтому когда Bash попытается вызвать команду `find`, он не может корректно интерпретировать значение скобок. Чтобы заставить его игнорировать скобки и просто передать их на вход `find`, они должны быть экранированы.

По-настоящему мощным инструментом команду `find` делает необязательный последний параметр, который задаёт действие. Это действие будет применено к каждому из найденных файлов и каталогов.

Таблица 2-4 демонстрирует наиболее часто используемые действия.

{caption: "Таблица 2-4. Часто используемые действия команды `find`", width: "100%"}
| Действие | Значение | Пример |
| --- | --- | --- |
| `-exec команда {} \;`| Выполнить указанную команду над каждым из найденных файлов или каталогов. | `find -name README -type f -exec cat {} \;` |
| `-exec команда {} +`| Выполнить указанную команду над всеми найденными файлами или каталогами. То есть они все будут переданы на вход этой команды. | ` find -type d -exec ls {} +` |
| `-delete`| Удалить каждый из найденных файлов. Обратите внимание, что каталоги будут удаляться только если они пустые. | `find -name README -type f -delete` |

I> Обратите внимание, что действие `-exec` с `{} +` на конце вы можете указывать только для команд, поддерживающих несколько аргументов. Большинство GNU утилит их поддерживает. В противном случае команда обработает только первый найденный файл или каталог.

Рассмотрим пример использования действия `-exec`. Достаточно часто встречается случай, когда вам надо найти какие-то файлы и скопировать их другое место. Предположим, что мы ищем все файлы документации по Bash с расширением HTML. Тогда команда поиска будет выглядеть следующим образом:
{line-numbers: false}
```
find / -path "*/doc/bash/*" -name "*.html"
```

I> Хорошей практикой в Bash считается заключать все шаблоны в двойные кавычки ". Смысл кавычек точно такой же, в случае экранирования  управляющих символом обратным слэшем. Таким образом мы даём Bash понять, что ему не следует интерпретировать шаблоны самому, а вместого этого просто передавать их вызываемой команде.

Результат её выполнения представлен на иллюстрации 2-16.

{caption: "Иллюстрация 2-16. Результат выполнения команды `find`", height: "30%"}
![Результат find](images/Bash/find-html.png)

Добавим к этой команде параметр `-exec`, вызывающий утилиту `cp`.  Эта утилита выполняет компирование файлов и каталогов. Первым её параметром указывается что следует скопировать, а вторым - куда копировать. Теперь вызов `find` выглядит следующим образом:
{line-numbers: false}
```
find / -path "*/doc/bash/*" -name "*.html" -exec cp {} ~ \;
```
Эта команда ничего не выведет в терминал (кроме уже знакомой нам ошибки с точками монтирования). Что произошло в ходе её выполнения? Для каждого найденного HTML файла (см. иллюстрацию 2-16) вызывается команда `cp`. В неё первым параметром вместо скобочек `{}` передаётся соответствующий путь. Поскольку было найдено два HTML файла, произойдёт только два вызова команды `cp`:
{line-numbers: false}
```
cp ./usr/share/doc/bash/bash.html ~
cp ./usr/share/doc/bash/bashref.html ~
```
В результате каждого вызова соответствующий HTML файл будет скопирован в домашний каталог пользователя.

Можно сказать, что только что мы написали простую программу на языке интерпретатора команды `find`. Её алгоритм выглядит следующим образом:

1. Найти файлы с расширением HTML, хранящиеся в корневом каталоге. Их пути должны соответствовать шаблону `*/doc/bash/*`.

2. Скопировать каждый из найденных файлов в каталог пользователя.

Программа состоит всего из двух действий. Но она окажется очень полезной, если вам нужно обработать значительное число файлов. Просто представьте себе, сколько времени у вас бы ушло на поиск файлов на диске `C` по таким же критериям и их копирование через графический интерфейс.

Действия `-exec` можно комбинировать точно так же как и выражения с условиями поиска. Предположим, что нам надо вывести содержимое каждого из найденных HTML файлов и подсчитать количество строк в нём. Для вывода содержимого воспользуемся уже знакомой нам командой `cat`. Для подсчёта строк применим команду `wc` с параметром `-l`. На вход она принимает имя файла, который надо обработать. Команда `find` в этом случае будет выглядеть следующим образом:
{line-numbers: false}
```
find / -path "*/doc/bash/*" -name "*.html" -exec cat {} \; -exec wc -l {} \;
```

В этом примере между действиями `-exec` логический оператор не указан. По умолчанию используется `-a` или логическое И. Это означает, что второе действие будет выполнено только при успешном исполнения первого. Мы можем заменить логический оператор на ИЛИ. Тогда второе действие будет выполняться всегда, независимо от результата первого.

Действия `-exec` можно группировать с помощью экранированных скобок `\(` и `\` точно так же как и условия поиска.

{caption: "Упражнение 2-3. Использование команды `find`", line-numbers: false}
```
Напишите команду find для поиска всех TXT файлов в вашем Linux окружении. Дополните команду, чтобы вывести общее число строк в этих файлах.
```

##### grep

Ещё одним мощным инструментом поиска является утилита `grep`. Мы познакомились с `find`, которая позволяет искать файлы и каталоги по их имени, пути и [метаданным](https://ru.wikipedia.org/wiki/Метаданные). К метаданным относятся размер (в случае файла), время создания и последней модификации, права доступа.

Представьте, что на всём системном диске вы ищете текстовый файл, в котором встречается фраза "free software" (свободное ПО). Алгоритм такого поиска может выглядеть следующим образом:

1. Найти все текстовые файлы на диске с помощью `find`.

2. Открыть каждый файл в текстовом редакторе и проверить наличие фразы "free software".

Это огромная ручная работа, которая займёт массу времени. Команда `grep` создана как раз для решения подобных задач.

Чтобы найти текст в указанном файле, запустите `grep` со следующими параметрами:
{line-numbers: false}
```
grep "free software" /usr/share/doc/bash/README
```
Первым параметром указывается строка для поиска. В нашем случае это "free software". Не забывайте про двойные кавычки, иначе слово software будет обработано `grep`, как имя файла. Следующими параметрами идут относительные или абсолютные пути до интересующих нас файлов, разделённые пробелом. Мы передаём только `README` документацию на Bash. Результат выполнения команды приведён на иллюстрации 2-17.

{caption: "Иллюстрация 2-17. Результат выполнения команды `grep`", width: "100%"}
![Результат grep](images/Bash/grep-command.png)

Обратите внимание, что вывод можно более информативным. Для этого передайте параметр `-n`. Благодаря ему, команда `grep` выведет номер строки файла, в которой встречается искомая фраза "free software". В нашем случае это 22-я строка.

Мы выяснили, как с помощью `grep` искать строки в одном файле. Но как эта команда поможет нам найти нужный файл из многих? Для этой цели `grep` можно использовать двумя способами.

В первом способе мы применим функцию Bash для разворачивания шаблона имени файла. Предположим, что в домашнем каталоге пользователя находятся два текстовых файла: `bash.txt` и `xz.txt`. Это копии `README` документов соответствующих программ. Наша задача проверить, встречается ли фраза "free software" в этих файлах. Для этого выполним следующее:
{line-numbers: false}
```
cd ~
grep "free software" *
```
Сначала мы перешли в домашний каталог пользователя. Затем вызвали команду `grep`. В качестве целевого файла мы использовали символ подстановки звёздочка. Это шаблон поиска, означающий любую строку. Перед вызовом `grep` Bash развернёт этот шаблон и передаст результат утилите. В результате её вызов будет выглядеть следующим образом:
{line-numbers: false}
```
grep "free software" bash.txt xz.txt
```
Поробуйте оба варианта вызова `grep`. Вы получите одинаковый результат.

I> Чтобы вывести на экран результат разворачинвания шаблона Bash, можно воспользоваться командой echo:
{line-numbers: false}
```
echo *
```

В данном случае важно не заключать символ звёздочки в двойные кавычки:
{line-numbers: false}
```
grep "free software" "*"
```
Если сделать так, то шаблон поиска будет передан как есть в `grep`. В отличие от `find` утилита `grep` не умеет самостоятельно разворачивать шаблоны. Поэтому будет выведено сообщение об ошибке как на иллюстрации 2-18.

{caption: "Иллюстрация 2-18. Результат передачи шаблона в `grep`", width: "100%"}
![Результат grep](images/Bash/grep-error.png)

I> Bash не включает скрытые файлы в шаблон `*`. Это означает, что команда `grep` не получит их на вход. Чтобы искать по скрытым файлам, используйте шаблон `.*`. Можно указывать оба шаблона сразу, чтобы искать по всем файлам:
{line-numbers: false}
```
grep "free software" * .*
```

Второй способ поиска с помощью `grep` заключается в использовании встроенной в утилиту функии перебора файлов в указанном каталоге. Для её включения необходимо указать параметр `-r`:
{line-numbers: false}
```
grep -r "free software" .
```
Приведённая команда ищет фразу "free software" во всех файлах текущего каталога. Если вы хотите также проверить файлы подкаталогов, то воспользуйтесь флагом `-R`:
{line-numbers: false}
```
grep -R "free software" .
```
Целевой каталог для поиска можно указывать по относительному и абсолютному путям:
```
cd  /home
grep -R "free software" ilya.shpigor/tmp
grep -R "free software" /home/ilya.shpigor/tmp
```

I> Утилита `grep`, запущенная с параметрами `-r` и `-R`, корректно обработает скрытые файлы и каталоги.

Если вас интересуют только имена файлов, в которых встречается указанная строка, воспользуётесь ключом `-l`:
{line-numbers: false}
```
grep -Rl "free software" .
```

Скорее всего, познакомившись с утилитой `grep`, вам захочется применить её для поиска документов в формате [PDF](https://ru.wikipedia.org/wiki/Portable_Document_Format) и MS Office. К сожалению, это не сработает. Файлы в этих форматах не являются текстовыми. Эта задача может быть решена установкой дополнительных утилит. Мы рассмотрим их далее, когда будем обсуждать пакетный менеджер.

Файлы с исходным кодом программ являются текстовыми. Поэтому утилита `grep` отлично подходит для поиска по ним.

{caption: "Упражнение 2-4. Использование команды `grep`", line-numbers: false}
```
Напишите команду grep для поиска приложений MSYS2, распространяющихся под указанной лицензией. В сообществе свободного ПО самые распространённые лицензии следующие:

1. GNU General Public License
2. MIT license
3. Apache license
4. BSD license
```

### Информация о командах

Мы научились основным командам навигации по файловой системе. Прежде чем продолжить наше знакомство с интерпретатором командной строки Bash, стоит рассмотреть один важный вопрос: где можно получить информацию о той или иной команде? Разработчики первых версий UNIX подумали над этой проблемой. В случае графического интерфейса, элементарные действия интуитивно понятны. Но при работе с командной строкой всё не так очевидно. Пользователь может оказаться с системой один на один и у него должен быть способ самостоятельно получить нужную информацию.

Начнём со справки о встроенных командах интерпретатора Bash. Чтобы вывести её на экран, выполните команду `help`. Результат приведён на иллюстрации 2-19.

{caption: "Иллюстрация 2-19. Результат выполнения команды `help`", height: "50%"}
![Результат help](images/Bash/bash-help.png)

В выводе `help` указаны все команды, которые интерпретатор Bash исполняет самостоятельно. Кроме них, есть ещё GNU утилиты. Например, команда `cd` есть в списке `help`. Это значит, что Bash выполняет её сам, не вызывая какое-то вспомогательное приложение. Когда же вы вводите команду `find`, которой в списке `help` нет, Bash ищет соответствующую утилиту на жёстком диске и запускает её с указанными вами параметрами.

Где Bash ищет утилиты для выполнения команд? У него есть список путей для их поиска. Этот список хранится в переменной [**переменной окружения**](https://ru.wikipedia.org/wiki/Переменная_среды) с именем `PATH`. [**Переменную**](https://ru.wikipedia.org/wiki/Переменная_(программирование)) можно представить как некоторое значение, которое имеет имя. Например, мы можем сказать, что текущее время 12 часов. В этом случае именем переменной будет "время", а значением "12 часов".

Значение переменных в Bash можно выводить командой `echo`. Чтобы вывести переменную с именем `PATH`, выполните следующее:
{line-numbers: false}
```
echo "$PATH"
```

Зачем нам понадобился знак доллара `$` перед именем переменной? Вообще, команда `echo` выводит строку, которую получает входным параметром. Например, если вы выполните `echo 123`, то получите в выводе `123`. Когда вы ставите `$` перед каким-то словом, вы сообщаете Bash, что это имя переменной. Интерпретатор, встретив имя переменной в какой-то строке, ищет его в своём списке. Если это имя ему известно, он подставит вместо него значение переменной. В противном случае будет подставлена пустая строка.

I> Заключать имена переменных в строках в двойные кавычки `"` считается [хорошей практикой](https://www.tldp.org/LDP/abs/html/quotingvar.html). Это позволяет избежать потенциальных ошибок. Например, Bash подставляет значение переменной вместо её имени. Если в подстановке встречаются управляющие символы, они будут обработаны интерпретатором. В результате вставленное значение переменной будет отличаться от того, что хранится в памяти Bash. Это может привести к некорректному поведению программы.

Вернёмся к нашей команде вывода переменной `PATH`. После её выполнения будет распечатана строка как на иллюстрации 2-20.

{caption: "Иллюстрация 2-20. Значение переменной `PATH`", height: "30%", width: "100%"}
![Значение PATH](images/Bash/echo-path.png)

Что означает этот вывод? Перед нами строка, которая состоит из набора путей, разделённых двоеточиями. Если мы представим эти пути в виде списка, он будет выглядеть следующим образом:
{line-numbers: false}
```
/usr/local/bin
/usr/bin
/bin
/opt/bin
/c/Windows/System32
/c/Windows
/c/Windows/System32/Wbem
/c/Windows/System32/WindowsPowerShell/v1.0/
```

I> Если у вас ещё не было опыта программирования, может возникнуть вопрос: зачем в переменной `PATH` хранить пути, разделённые двоеточиями, а не символами перевода строки? Тогда бы при выводе переменной на экран, её было бы удобнее читать. Короткий ответ заключается в том, что так проще программировать. Использование символа перевода строки `\n` чревато ошибками при работе с переменной.

Итак, вернёмся к нашей задаче получения информации о доступных командах. Будет логичным искать вспомогательные утилиты там же, где их ищет Bash. Команда `find` поможет вам с поиском нужного файла в каждом из каталогов `PATH`. Так вы обнаружите, что сама утилита `find`, например, находится в обоих каталогах `/bin` и `/usr/bin`.

I> Чтобы вывести все переменные окружения, установленные в данный момент, воспользуйтесь командой `env` без параметров.

Узнать путь до той или иной утилиты, используемой Bash, поможет команда интерпретатора `type`. Вызовите её, передав первым параметром имя интересующей вас утилиты. В результате будет выведен абсолютный путь до неё как на иллюстрации 2-21.

{caption: "Иллюстрация 2-21. Результат выполнения команды `type`", height: "30%"}
![Результат `type`](images/Bash/type-command.png)

Предположим, что мы нашли интересующую нас утилиту по одному из путей `PATH`. Как узнать, какие входные параметры она принимает? Если вам нужна краткая справка, вызовите утилиту и передайте входным параметром строку `--help`. Иллюстрация 2-22 демонстрирует вывод справки для команды `cat`.

{caption: "Иллюстрация 2-22. Справка команды `cat`", height: "50%"}
![Справка `cat`](images/Bash/cat-help.png)

Если на вашей системе в качестве языка по умолчанию установлен английский, то скорее всего информация о командах будет доступна только на нём. Перевод вы можете найти в [интернете](https://www.opennet.ru/man.shtml?topic=cat&russian=0&category=&submit=%F0%CF%CB%C1%DA%C1%D4%D8+man), но это не всегда удобно. Поэтому постарайтесь всегда настраивать ОС на подходящий вам язык. В случае Linux, документация по командам тоже должна переключиться на указанный язык.

Если вам нужна более детальная информация о команде, воспользуйтесь системой документации `info`. Например, вы хотите узнать примеры использования утилиты `cat` или получить её подробное описание. Для этого вызовите команду:
{line-numbers: false}
```
info cat
```
Результат приведён на иллюстрации 2-23.

{caption: "Иллюстрация 2-23. Справка info по команде `cat`", height: "50%"}
![Справка info по `cat`](images/Bash/cat-info.png)

Перед вами программа для чтения текстовых документов. Чтобы прокручивать текст вверх и вниз, воспользуйтесь клавишами PageUp и PageDown, либо стрелками. Для выхода из программы нажмите Q.

I> Система документации `info` была введена разработчиками GNU утилит. До этого на UNIX системах повсеместно использовалась более старая программа `man`. Её функциональность очень похожа на `info`. Поэтому в MSYS2 `man` не устанавливается по умолчанию, но вы можете скачать её отдельно. Вызов справки через man выглядит следующим образом:
{line-numbers: false}
```
man cat
```

Мы разобрались со случаем, когда нам известно имя утилиты, способной выполнить нашу задачу. Но как быть, если мы этого не знаем? Лучшим решением будет поиск ответа в интернете через [Google](https://www.google.com). Советы по использованию командной строки, как правило, намного лаконичнее инструкций, связаных с GUI. Вам не нужны скриншоты и видеоролики с объяснением каждого действия. Вместо этого вас интересует одна единственная строчка с вызовом команды, которая сделает то, что надо.

Если ваша задача не совсем обычна, имеет смысл попробовать искать информацию на английском языке. Сообщество англоязычных пользователей Bash огромно, и кто-то наверняка уже сталкивался с вашей задачей и решил её.

{caption: "Упражнение 2-5. Использование системы документации", format: text, line-numbers: false}
```
Прочитайте документацию по каждой из команд, представленных в таблице 2-1. Сравните объём информации, доступный по параметру --help и в системе info. Понятна ли вам эта информация? В случае проблем с переводом английского воспользуйтесь Google Translate (https://translate.google.com). Скопируйте текст из терминала в буфер обмена (левой кнопкой мыши выделение, правой через меню "Скопировать") и вставьте его в окно браузера.
```

### Действия над файлами и каталогами

Мы знаем, как найти нужный нам файл или каталог на диске. Какие действия мы можем над ними совершить? Скорее всего, вам этот список хорошо знаком по опыту работы с графическим интерфейсом ОС:

1. Создание
2. Удаление
3. Копирование
4. Переименование

В таблице 2-5 приводятся команды, соответствующие этим действиям.

{caption: "Таблица 2-5. Команды для работы с файлами и каталогами", width: "100%"}
| Команда | Описание | Примеры |
| --- | --- | --- |
| `mkdir` | Создание каталога с указанным именем и путём. | `mkdir /tmp/docs` |
| | | `mkdir -p tmp/docs/report` |
| --- | --- | --- |
| `rm` | Удалить указанный файл или каталог по абсолютному или относительному пути. | `rm readme.txt` |
| | | `rm -rf ~/tmp` |
| --- | --- | --- |
| `cp` | Скопировать файл или каталог. Первым параметром передаётся текущий путь, а вторым - целевой. | `cp readme.txt tmp/readme.txt` |
| | | `cp -r /tmp ~/tmp` |
| --- | --- | --- |
| `mv` | Переименовать указанный первым параметром файл или каталог. | `mv readme.txt documentation.txt.` |
| | | `mv ~/tmp ~/backup` |

Кратко рассмотрим эти команды. Теперь вы знаете, как пользоваться помощью. Поэтому если возникнут вопросы, вам будет просто найти на них ответы.

##### mkdir

Чтобы создать новый каталог, воспольузйтесь командой `mkdir`. Для этого первым параметром передайте его абсолютный или относительный путь. Например, чтобы создать каталог `docs` в домашнем каталоге пользователя выполните команду:
{line-numbers: false}
```
mkdir ~/docs
```
Либо вы можете сначала перейти в каталог пользователя, а потом создать в нём каталог:
{line-numbers: false}
```
cd ~
mkdir docs
```
У команды `mkdir` есть полезный параметр `-p`. Он позволяет создать не только указанный каталог, но и все его родительские каталоги. Например, вы хотите создать каталог для отчета за 2019 год. Он должен находится по пути `~/docs/reports/2019`. Предположим, что каталоги `docs` и `reports ` ещё не созданы. В графическом интерфейсе Windows вам сначала нужно создать их, а только потом каталог `2019`. В Bash для этого достаточно одной команды:
{line-numbers: false}
```
mkdir -p ~/docs/reports/2019
```
Обратите внимание, что если каталоги `docs` или `reports` уже существуют, сообщения об ошибке не будет. Команда создаст только недостающую часть пути.

##### rm

Команда `rm` удаляет файлы и каталоги. Для удаления одного файла просто укажите его относительный или абсолютный путь. Например:
{line-numbers: false}
```
rm report.txt
rm ~/docs/reports/2019/report.txt
```
Вы может также удалить несколько файлов, указав их через пробел:
{line-numbers: false}
```
rm report.txt ~/docs/reports/2019/report.txt
```
Также можно воспользоваться шаблоном поиска. Следующая команда удаляет все TXT файлы начинающиеся с слова "report":
{line-numbers: false}
```
rm ~/docs/reports/2019/report*.txt
```
Если вы попробуете удалить файл с доступом только на чтение, будет выведено предупреждение как на иллюстрации 2-24.

{caption: "Иллюстрация 2-24. Предупреждение при удалении файла с доступом на чтение", width: "100%"}
![Предупреждение `rm`](images/Bash/rm-warning.png)

Чтобы продолжить удаление, нажмите клавишу y (от yes), а затем Enter. Если вы хотите проигнорировать подобные предупреждения, воспользуйтесь параметром `-f` или `--force` команды `rm`:
{line-numbers: false}
```
rm -f ~/docs/reports/2019/report*.txt
```

Для удаления каталога вместе с его содержимым воспользуйтесь командой `rm` с параметром `-r` или `--recursive`:
{line-numbers: false}
```
rm -r ~/docs
```

#### cp и mv

Команды копирования и переименования файлов и каталогов однотипны. В обеих сначала указывается то, над чем совершается действие, потом путь назначения.

Например, команда для копирования файла `report.txt` в текущем каталоге, выглядит следующим образом:
{line-numbers: false}
```
cp report.txt report-2019.txt
```
После её исполнения будет создан файл `report-2019.txt` с тем же содержимым, что и `report.txt`.

Если старый файл `report.txt` вам больше не нужен, воспользуйтесь командой переимнования:
{line-numbers: false}
```
mv report.txt report-2019.txt
```
В этом случае файл `report.txt` будет удалён.

Вы можете указывать полные пути до файлов. Таким образом они будут копироваться или переносится между разными каталогами:
{line-numbers: false}
```
cp ~/report.txt ~/tmp/report-2019.txt
mv ~/report.txt ~/tmp/report-2019.txt
```

Переименование каталогов происходит точно так же, как и файлов:
{line-numbers: false}
```
mv ~/tmp ~/backup
```
В результате этой команды каталог `tmp` будет переименован в `backup`.

Для копирования каталога вместе с его содержимым необходимо указывать параметр `-r`:
{line-numbers: false}
```
cp -r /tmp ~/tmp
```
Эта команда копирует системный каталог `tmp` в домашний каталог пользователя.

Если при копировании или переименовании в целевом каталоге уже есть файл с тем же именем, будет выдано сообщение с подтверждением его перезаписи. Чтобы автоматически перезаписывать, воспользуйтесь параметром `-f`:
{line-numbers: false}
```
cp -f ~/report.txt ~/tmp
mv -f ~/report.txt ~/tmp
```
Если в каталоге `tmp` уже есть файл с именем `report.txt`, в результате этих команд он будет перезаписан.

{caption: "Упражнение 2-6. Использование команд для работы с файлами и каталогами", format: text, line-numbers: false}
```
Попробуйте упорядочить свой архив фотографий за последние три месяца с помощью изученных нами команд Bash. Перед началом работы обязательно сделайте резервную копию архива. Разделите все фотографии по годам и месяцам. Структура каталогов должна получиться примерно следующая:
~/
  photo/
        2019/
             11/
             12/
        2020/
             01/
```

#### Права доступа

На иллюстрации 2-24 обратите внимание на команду `ls`, запущенную с параметром `-l`. Она выводит таблицу с подробной информацией о файлах и каталогах. Каждому из них соответствует одна строка таблицы. В первом её столбце указаны права доступа. Файл `report.txt` имеет права доступа `-r--r--r--`. Рассмотрим, что означает эта запись.

По опыту использования Проводника Windows вы, возможно, уже знакомы с концепцией прав доступа. У пользователя могут быть права на чтение, редактирование и запуск файла. У разных пользователей права могут отличаться. Это может быть полезно, если несколько человек использует один и тот же компьютер. Будет разумно, если они смогут читать и изменять только свои собственные документы.

В Unix информация о доступе хранится в [**битовой маске**](https://ru.wikipedia.org/wiki/Битовая_маска). Битовая маска - это обычное число. Если представить его в двоичной системе счисления, то получится последовательность нулей и единиц. Для хранения каждого из них в памяти требуется один бит. Главная особенность битовой маски заключается в её интерпретации.

Предположим, что у нас есть набор признаков. Каждый признак либо есть, либо его нет. Если признак есть, соответствующий ему бит равен 1, иначе 0. Например, если мы говорим о доступе к файлу, то признаки могут быть следующие:

1. Разрешение на чтение.
2. Разрешение на запись.
3. Разрешение на исполнени.

Набор этих признаков можно закодировать маской из трёх битов. Допустим, что к файлу есть полный доступ и его можно читать, писать и исполнять. Тогда маска выглядит как:
{line-numbers: false}
```
111
```
Если чтение и исполнение запрещёно, то первый и третий биты будут нулями:
{line-numbers: false}
```
010
```
Надеюсь, что вы уловили суть. Теперь вернёмся к правам доступа в Unix. Строка с правами доступа `-r--r--r--` есть ни что иное, как битовая маска. В ней нулям соответствует тире, а единицам какая-то буква. То есть строку `-r--r--r--` можно представить в виде маски 0100100100. Маске 1111111111 будет соответствовать строка `drwxrwxrwx`.

На самом деле маска прав доступа состоит из четырёх частей. Они приведены в таблице 2-6.

{caption: "Таблица 2-6. Значение позиций букв в строке прав доступа", width: "100%"}

| d | rwx | rwx | rwx |
| --- | --- | --- | --- |
| Признак каталога. | Права владельца файла или каталога. По умолчанию это тот, кто его создал. | Права группы пользователей, привязанной к файлу. По умолчанию это группа, к которой относится владелец. | Права всех остальных пользователей кроме владельца и группы, привязанной к файлу. |

Каждая из этих частей представляет собой отдельную маску. Минимальный размер числа, которым оперируют компьютеры, составляет 4 байта. Поэтому уже знакомая нам строка `-r--r--r--` на самом деле представляется маской 0000 0100 0100 0100.

Что означают буквы в строке прав доступа? Как мы выяснили, это равные единице биты. Позиция каждого из них определяет, какое действие над файлом или каталогом разрешено. Буквы были введены, чтобы упростить чтение битовой маски. Согласитесь, что понять строку `-rw-r--r--` проще и быстрее, чем двоичное число 0000011001000100. Значение каждого символа приведено в таблице 2-7.

{caption: "Таблица 2-7. Значение символов в строке прав доступа", width: "50%"}
| Символ | Значение для файла | Значение для каталога |
| --- | --- | --- |
| d | Если вместо d первым символом стоит тире, это права для файла. | Права доступа соответствуют каталогу.  |
| r | Чтение. | Вывод содержимого каталога. |
| w | Запись. | Создание, переименование или удаление файлов в каталоге . |
| x | Выполнение файла. | Переход в каталог, доступ к его файлам и подкаталогам. |
| - | Отсутствие права. | Отсутствие права. |

Когда к файлу имеют полный доступ все пользователи системы, строка прав выглядит как `-rwxrwxrwx`. Для каталога с такими же правами первый символ тире заменяется на d: `drwxrwxrwx`.

I> Чтобы вывести группы, к которым относится текущий пользователь воспользуйтесь командой group. Эта команда доступна только под Linux и macOS.

Теперь если мы вернёмся к иллюстрации 2-24, мы легко сможем прочитать права доступа к файлам `report.txt` и `report1.txt`. Первый могут читать все пользователи, но его изменение и исполнение запрещено. Второй файл могут читать все, а изменять только владелец. При этом его исполнение также запрещено.

Таблица 2-8 демонстрирует необходимые права доступа к файлу или каталогу, необходимые для выполнения рассмотренных нами команд.

{caption: "Таблица 2-8. Права доступа для команд", width: "100%"}
| Команда | Маска | Права доступа | Комментарий |
| --- | --- | --- | --- |
| `ls` | `r--` | Чтение | Только каталоги. |
| `cd` | `--x` | Выполнение | Только каталоги. |
| `mkdir` | `-wx` | Запись и выполнение. | Только каталоги. |
| `rm` | `-w-` | Запись | Для каталогов надо использовать параметр `-r`. |
| `cp` | `r--` | Чтение | Целевой каталог должен быть доступен на запись и исполнение. |
| `mv` | `r--` | Чтение | Целевой каталог должен быть доступен на запись и исполнение. |
| Исполнение | `r-x` | Чтение и выполнение. | Только для файлов. |

#### Запуск файлов

Для запуска файла в Bash достаточно, чтобы он имел только права на чтение и исполнение. В отличие от требований, принятых в ОС Windows, его расширение может быть произвольным. Он может называться например `report.txt`, но всё равно быть исполняемым.

I> В Unix нет общепринятого соглашения о расширении исполняемых бинарных  файлов. Поэтому чтобы узнать тип файла вам пригодится команда `file`. Примеры её использования:
{line-numbers: false}
```
file /usr/bin/ls
cd /bin
file ls
```

Мы уже знаем, что все GNU утилиты находятся в каталогах `/bin` и `/usr/bin`. Bash хранит их пути в переменной `PATH`. Может возникнуть вопрос: куда устанавливаются приложения в Linux окружении?

В Windows на системном диске есть каталоги `Program Files` и `Program Files (x86)`. По умолчанию все приложения устанавливаются туда. Для каждого приложения создаётся новый каталог (например, `C:\Program Files (x86)\Notepad++`). В процессе установки в него копируются исполняемые файлы, DLL библиотеки, файлы конфигурации и ресурсов. Всё это, а также системные библиотеки Windows необходимы для запуска и работы приложения. Вместо каталогов `Program Files` пользователь может указать любой другой путь установки (например, `D:\Games`).

В Linux окружении есть два общепринятых варианта установки приложения. Первый вариант немного напоминает подход Windows. Установка происходит в каталог `/opt`. В нём создаётся подкаталог (например, `/opt/teamviewer`), куда копируются все файлы приложения. Как правило, этот вариант установки используется проприетарными программами, исходный код которых закрыт.

Второй вариант применяется для приложений с открытым исходным кодом. Каждый тип файлов приложения копируется в соответствующий системный каталог. Список этих каталогов приведён в таблице 2-9.

{caption: "Таблица 2-9. Назначение системных каталогов", width: "70%"}
| Каталог | Назначение |
| --- | --- |
| `/bin` | Исполняемые файлы системных утилит. |
| `/etc` | Конфигурационные файлы. |
| `/lib` | Библиотеки, необходимые для работы системных утилит. |
| `/usr/bin` | Исполняемые файлы приложений пользователя. |
| `/usr/lib` | Библиотеки, необходимые для приложений пользователя. |
| `/usr/local` | Приложения, скомпилированные пользователем самостоятельно. |
| `/usr/share` | Архитектурно-независимые файлы ресурсов приложений пользователя. |
| `/var` | Файлы, создаваемые приложением в процессе работы (например лог-файлы). |

Может показаться, что копирование файлов приложения по нескольким системным каталогом приведёт к хаосу в файловой системе. На самом деле всё в точности наоборот. Благодаря тому, что все приложения следует соглашению о назначении каждого системного пути, оказывается намного проще организовать их взаимодействие. В Windows каждое приложение при установке копирует все необходимые ему библиотеки, кроме системных. Таким образом постепенно в файловой системе накапливаются десяткий копий одних и тех же библиотек. В Linux все приложения используют единственный экземпляр этой библиотеки. Это возможно потому, что она установлена по предопределённому системному пути и приложения знают, где её искать. В результате использование пространства жёсткого диска происходит намного эффективнее.

Предположим, что мы установили приложение (например, браузер). Согласно таблице 2-9 его исполняемый файл (например, `firefox`) будет скопирован в каталог `/usr/bin`. Как нам его запустить из Bash? Есть несколько способов:

1. По имени исполняемого файла.
2. По абсолютному пути.
3. По относительному пути.

Рассмотрим каждый способ подробнее.

Первый вариант нам хорошо знаком. Именно таким образом мы вывзывали GNU утилиты до сих пор. Например, запуск `find` из каталога `/usr/bin`:
{line-numbers: false}
```
find
```
Точно так же мы запустим и браузер:
{line-numbers: false}
```
firefox
```
Это работает, потому что путь `/usr/bin` хранится в переменной `PATH`. Получив команду `firefox`, Bash ищет исполняемый файл с соответствующим именем в каждом из путей в `PATH`.

I> Обратите внимание, что порядок поиска исполняемого файла соответствует порядку путей в переменной `PATH`. Предположим, что файл есть в обоих каталогах `/usr/local/bin` и `/usr/bin`. В то же время `/usr/local/bin` идёт первым в `PATH`. Тогда Bash всегда будет запускать файл из него.

Во втором способе запуска мы просто набираем абсолютный путь к исполняемому файлу:
{line-numbers: false}
```
/usr/bin/firefox
```
Как правило, этот способ применяется для запуска проприетарных приложений, установленных в каталог `/opt`. Этот каталог обычно не указывается в переменной `PATH`. Поэтому Bash не может самостоятельно найти каталог исполняемого файла.

Третий способ запуска файла покажется непривычным для Windows пользователей. Если вы перейдёте в каталог `/usr`, то запустить браузер можно командой:
{line-numbers: false}
```
bin/firefox
```
Это очевидно и не вызывает вопросов. Но предположим, что исполняемый файл `firefox` находится в каталоге `/opt/firefox/bin`. Перейдём в этот каталога командой `cd` и попробуем запустить браузер:
{line-numbers: false}
```
cd /opt/firefox/bin
firefox
```
Такой способ не сработает. Почему? Дело в том, что сейчас вы попытались запустить приложение по имени исполняемого файла. В этом случае, как мы уже знаем, Bash будет искать его в путях переменной `PATH`. Но приложение установлено в `/opt`, которого в `PATH` нет. Тогда Bash выдаст ошибку, что файл не найден.

Правильно указывать относительный путь с текущим каталогом:
{line-numbers: false}
```
./firefox
```
Тогда Bash поймёт, что искать исполняемый файл следует в текущем каталоге.

Рассмотрим, как добавить свой путь (например, `/opt/firefox/bin`) в переменную `PATH`. Для этого выполните следующией действия:

1. Перйдите в домашний каталог пользователя:
{line-numbers: false}
```
cd ~
```

2. Выведите соответствующий ему Windows путь (см. пример на иллюстрации 2-6):
{line-numbers: false}
```
pwd -W
```

3. В редакторе Notepad++ откройте файл `.bash_profile` из этого каталога.

4. Найдите следующий код на строке 23:
{number-from: "23"}
```
# Set PATH so it includes user's private bin if it exists
# if [ -d "${HOME}/bin" ] ; then
#   PATH="${HOME}/bin:${PATH}"
# fi
```
В начале строк 24, 25 и 26 удалите символ `#`, который означает закоментированный код. Также в строке 25 замените путь `${HOME}/bin` на нужный нам `/opt/firefox/bin`. После редактирования должно получиться следующее:
{number-from: "23"}
```
# Set PATH so it includes user's private bin if it exists
if [ -d "${HOME}/bin" ] ; then
    PATH="/opt/firefox/bin:${PATH}"
fi
```

Чтобы изменения вступили в силу, вам нужно перезапустить терминал MSYS2. Теперь если вы наберёте команду `firefox`, Bash найдёт соответствующий исполняемый файл по пути `/opt/firefox/bin` и запустит.

### Конвейр команд

https://ru.wikipedia.org/wiki/Конвейер_(Unix)

// TODO: начать разбор pipe и вывод в файл с примера cat.

// TODO: xargs

### Пакетный менеджер
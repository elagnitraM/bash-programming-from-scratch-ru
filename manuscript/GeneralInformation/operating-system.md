## Операционные системы

### Предпосылки возникновения ОС

Большинство пользователей компьютера понимает, зачем нужна [**операционная система**](https://ru.wikipedia.org/wiki/Операционная_система#Функции) (ОС). Покупая или загружая из интернета приложение, вы проверяете его системные требования. В них указаны минимальные параметры аппаратной части компьютера. Кроме этого в требованиях указана ОС, на которой приложение запустится. Получается, что ОС — это программная платформа на которой работают приложения. Но откуда взялось это требование? Почему нельзя просто купить компьютер и запустить на нём приложение без ОС?

Эти вопросы кажутся бессмысленными только на первый взгляд. Подумайте сами: современные ОС универсальны и предлагают пользователю множество функций. Большинство из них каждому конкретному пользователю не нужно. Но эти функции зачастую невозможно отключить. Для их обслуживания ОС активно использует ресурсы компьютера. В результате приложениям пользователя достаётся меньше ресурсов. Из-за этого они работают медленно и зависают.

Обратимся к истории, чтобы выяснить причины возникновения ОС. На самом деле первая коммерческая ОС [GM-NAA I/O](https://ru.wikipedia.org/wiki/GM-NAA_I/O) появилась только в 1956 году для компьютера [IBM 704](https://ru.wikipedia.org/wiki/IBM_704). Все ранние модели компьютеров обходились без ОС. Почему в них не было необходимости?

Главная причина в быстродействии. Например, рассмотрим первый [**электромеханический компьютер**](http://chernykh.net/content/view/16/40/). Его сконструировал [Герман Холлерит](https://ru.wikipedia.org/wiki/Холлерит,_Герман) в 1890 году. Компьютер получил название табулятор. Для работы ему не нужна ОС и [программы](https://ru.wikipedia.org/wiki/Компьютерная_программа) в современном смысле этого слова. Табулятор выполняет ограниченный набор арифметических операций. Эти операции определяет конструкция компьютера. Данные для вычислений загружаются с [**перфокарт**](https://ru.wikipedia.org/wiki/Перфокарта). Перфокарты представляют собой листки плотной бумаги с пробитыми отверстиями. Эти листки вручную подготавливаются и укладываются в специальные приёмные устройства. Там они нанизываются на иглы. В местах отверстий происходит замыкание электрической цепи. Каждое замыкание увеличивает механический счётчик. Счётчиком служит вращающийся цилиндр. Результаты вычислений выводятся на циферблаты, напоминающие часы.

Иллюстрация 1-1 демонстрирует табулятор, построенный Германом Холлеритом.

{caption: "Иллюстрация 1-1. Табулятор Холлерита", height: "30%"}
![Табулятор Холлерита](images/GeneralInformation/tabulating-machine.jpg)

По современным меркам табулятор работает очень медленно. На это есть несколько причин. Прежде всего данные для вычислений подготавливаются вручную. Во времена табулятора не было способа автоматически пробивать перфокарты. Далее загрузка перфокарт в компьютер также выполняется вручную. Сам табулятор содержит много механических частей: иглы для считывания данных, счётчики из вращающихся цилиндров, циферблаты для вывода результата. Вся эта механика работает медленно. Выполнение одной элементарной операции занимает порядка одной секунды. Никакая автоматизация не способна ускорить эти механические процессы.

Табуляторы выполняют вычисления с помощью вращающихся цилиндров. На смену им пришли компьютеры, работающие на [**реле**](https://ru.wikipedia.org/wiki/Реле). Реле — это механический элемент. Он меняет своё состояние под воздействием электрического тока. Один из [первых релейных компьютеров](https://habr.com/ru/company/ua-hosting/blog/386247) Z2 сконструировал немецкий инженер [Конрад Цузе](https://ru.wikipedia.org/wiki/Цузе,_Конрад) в 1939 году. Затем этот компьютер был усовершенствован в 1941 году и получил название Z3. Переход на реле сократил время выполнения одной элементарной операции с секунды до миллисекунд.

Кроме возросшей скорости вычислений, компьютеры Цузе отличает ещё одна особенность. В них появилось понятие программы. Теперь с помощью перфокарт вводятся не исходные данные задачи, а [**алгоритмы**](https://ru.wikipedia.org/wiki/Алгоритм) по которым она решается. Для ввода данных используется клавиатура. Она отдалённо напоминает печатную машинку. Такие компьютеры стали называться [**программируемыми**](https://ru.wikipedia.org/wiki/Компьютер_общего_назначения) или универсальными.

I> Алгоритмом называется конечная последовательность инструкций для выполнения какого-либо вычисления или решения задачи.

Появление программируемых компьютеров стало важным шагом в развитии вычислительной техники. До этого машины выполняли только узкоспециализированные задачи. Это было слишком дорого и неэффективно. Поэтому многие инвесторы избегали вкладывать деньги в проекты по конструированию новых компьютеров. Эти проекты ограничивались только военными разработками в годы Второй мировой войны.

Следующим большим шагом стало создание компьютера [**ENIAC**](https://ru.wikipedia.org/wiki/ЭНИАК) (см. иллюстрацию 1-2) в 1946 году [Джоном Эккертом](https://ru.wikipedia.org/wiki/Эккерт,_Джон_Преспер) и [Джоном Мокли](https://ru.wikipedia.org/wiki/Мокли,_Джон). В качестве рабочих элементов в нём используются не реле, а [**электровакуумные лампы**](https://ru.wikipedia.org/wiki/Электронная_лампа). То есть электромеханические компоненты с большим временем отклика заменили на более быстрые электронные. Это увеличило быстродействие компьютера на порядок. Время выполнения одной элементарной операции сократилось до 200 микросекунд.

{caption: "Иллюстрация 1-2. ENIAC", height: "30%"}
![ENIAC](images/GeneralInformation/eniac.jpg)

В среде инженеров долго сохранялось скептическое отношение к электровакуумным лампам. Они были известны своей низкой надёжностью и высоким энергопотреблением. Никто не верил, что сконструированная на них машина вообще сможет работать. В ENIAC использовалось около 18 000 ламп. Они часто выходили из строя. Но между их отказами компьютер успешно справлялся с вычислениями. ENIAC стал положительным примером использования ламп. Он переубедил многих конструкторов.

ENIAC — это программируемый компьютер. В нём алгоритм вычислений задаётся с помощью комбинации переключателей и перемычек на коммутационных панелях. Такое программирование долго и трудозатратно. Нужна одновременная работа нескольких человек. На иллюстрации 1-3 изображена одна из панелей для программирования ENIAC.

{caption: "Иллюстрация 1-3. Панель программирования ENIAC", height: "30%"}
![Панель программирования ENIAC](images/GeneralInformation/eniac-programming.jpg)

ENIAC использует перфокарты для ввода исходных данных и вывода результатов. Так же работали и предыдущие модели компьютеров. Но в ENIAC появилась новая возможность. Перфокарты могли хранить промежуточные расчёты. Если исходная задача из-за своей сложности не решалась сразу, она разбивалась на несколько подзадач. После выполнения каждой подзадачи её результаты выгружались на перфокарты. Затем компьютер перепрограммировался. После этого перфокарты загружались обратно в качестве входных данных.

Опыт эксплуатации ENIAC показал, что производительность компьютера ограничивают все механические операции. Например, ручное перепрограммирование с помощью переключателей и перемычек, а также чтение и пробивание перфокарт. ENIAC обладал небывалой по тем временам производительностью. Но несмотря на это, прикладные задачи решались на нём медленно. Большую часть времени компьютер простаивал, ожидая программы или входных данных. Опыт работы с ENIAC привел к разработке новых средств ввода и вывода данных.

Вычислительная мощность компьютеров увеличилась на порядок после перехода с электровакуумных ламп на [**транзисторы**](https://ru.wikipedia.org/wiki/Транзистор). Вместе с усовершенствованными средствами ввода-вывода это привело к более интенсивной эксплуатации компьютеров и их частому перепрограммированию. К этому времени вычислительные машины распространились за пределы военных проектов и стали использоваться крупными банками и корпорациями. В результате возросло число и разнообразие запускаемых на них программ.

Часто программы исполнялись друг за другом без задержек. Это исключало простой оборудования. Для автоматизации загрузки программ и вывода их результатов потребовались специальные решения. Именно для управления выполнением программ и была разработана первая ОС GM-NAA I/O.

Интенсивное использование компьютеров и разнообразие программ привело к проблеме управления их исполнением. Была и другая проблема. Дело в том, что функции компьютера определялись загруженной в него программой. Например, если она включает в себя код для управления устройствами ввода-вывода, они доступны. В противном случае устройства не работают. Для конкретной модели компьютера подключенное к нему оборудование менялось редко. Поэтому код для работы с ним копировался. Он кочевал из одной программы в другую, занимая лишнее место на устройствах хранения. Со временем этот код стали выносить в отдельную служебную программу. Она загружалась в компьютер вместе с основной. Постепенно эти служебные программы вошли в состав первых ОС.

Вернёмся к нашему вопросу о необходимости операционных систем. Мы выяснили, что приложения могут работать и без них. Такие программы используются и сегодня. Например, это [**утилиты**](https://ru.wikipedia.org/wiki/Утилита) проверки памяти и разбивки диска, а также некоторые антивирусы. Однако, разработка таких программ требует больше времени и сил. В них приходится включать код для поддержки оборудования, который обычно предоставляет ОС. Разработчики предпочитают использовать возможности ОС. Это уменьшает объём работы и ускоряет выпуск программы.

### Возможности ОС

Почему мы начали изучение программирования с рассмотрения ОС? Иллюстрация 1-4 демонстрирует схему взаимодействия ОС с [**прикладными программами**](https://ru.wikipedia.org/wiki/Прикладное_программное_обеспечение) и [**аппаратным обеспечением**](https://ru.wikipedia.org/wiki/Аппаратное_обеспечение). Прикладные программы — это приложения, которые решают задачи пользователя (например, текстовый редактор, калькулятор, браузер). Аппаратным обеспечением называются все электронные и механические компоненты компьютера (например, клавиатура, монитор, центральный процессор, видеокарта).

{caption: "Иллюстрация 1-4. Схема взаимодействия ОС с программами и аппаратным обеспечением", height: "50%"}
![Схема взаимодействия ОС](images/GeneralInformation/operating-system.png)

Рассмотрим схему. Приложения получают доступ к аппаратным ресурсам не напрямую, а через [**системные библиотеки**](https://ru.wikipedia.org/wiki/Библиотека_(программирование)) ОС. Чтобы получить этот доступ, приложение должно следовать строгим правилам. Например, доступны только те возможности устройств, которые поддерживает ОС. Правила работы с устройствами определяет [**интерфейс прикладного программирования**]((https://ru.wikipedia.org/wiki/API)). Он также известен как API (Application Programming Interface). API предоставляют системные библиотеки. 

Интерфейс — это набор соглашений о взаимодействии компонентов информационной системы. Интерфейсы описаны в стандартах. Такие стандарты гарантируют совместимость компонентов системы.

API определяет все аспекты взаимодействия приложения с ОС. Например, он отвечает на следующие вопросы:

1. Какую операцию выполнит ОС при вызове конкретной системной функции?

2. Какие данные функция ожидает на вход?

3. Какие данные функция вернёт в качестве результата?

Следовать интерфейсу должна как ОС, так и приложение. Например, в документации сказано: "ОС создаёт файл при вызове функции X". Не зависимо от версии ОС, она всегда должна следовать этому правилу. Это гарантирует совместимость разных версий приложений и ОС. Такая совместимость невозможна без хорошо документированного и стандартизированного интерфейса.

Мы уже выяснили, что приложения могут работать без ОС. Однако, ОС предлагает готовые решения для взаимодействия с аппаратными ресурсами компьютера. Без этих решений разработчики приложений должны сами отвечать за работу с оборудованием. Это огромная работа. Представьте всё разнообразие комплектующих современных компьютеров. Приложение должно поддерживать все модели устройств (например, видеокарт). В противном случае оно не заработает у некоторых пользователей.

Выясним, какие возможности предоставляет ОС через API интерфейс. Все электронные и механические компоненты компьютера можно рассматривать как ресурсы. Программы используют эти ресурсы для вычислений. Другими словами аппаратное обеспечение выполняет программы. API отражает возможности оборудования, которые доступны программе. Также интерфейс определяет порядок взаимодействия между несколькими программами и оборудованием.

Рассмотрим пример. Две программы не могут одновременно записывать данные на [жёсткий диск](https://ru.wikipedia.org/wiki/Жёсткий_диск#Технологии_записи_данных) в одну и ту же область. Во-первых, запись выполняется единственной магнитной головкой жёсткого диска. Во-вторых, после записи данных первым приложением их может затереть второе приложение. Поэтому одновременные запросы программ на запись нужно упорядочить. Обычно их помещают в очередь и исполняют друг за другом. За это отвечает ОС, а точнее её [**ядро**](https://ru.wikipedia.org/wiki/Ядро_операционной_системы) (см. иллюстрацию 1-4). В ядре реализована [**файловая система**](https://ru.wikipedia.org/wiki/Файловая_система). Похожим образом ОС упорядочивает доступ ко всем [**периферийным**](https://ru.wikipedia.org/wiki/Периферийное_устройство) и внутренним устройствам компьютера. Этот доступ предоставляется через специальные программы. Они называются [**драйверами устройств**](https://ru.wikipedia.org/wiki/Драйвер) (см. иллюстрацию 1-4).

Что такое периферийные устройства, и чем они отличаются от внутренних? К периферийным относятся все устройства, отвечающие за ввод-вывод информации и её постоянное хранение. Примеры: клавиатура, мышь, микрофон, монитор, колонки, жёсткий диск. Внутренние устройства отвечают за обработку информации, то есть непосредственное исполнение программ. К ним относятся [**центральный процессор**](https://ru.wikipedia.org/wiki/Центральный_процессор) (central processing unit, CPU), [**оперативная память**](https://ru.wikipedia.org/wiki/Оперативная_память) (random-access memory, RAM), [**видеокарта**](https://ru.wikipedia.org/wiki/Видеокарта) (graphics processing unit, GPU).

ОС предоставляет не только интерфейс доступа к аппаратным ресурсам. Кроме аппаратных есть ещё и программные ресурсы самой ОС. Это повторяющийся код, ставший со временем служебными программами. Впоследствии его оформили в системные библиотеки (см. иллюстрацию 1-4). Некоторые из библиотек обслуживают устройства. Другие выполняют полезные операции над входными данными. Например, компонент Windows под названием [**интерфейс графических устройств**](https://ru.wikipedia.org/wiki/GDI) (Graphical Device Interface или GDI). С его помощью приложения манипулируют графическими объектами. Используя GDI, разработчики создают пользовательский интерфейс для своих программ. К программным ресурсам относятся все компоненты ОС, установленные на компьютере. Кроме них ОС также предоставлять доступ к алгоритмам сторонних приложений или библиотек.

ОС не только управляет ресурсами. Она организует совместную работу запущенных приложений. Запуск приложения — это нетривиальная задача. Её выполняет специальная служебная программа ОС. После запуска приложения, ОС контролирует его выполнение. Если нарушается какое-то ограничение, приложение завершается. Пример нарушения — чтение недоступной памяти. В следующем разделе мы подробно рассмотрим процесс запуска и исполнения программы.

Если ОС многопользовательская, она контролирует доступ к данным. Благодаря этому, каждый пользователь работает только со своими файлами и каталогами.

Подведём итог. ОС выполняет следующие функции:

1. Предоставляет и упорядочивает доступ к аппаратным ресурсам компьютера.

2. Предоставляет программные ресурсы в виде системных библиотек.

3. Запускает приложения, а также отвечает за ввод данных для них и вывод результата.

4. Организует взаимодействие приложений друг с другом.

5. Контролирует доступ пользователей к данным.

Посмотрите внимательно на эти функции ОС. Наверное вы догадались, что без ОС нельзя запустить несколько приложений одновременно. Проблема в том, что их разработчики не знают, в каком сочетании программы будут выполняться. Только ОС имеет достаточно информации, чтобы эффективно распределить ресурсы компьютера в реальном времени.

### Современные ОС

Мы познакомились с основными возможностями ОС. Теперь учтём новые знания и рассмотрим современные ОС. Их функции во многом аналогичны. Основные отличия заключаются в способах реализации этих функций. Эти особенности реализации и решения, которые к ним привели, называются [**архитектурой**](https://ru.wikipedia.org/wiki/Архитектура_программного_обеспечения).

У современных ОС есть две особенности. Они определяют их поведение и способ взаимодействия с пользователем. Речь идёт о многозадачности и графическом интерфейсе. Рассмотрим их подробнее.

#### Многозадачность

Большинство современных ОС [**многозадачны**](https://ru.wikipedia.org/wiki/Многозадачность). Это означает, что они исполняют несколько программ одновременно. Почему это свойство оказалось важным? Системы с этим свойством вытеснили ОС без него.

В 1960-е годы появилась проблема эффективного использования компьютеров. В то время они стоили дорого. Поэтому ценилась каждая минута их работы. Позволить купить себе мейнфрейм могли только крупные компании и университеты. Они считали неприемлемым любой его простой.

Ранние операционные системы исполняли программы друг за другом без задержек. В таких ОС программы и их входные данные подготавливались заранее. Они записывались на устройство хранения (например, магнитную ленту). Эта лента подавалась на устройство чтения компьютера. Он последовательно исполнял программы и выводил их результаты на устройство вывода (например, принтер). Такой режим работы называется [**пакетная обработка**](https://ru.wikipedia.org/wiki/Пакетное_задание) ([batch processing](https://en.wikipedia.org/wiki/Batch_processing)). Он экономит время на переключение компьютера с одной задачи на другую.

Пакетная обработка увеличила эффективность использования мейнфреймов. Она автоматизировала загрузку программ и частично исключила из этого процесса человека-оператора. Однако, у системы осталось [**узкое место**](https://ru.wikipedia.org/wiki/Узкое_место). Вычислительная мощность процессоров значительно выросла. Скорость же работы периферийных устройств почти не изменилась. Поэтому CPU часто простаивал, ожидая ввода-вывода данных.

I> Узкое место (bottleneck) — компонент или ресурс информационной системы, который ограничивает её общую производительность или пропускную способность.

Рассмотрим пример. Представьте, что мейнфрейм последовательно выполняет программы. Данные для них считываются с магнитной ленты, а результаты печатаются на принтере. ОС загружает каждую программу и исполняет её инструкции, затем загружает следующую и так далее. Проблема возникает на этапах чтения данных и печати результата. Время доступа к данным на магнитной ленте огромно в масштабах центрального процессора. Между двумя операциями чтения, он успел бы выполнить ряд вычислений. Но он этого не делает. Все ресурсы компьютера использует только программа, загруженная сейчас в память. То же происходит с выводом результатов на печать. Принтер — это чисто механическое устройство. Он работает очень медленно.

Проблема простоя центрального процессора привела к идее [**мультипрограммирования**](https://ru.wikipedia.org/wiki/Мультипрограммирование). Это означает одновременную загрузку сразу нескольких программ в память компьютера. Первая из них выполняется до тех пор, пока доступны все необходимые ей ресурсы. Как только один из ресурсов оказывается занят, выполнение программы останавливается. Например, ей нужны данные, хранящиеся на жёстком диске. Пока контроллер диска читает первую часть данных, он занят и не может обработать запрос на чтение следующей части. В этом случае ОС прекращает выполнение первой программы и переключается на вторую. Она в свою очередь исполняется до конца или до момента, когда нужный ей ресурс окажется занят. После этого опять происходит переключение задач.

Мультипрограммирование стало прототипом многозадачности, которая реализована в современных ОС. Мультипрограммирование хорошо справляется с режимом пакетной обработки. Однако, этот подход распределения нагрузки не подходит для систем с [**интерактивным взаимодействием**](https://ru.wikipedia.org/wiki/Интерактивность). В таких системах действия пользователя являются событиями. Например, нажатие клавиши. Каждое событие обрабатывается сразу. Например, добавление нового символа в текстовый документ. Время отклика системы должно быть минимальным. Иначе пользователь заметит зависания программы.

Проблема мультипрограммирования в том, что момент переключения задач непредсказуем. Это случится только при её завершении программы или её обращении к занятому ресурсу. При это действия пользователя не будут обработаны до момента переключения задач.

Многозадачность решает проблему быстрого отклика при интерактивной работе с компьютером. Способ её реализации постепенно развивался и усложнялся. В современных ОС применяется [**вытесняющая многозадачность**](https://ru.wikipedia.org/wiki/Вытесняющая_многозадачность) с псевдопараллельной обработкой задач. Это означает, что ОС самостоятельно решает, какую программу выполнять в данный момент. При выборе учитываются приоритеты работающих приложений. То есть более приоритетные приложения будут получать аппаратные ресурсы чаще, чем низкоприоритетные. Механизм переключения задач реализован в ядре ОС и называется [**планировщиком задач**](https://ru.wikipedia.org/wiki/Диспетчер_операционной_системы).

Псевдопараллельность обработки означает, что в каждый момент времени выполняется только одна задача. При этом ОС переключается между задачами настолько быстро, что пользователь этого не замечает. Ему кажется, что компьютер выполняет одновременно несколько программ. При это графический интерфейс сразу реагирует на любое действие. Но на самом деле, каждая программа и компонент ОС получают аппаратные ресурсы в строго определённые моменты времени.

Одновременное выполнение программ возможно только на компьютерах с несколькими процессорами или с [многоядерными](https://ru.wikipedia.org/wiki/Ядро_микропроцессора) процессорами. На таких компьютерах число одновременно работающих программ примерно равно числу ядер всех процессоров. При этом всё равно работает механизм вытесняющей многозадачности с постоянным переключением задач. Он универсален и балансирует нагрузку на любых системах, независимо от числа ядер. Так выдерживается приемлемое время отклика на действия пользователя.

#### Интерфейс пользователя

Современные ОС решают разные задачи. Эти задачи определяет тип компьютера, на котором запускается ОС. Основные типы следующие:

* [Персональные компьютеры](https://ru.wikipedia.org/wiki/Персональный_компьютер) (ПК) и ноутбуки
* Мобильные телефоны и планшеты
* Сервера
* [Встраиваемые системы](https://ru.wikipedia.org/wiki/Встраиваемая_система)

Мы рассмотрим только ОС для ПК и ноутбуков. Помимо многозадачности они предоставляют [**графический интерфейс пользователя**](https://ru.wikipedia.org/wiki/Графический_интерфейс_пользователя) (graphical user interface или GUI). В данном случе интерфейс — это способ взаимодействия с системой. Через него пользователь запускает приложения, настраивает устройства компьютера и компоненты ОС. Рассмотрим подробнее историю возникновения графического интерфейса.

Пользователи коммерческих компьютеров впервые узнали об интерактивном режиме работы в 1960 году. Его поддерживал новый [мини-компьютер](https://en.wikipedia.org/wiki/Minicomputer) [PDP-1](https://ru.wikipedia.org/wiki/PDP-1) от компании [Digital Equipment Corporation](https://ru.wikipedia.org/wiki/Digital_Equipment_Corporation). Почему производители и пользователи компьютеров вообще заинтересовались интерактивностью? В 1950-е годы на рынке мейнфреймов доминировали компьютеры IBM. Они работали в режиме пакетной обработки и хорошо справлялись с вычислительными задачами. Их операционные системы с поддержкой мультипрограммирования автоматизировали загрузку программ и обеспечивали высокую производительность.

Идея интерактивной работы с компьютером появилась в военном проекте SAGE. Он выполнялся по заказу ВВС США. В проекте разрабатывалась автоматизированная система ПВО для обнаружения советских бомбардировщиков. При разработке конструкторы столкнулись с проблемой обработки данных с радаров. Согласно требованиям, компьютер должен был выводить данные в реальном времени. Человек-оператор реагировал на них максимально быстро и отдавал команды. Существующие тогда методы работы с компьютером для этой задачи не подходили. Поскольку в системе ПВО важна скорость реакции на угрозу.

Проект SAGE привёл к созданию первого интерактивного компьютера [AN/FSQ-7](https://en.wikipedia.org/wiki/AN/FSQ-7_Combat_Direction_Central) (см иллюстрацию 1-5). Он выводил данные на [**электронно-лучевой монитор**](https://ru.wikipedia.org/wiki/Кинескоп). Команды вводились оператором с помощью [**светового пера**](https://ru.wikipedia.org/wiki/Световое_перо).

{caption: "Иллюстрация 1-5. Компьютер AN/FSQ-7"}
![Компьютер AN/FSQ-7](images/GeneralInformation/AN-FSQ-7.jpg)

Метод интерактивной работы с компьютером стал известен в научных кругах. Он быстро набрал популярность. Пакетная обработка успешно справлялась с выполнением программ. Однако, их разработка и отладка была неудобной. Программист писал алгоритм и записывал его на устройство хранения. Дальше разработчик помещал свою задачу в очередь на выполнение на мейнфрейме. Ожидание в очереди занимало часы. Если после исполнения программы обнаруживалась ошибка, программист её исправлял и снова помещал свою задачу в очередь. В результате исправление всех ошибок даже в небольшой программе занимало дни.

В интерактивном режиме работы программист запускает программу, ожидает её завершения и видит на экране результат. Это в разы увеличивает скорость разработки и отладки приложений. Теперь работа, требующая несколько дней, выполнялась за несколько часов.

Интерактивный режим принёс новые задачи. Этот режим имел смысл, только если система сразу реагировала на действия пользователя. Для этого требовался новый механизм балансирования нагрузки. С этим требованием справился режим многозадачности новых ОС.

Интерактивный режим поддерживают не только многозадачные ОС, но и однозадачные. Пример такой ОС — [MS-DOS](https://ru.wikipedia.org/wiki/DOS). Совмещение интерактивности и однозадачности было нецелесообразно во времена дорогих мейнфреймов. Тогда ресурсами одного компьютера пользовались сразу несколько пользователей. Их программы исполнялись параллельно и независимо друг от друга. Такой режим работы получил название [**разделение времени**](https://ru.wikipedia.org/wiki/Разделение_времени) (time-sharing). Совместить же однозадачность и разделение времени невозможно.

Когда появились первые относительно дешевые персональные компьютеры, на них устанавливались однозадачные ОС. Они требовали меньше аппаратных ресурсов чем их старшие аналоги для мейнфреймов. Несмотря на свою простоту, однозадачные ОС поддерживали интерактивную работу. Для пользователей ПК этот режим стал особенно привлекательным.

Интерактивный режим поставил не только задачу балансировки нагрузки системы. Нужны были новые способы взаимодействия пользователя и компьютера. Существующие в 1960-е годы магнитные ленты и принтеры для этого не подходили. 

[**Телетайп**](https://ru.wikipedia.org/wiki/Телетайп) (teletype) стал прототипом устройства для интерактивной работы с компьютером. Иллюстрация 1-6 демонстрирует телетайп Model 33. Он представляет собой электромеханическую печатную машинку. С помощью проводов она подключается к такой же машинке. После соединения двух телетайпов операторы могут передавать друг другу текстовые сообщения. Отправитель набирает текст на своём устройстве. Нажатия клавиш передаются на устройство получателя. Оно печатает каждую принятую букву на бумаге.

{caption: "Иллюстрация 1-6. Телетайп Model 33", height: "50%"}
![Телетайп Model 33](images/GeneralInformation/teletype.jpg)

Телетайпы применяли для удалённого доступа к мейнфреймам. Такое устройство получило название [**терминал**](https://ru.wikipedia.org/wiki/Компьютерный_терминал). Терминал подключался напрямую к мейнфрейму. Пользователь набирал на клавиатуре команды. Мейнфрейм их получал, исполнял и отправлял результат обратно. Терминал распечатывал полученные данные на бумаге. Позднее устройство печати заменил монитор. В результате получился [**интерфейс командной строки**](https://ru.wikipedia.org/wiki/Интерфейс_командной_строки) (command-line interface или CLI). Принцип его работы напоминает классический телетайп. Пользователь вводит команды одну за другой. Компьютер последовательно их исполняет и выводит на экран результаты.

Иллюстрация 1-7 демонстрирует современный интерфейс командной строки. Это окно [**эмулятора терминала**](https://ru.wikipedia.org/wiki/Эмулятор_терминала) [Terminator](https://en.wikipedia.org/wiki/Terminator_(terminal_emulator)). В нём запущен интерпретатор командной строки Bash. В окне выведены результаты работы программ ping и ls.

{caption: "Иллюстрация 1-7. Интерфейс командной строки", height: "50%"}
![Интерфейс командной строки](images/GeneralInformation/cli.png)

Интерфейс командной строки востребован и сегодня. Он имеет ряд преимуществ по сравнению с графическим интерфейсом. Главное достоинство CLI в его нетребовательности к вычислительным ресурсам. Он работает одинаково стабильно и без задержек как на низкопроизводительных встраиваемых компьютерах, так и на мощных серверах. Если применять CLI для удалённого доступа к компьютеру, качество канала связи и его пропускная способность могут быть низкими. Даже с медленным соединением сервер получит команды.

У интерфейса командной строки есть и недостатки. Главная его проблема в сложности освоения. Пользователю доступны сотни команд с различными входными параметрами, которые определяют их режим работы. Требуется немало времени, чтобы запомнить хотя бы часто используемые команды.

Проблема наглядного представления доступных команд была решена [**текстовым интерфейсом пользователя**](https://ru.wikipedia.org/wiki/Текстовый_интерфейс_пользователя) (textual user interface или TUI). В нём наряду с буквенными и цифровыми символами используется [**псевдографика**](https://ru.wikipedia.org/wiki/Псевдографика). Псевдографикой называются специальные символы, с помощью которых на экране отображаются графические примитивы (например, линии, прямоугольники, треугольники и т.д.). Иллюстрация 1-8 демонстрирует типичный текстовый интерфейс. Это вывод статистики использования системных ресурсов программой htop.

{caption: "Иллюстрация 1-8. Текстовый интерфейс пользователя", height: "50%"}
![Текстовый интерфейс пользователя](images/GeneralInformation/tui.png)

Дальнейший рост производительности компьютеров позволил заменить псевдографику на реальные графические элементы. Примеры таких элементов: окна, иконки, кнопки и т.д. В результате возник полноценный графический интерфейс, который применяется в современных ОС.

Графический интерфейс ОС Windows приведён на иллюстрации 1-9. Это скриншот рабочего стола с развёрнутыми окнами трёх одновременно работающих приложений: Проводника, Блокнота и Калькулятора.

{caption: "Иллюстрация 1-9. Графический интерфейс пользователя"}
![Графический интерфейс пользователя](images/GeneralInformation/gui.png)

Первый графический интерфейс предназначался для мини-компьютера [Xerox Alto](https://ru.wikipedia.org/wiki/Xerox_Alto) (см. иллюстрацию 1-10). Его разработали в 1973 году в исследовательском центре [Xerox PARC](https://ru.wikipedia.org/wiki/Xerox_PARC). Однако, интерфейс не получил широкого распространения вплоть до 1980-х годов. Он требовал много памяти и высокой производительности компьютера. В то время такие ПК стоили слишком дорого для рядовых пользователей. 

Компания Apple выпустила на рынок первый ПК Lisa с графическим интерфейсом только в 1983 году.

{caption: "Иллюстрация 1-10. Мини-компьютер Xerox Alto", height: "50%"}
![Мини-компьютер Xerox Alto](images/GeneralInformation/xerox-alto.jpg)

#### Семейства ОС

Сегодня на рынке персональных компьютеров доминируют три семейства ОС:

* [Windows](https://ru.wikipedia.org/wiki/Windows)
* [Linux](https://ru.wikipedia.org/wiki/Linux)
* [macOS](https://ru.wikipedia.org/wiki/MacOS)

Что именно подразумевается, когда говорят о семействе ОС? Этот термин означает ряд версий ОС, которые следуют одним и тем же архитектурным решениям, а также сохраняют некоторые особенности реализации тех или иных функций.

Почему разработчики каждой ОС предпочитают придерживаться одной и той же архитектуры, а не предлагают что-то принципиально новое в следующих версиях? На самом деле изменения в современных ОС происходят, но постепенно и медленно. Причина этого в [**обратной совместимости**](https://ru.wikipedia.org/wiki/Обратная_совместимость). Эта совместимость предполагает наличие некоторых старых функций в новой версии ОС. Они нужны для корректной работы написанных ранее программ. На первый взгляд это требование может показаться необязательным. Но на самом деле это серьёзное ограничение для разработки программного обеспечения. Давайте разберёмся, почему это так.

Представьте, что вы разработали программу для ОС Windows и продаёте её. Иногда пользователи обнаруживают в ней ошибки, которые вы успешно исправляете. Время от времени вы добавляете в неё новые функции. Теперь представьте, что выходит новая версия Windows, на которой ваша программа перестаёт работать. У пользователей есть два решения: ждать от вас новой версии программы, в которой проблема решена, или отказаться от обновления Windows. Теперь предположим, что новая версия ОС принципиально отличается от предыдущей. Это значит, что вашу программу придётся переписать буквально с нуля. Посчитайте всё время, которое вы уже потратили на исправление ошибок и добавление новых функций. Эту работу в полном объёме придётся повторить. Скорее всего вы откажетесь от этой идеи и предложите пользователям оставаться на старой версии Windows. Теперь представьте, что таких программ как ваша много. Их разработчики придут к тому же решению, что и вы. В результате новая версия Windows окажется никому не нужна. В этом и заключается проблема обратной совместимости. Именно поэтому и существуют семейства ОС.

Влияние приложений, доступных под конкретную ОС, сложно переоценить. Например, ОС Windows и персональные компьютеры от IBM обязаны своим успехом табличному процессору [Lotus 1-2-3](https://ru.wikipedia.org/wiki/Lotus_1-2-3). Он запускался только на ПК от IBM, работающих под управлением Windows. Ради Lotus 1-2-3 пользователи покупали и первое и второе. Такие популярные приложения, выводящие какую-то платформу на широкий рынок, получили название [**killer application**](https://ru.wikipedia.org/wiki/Killer_application) (букв. убойное приложение). Похожая ситуация сложилась с табличным процессором [VisiCalc](https://ru.wikipedia.org/wiki/VisiCalc), который способствовал распространению компьютеров [Apple II](https://ru.wikipedia.org/wiki/Apple_II). Точно так же бесплатные компиляторы языков C, Fortran и Pascal подогрели интерес к Unix в университетских кругах. За каждой из трёх доминирующих сегодня ОС стоит какое-то killer application. Далее распространению этих ОС способствовал [сетевой эффект](https://ru.wikipedia.org/wiki/Сетевой_эффект), когда разработчики приложений выбирали в качестве целевой программной платформы именно ту, которая уже была установлена на компьютеры большинства пользователей.

Вернёмся к нашему списку семейств ОС. Windows и Linux примечательны тем, что не привязаны к конкретной аппаратной платформе. Это значит, что купив любой персональный компьютер или ноутбук, вы без особых трудностей сможете установить на него эти ОС. macOS в отличие от них рассчитана на запуск только на устройствах Apple. Чтобы установить macOS на другую аппаратную платформу, вам понадобится её неофициальная [модифицированная версия](https://ru.wikipedia.org/wiki/OSx86). Совместимость с аппаратной платформой — это хороший пример архитектурного решения. Но таких решений много, и все вместе они формируют особенности каждого семейства.

ОС во многом определяет инфраструктуру, доступную программисту. Она диктует не только инструменты разработки, такие как IDE, компилятор, система сборки, но и некоторые архитектурные решения самих запускаемых на ней приложений. Можно говорить о некоторой сложившейся культуре написания программ под конкретную ОС. Это очень важный момент, который следует всегда учитывать: под разные ОС программы принято разрабатывать по-разному.

Рассмотрим различие культур разработки программ подробнее на примере Windows и Linux.

#### Windows

Windows — это [проприетарная](https://ru.wikipedia.org/wiki/Проприетарное_программное_обеспечение) ОС. Исходные коды проприетарного программного обеспечения закрыты для постороннего изучения и модификации. Вы не сможете законным способом узнать о нём больше, чем разработчики посчитают нужным вам сообщить. Чтобы установить Windows на свой компьютер, вам надо купить её у компании Microsoft. Однако, часто эта ОС уже предустановлена на новые компьютеры и ноутбуки, а её цена включена в конечную стоимость устройства.

Обратите внимание, что целевой платформой Windows были и остаются относительно дешёвые персональные компьютеры. Многие могут позволить себе купить такое устройство. Следовательно, рынок потенциальных пользователей огромен. Microsoft стремится всеми силами сохранить конкурентное преимущество на этом рынке. Компания опасается появления аналогов своей ОС с такими же возможностями. Именно поэтому Microsoft заботится о защите своей интеллектуальной собственности не только техническими, но и юридическими путями. Строго говоря, пользовательское соглашение запрещает вам исследовать внутреннее устройство ОС.

За всё время существования семейства ОС Windows под него было написано много прикладных программ. Первые из них (например, пакет офисных приложений [Microsoft Office](https://ru.wikipedia.org/wiki/Microsoft_Office) или [стандартные приложения Windows](https://ru.wikipedia.org/wiki/Категория:Стандартные_приложения_Windows)) создавались самой компанией Microsoft. Для сторонних разработчиков они послужили в некотором роде образцом для подражания. Microsoft при разработке своих приложений придерживалась того же принципа закрытости, что и при разработке ОС: исходные коды недоступны конечным пользователям, форматы данных недокументированны, сторонние утилиты не могут получить доступа к возможностям приложений. Опять же все эти решения были продиктованы заботой о защите интеллектуальной собственности компании от конкурентов.

Сторонние разработчики программ последовали примеру Microsoft и зачастую стали придерживаться той же философии закрытости. Большинство получившихся приложений самодостаточны и независимы друг от друга. Форматы их данных, как правило, закодированы и недокументированны.

Если вы опытный пользователь компьютера, то сразу узнаете типичное Windows приложение. Это окно с такими [элементами интерфейса](https://ru.wikipedia.org/wiki/Элемент_интерфейса), как кнопки, поля ввода, вкладки и т.д. Через это окно пользователь манипулирует каким-то данными (например, текстом, изображением или звуковой записью). Результат работы сохраняется на жёсткий диск компьютера и может быть повторно загружен в том же самом приложении. Очень велика вероятность, что если вы напишете собственную Windows-программу, она будет выглядеть и работать похожим образом. Именно такая преемственность решений и имеется ввиду, когда мы говорим о сложившейся культуре разработки под конкретную ОС.

#### Linux

Linux является идейным наследником ОС [Unix](https://ru.wikipedia.org/wiki/Unix) и следует её [**спецификациям**](https://ru.wikipedia.org/wiki/Спецификация). Спецификация — это документ с требованиями к системе, который также определяет её поведение и внутреннее устройство. Получается, что Linux заимствовал многие идеи и решения Unix, что в результате привело к похожему поведению.

Сама Unix возникла в конце 1960-х годов. Она создавалась как хобби-проект двумя инженерами компании Bell Labs: [Кеном Томпсоном](https://ru.wikipedia.org/wiki/Томпсон,_Кен) и [Деннисом Ритчи](https://ru.wikipedia.org/wiki/Ритчи,_Деннис). Они участвовали в крупном проекте компании по разработке ОС [**Multics**](https://ru.wikipedia.org/wiki/Multics) для нового мейнфрейма GE-645 (см. иллюстрацию 1-11) от компании General Electric. Кроме Bell Labs и General Electric над проектом также работал Массачусетский Технологический Институт (MIT).

{caption: "Иллюстрация 1-11. Мэйнфрейм модели GE-645", height: "30%"}
![Мэйнфрейм модели GE-645](images/GeneralInformation/ge-645.jpg)

В ОС Multics планировалось реализовать много инновационных для того времени идей. Одной из них было разделение времени. Как вы помните, это означает, что с одним мейнфреймом одновременно может работать несколько пользователей. При этом вычислительные ресурсы компьютера разделяются между ними с помощью многозадачности.

Разработка Multics затягивалась и Bell Labs решила выйти из проекта. Однако многие инженеры компании хотели продолжать работу над ним. На этой волне Кен Томпсон решил создать собственную ОС для компьютера GE-645. Для этого он начал писать ядро и продублировал некоторые механизмы Multics. Однако, General Electric потребовала вернуть свой дорогой мейнфрйем, переданный Bell Labs во временное пользование. В результате Кен Томпсон остался без аппаратной платформы для разработки.

Параллельно с работой над аналогом Multics Кен писал компьютерную игру [Space Travel](https://ru.wikipedia.org/wiki/Space_Travel). Она запускалась на мейнфрейме General Electric прошлого поколения GE-635, который работал под управлением ОС [GECOS](https://ru.wikipedia.org/wiki/GCOS). Этот компьютер представлял собой шкафы с электроникой и стоил порядка 7 500 000$. Его вычислительные ресурсы активно использовались для нужд компании и были постоянно заняты. Поэтому Кен решил портировать свою игру на относительно недорогой и реже используемый коллегами мини-компьютер [PDP-7](https://ru.wikipedia.org/wiki/PDP-7) (см. иллюстрацию 1-12) стоимостью порядка 72 000$. Проблема заключалась в том, что игра использовала возможности ОС GECOS, которые были недоступны на PDP-7. Поэтому Кену и присоединившемуся к нему Деннису пришлось реализовать эти возможности в виде набора библиотек и систем, которые впоследствии развились в самостоятельную ОС Unix.

{caption: "Иллюстрация 1-12. Мини-компьютер PDP-7", height: "30%"}
![Мини-компьютер PDP-7](images/GeneralInformation/pdp-7.jpg)

Очевидно, в своём проекте разработчики Unix не заботились о защите интеллектуальной собственности, поскольку не собирались её продавать. ОС разрабатывалась для собственных нужд и распространялась с открытым исходным кодом, доступным для изучения и модификации любым желающим. Изначально круг пользователей ограничивался сотрудниками компании Bell Labs. Позднее AT&T, которой принадлежала Bell Labs, предоставила исходный код Unix высшим учебным заведениям США. Таким образом развитие ОС продолжилось уже в университетских кругах.

ОС Linux была создана в 1991 году [Линусом Торвальдсом](https://ru.wikipedia.org/wiki/Торвальдс,_Линус) во время его обучения в Хельсинкском университете. Линус решал чисто практическую проблему: в то время персональные компьютеры не имели полноценной Unix-совместимой ОС. В университете студенты выполняли учебные задания на мини-компьютере MicroVAX под управлением Unix, но дома у них не было оборудования, подходящего для её запуска. Единственной альтернативой Unix была ОС [Minix](https://ru.wikipedia.org/wiki/Minix), разработанная Эндрю Таненбаумом в 1987 году для персональных компьютеров IBM с процессорами Intel 80268. Но эта ОС создавалась для учебных целей, и поэтому Эндрю отказывался вносить в неё изменения для поддержки более современных компьютеров. Эти изменения неизбежно привели бы к усложнению системы и сделали бы её непригодной для обучения студентов.

Линус задался целью написать Unix-совместимую ОС для своего нового компьютера IBM с процессором Intel 80386. Её прототипом стала учебная ОС Minix. Как и у создателей Unix, у него не было коммерческих интересов, связанных с продажей результата своего труда. Он разрабатывал систему для собственных нужд. Поэтому его ОС стала бесплатной и свободно распространялась с исходным кодом через интернет.

На самом деле Linux — это не более чем ядро ОС, предоставляющее функции для работы с памятью, файловой системой, периферийными устройствами, а также управлением процессорным временем. Большинство функций системы доступны через свободные [пользовательские компоненты GNU](https://ru.wikipedia.org/wiki/Проект_GNU), которые Линус включил в [дистрибутив](https://ru.wikipedia.org/wiki/Дистрибутив_Linux) своей ОС.

Изначально у Linux, как у и Unix, не было графической подсистемы. Все приложения пользователь запускал из командной строки. Только некоторые сложные приложения имели текстовый интерфейс. Со временем в Linux появилась оконная система [X Window System](https://ru.wikipedia.org/wiki/X_Window_System), а вместе с ней и приложения с графическим интерфейсом, более привычные пользователям Windows.

Условия в которых возникла и развивалась ОС Unix (а позднее и Linux), во многом определили культуру написания приложений. В этой культуре предпочтение отдаётся узкоспециализированным утилитам командной строки, которые выполняют только одну конкретную задачу, но делают это максимально эффективно. Эти утилиты выводят свои результаты в открытом формате данных (как правило [текстовом](https://ru.wikipedia.org/wiki/Текстовые_данные)), а их исходный код всегда доступен для изучения и модификации.

Культура разработки приложений в Linux значительно отличается от стандартов, принятых в Windows. В Windows каждое приложение монолитно и самостоятельно выполняет все свои задачи. Оно не полагается на сторонние утилиты, которые могут оказаться платными или недоступными для пользователя по какой-то причине. Разработчик должен рассчитывать только на себя. Он не в праве требовать от пользователя купить что-то дополнительное для работы своего приложения. В Linux же подавляющее большинство утилит бесплатны, взаимозаменяемы и легко доступны через интернет. Поэтому вполне естественно, что какое-то приложение потребует загрузить и установить недостающие ему системные компоненты или другое приложение.

Даже монолитные графические приложения в Linux обычно предоставляют дополнительный интерфейс командной строки. Таким образом они органично вписываются в экосистему и легко интегрируются с другими утилитами и приложениями.

Когда сложный вычислительный процесс строится на сочетании нескольких узкоспециализированных приложений, возникает задача составления алгоритма их совместной работы. Именно для этой задачи была создана [командная оболочка](https://ru.wikipedia.org/wiki/Командная_оболочка_Unix) [Bourne shell](https://ru.wikipedia.org/wiki/Bourne_shell) и её потомок [Bash](https://ru.wikipedia.org/wiki/Bash). В этой книге мы будем работать только с Bash, который полностью вытеснил Bourne shell на современных Linux-системах.

Стоит признать, что нельзя отдать однозначное предпочтение культуре Linux перед Windows. Их сравнение давно служит поводом для бесконечных споров. Каждая из культур имеет свои достоинства и недостатки. Например, широко распространённые в Windows монолитные приложения лучше справляются с задачами, требующими интенсивных расчётов. При комбинации узкоспециализированных Linux-утилит в этом случае возникают накладные расходы, связанные с их запуском и передачей данных между ними. В результате задача выполняется дольше.

Сегодня можно наблюдать синтез культур Windows и Linux. Всё больше коммерческих приложений портируются на Linux: браузеры, инструменты для разработки программ, игры, мессенджеры и т.д. При этом их разработчики часто не готовы вносить изменения, продиктованные Linux-культурой. Такие изменения требуют времени и сил. Кроме того они усложняют сопровождение продукта. Вместо одного приложения получается несколько: под каждую платформу разная версия. Намного проще портировать приложение в том же виде, в каком оно разрабатывалось под Windows. В результате под Linux всё чаще встречаются приложения выполненные в типичном Windows-стиле. О плюсах и минусах этого процесса можно спорить. Но одно очевидно: чем больше приложений запускается на ОС, тем популярнее она становится благодаря сетевому эффекту.

I> Подробнее о культуре разработки в Unix и Linux вы можете узнать из книги [Эрика Реймонда "Искусство программирования в Unix"](https://ru.wikipedia.org/wiki/Философия_Unix#Реймонд:_Искусство_программирования_в_Unix).

## Компьютерная программа

Мы рассмотрели функции ОС. Теперь познакомимся с компьютерной программой. Что она из себя представляет? Как происходит её запуск и исполнение? Попробуем отвтить на эти вопросы.

### Память компьютера

Любая компьютерная программа исполняется центральным процессором. Она хранится на жёстком диске или другом носителе информации в виде файла. Когда вы запускаете её, ОС загружает содержимое этого файла в оперативную память. Сразу возникает вопрос: зачем это нужно? Почему нельзя просто исполнить файл на диске?

В современном компьютере есть несколько [уровней памяти](https://ru.wikipedia.org/wiki/Иерархия_памяти). Они изображены на иллюстрации 1-10.

{caption: "Иллюстрация 1-10. Уровни памяти персонального компьютера", height: "50%"}
![Уровни памяти](images/GeneralInformation/memory-levels.png)

Стрелки на иллюстрации 1-10 соответствуют потокам данных, загрузка и выгрузка которых возможна только между соседними уровнями памяти. Другими словами если процессору нужны данные с дисковой памяти, они будут сначала загружены в оперативную память, затем в кэш CPU и только потом попадут в его регистры. Аналогичным образом происходит и обратный процесс записи данных на диск.

Уровни памяти отличаются друг от друга несколькими параметрами:

1. **Скорость доступа** определяет объём данных, читаемый или записываемых в единицу времени на носитель. Обычно измеряется в [**байтах**](https://ru.wikipedia.org/wiki/Байт) за секунду (байт/с).

2. **Объём** — количество данных, которое может храниться на носителе. Измеряется в байтах.

3. **Стоимость** — цена носителя в соотношении к его объёму. Измеряется в долларах или центах за байт или бит.

4. **Время доступа** — время, через которое процессор получит доступ к прочитанным данным. Обычно измеряется в [**тактовых сигналах**]((https://ru.wikipedia.org/wiki/Тактовый_сигнал)) проецссора.

Соотношение рассмотренных параметров для разных типов памяти приведено в таблице 1-1.

{caption: "Таблица 1-1. Уровни памяти персонального компьютера", width: "100%", column-widths: "10%,30%,*"}
| Уровень | Память | Объём | Скорость доступа | Время доступа | Стоимость |
| --- | --- | --- | --- | --- | --- |
| 1 | [**Регистры**](https://ru.wikipedia.org/wiki/Регистр_процессора) процессора. | до тысячи байтов | — | 1 такт | — |
| 2 | [**Кэш**](https://ru.wikipedia.org/wiki/Кэш_процессора) память процессора. | от одного килобайта до нескольких мегабайтов | от 700 до 100 гигабайт/сек | от 2 до 100 тактов | — |
| 3 | Оперативная память | десятки гигабайтов | 10 гигабайт/сек | до 1000 тактов | $10^-9^/байт |
| 4 | Дисковая память ([**жёсткие диски**](https://ru.wikipedia.org/wiki/Жёсткий_диск) и [**твёрдотельные накопители**](https://ru.wikipedia.org/wiki/Твердотельный_накопитель)) | терабайты | 2000 мегабайт/сек | до 10000000 тактов | $10^-12^/байт |

Таблица 1-1 вызывает вопросы. Разве скорости доступа к данным в 2000 Мбайт/с недостаточно для чтения и исполнения файла приложения размером с десятки мегабайт? На самом деле важна не столько скорость чтения данных в байтах, а то как долго простаивает процессор, дожидаясь доступа к ним. Это время доступа к памяти измеряется в числе тактовых сигналов или тактах. Такт синхронизирует выполнение всех операций процессора. Как правило, элементарная операция занимает от одного до нескольких тактов.

Итак, если бы процессору приходилось читать код программы с жёсткого диска и записывать на него промежуточные данные и результаты, выполнение простейших алгоритмов заняло бы в лучшем случае недели. Причём большую часть этого времени процессор простаивал бы, находясь в ожидании выполнения операций чтения и записи. Иерархическая организация памяти позволяет на порядки ускорить доступ к данным, необходимым процессору в данный момент. Тем самым решается проблема его простаивания. Как это происходит?

Представьте, что процессор исполняет программу. Например, она читает файл с диска и выводит его содержимое на экран. При этом, согласно иллюстрации 1-10, данные с диска сначала будут загружены в оперативную память. Затем по частям они будут загружаться в кэш процессора, а оттуда в его регистры. После этого CPU вызовет функцию из системной библиотеки ОС, в которую эти данные передаются. Функция с помощью драйвера видеокарты выведет данные на экран. Проблема может возникнуть, когда процессор вызвал функцию и переходит к следующему блоку данных из файла. Если окажется, что они ещё не загружены в регистры из кэша, то CPU проведёт в ожидании от 2 до 100 тактов (согласно таблице 1-1). Аналогично, если данные ещё не были загружены из RAM в кэш, то время ожидания вырастет на порядок (до 1000 тактов). Предположим, что читаемый файл оказался слишком велик и не помещается целиком в оперативную память. Тогда возможна ситуация, когда его часть, необходимая в данный момент процессору, еще не была загружена в RAM. Тогда время простоя CPU увеличится на 4 порядка (до 10000000 тактов).

Надеюсь, этот пример помог вам оценить, насколько дорого обходятся ошибка механизма кэширования, называемая **промахом**. Программист должен всегда помнить об иерархии памяти и учитывать её при разработке своих алгоритмов. Некоторые алгориты приводят к большему числу промахов, чем другие.

Обратите внимание, что чем меньше время доступа к памяти, тем ближе она физически расположена к процессору (см. иллюстрацию 1-11). Наример, внутренняя память CPU (регистры и кэш) находится внутри его кристалла. Оперативная память (RAM) расположена на [**материнской плате**](https://ru.wikipedia.org/wiki/Материнская_плата) рядом с процессором и соединена с ним по высокочастотной [**шине данных**](https://ru.wikipedia.org/wiki/Шина_данных). Дисковая память подключается к материнской плате через относительно медленную шину данных (например, [SATA](https://ru.wikipedia.org/wiki/SATA)).

{caption: "Иллюстрация 1-11. Материнская плата PC", height: "50%"}
![Материнская плата](images/GeneralInformation/motherboard-memory.png)

I> За загрузку данных из RAM в кэш процессора отвечает системный контроллер под названием [**северный мост**](https://ru.wikipedia.org/wiki/Северный_мост_(компьютер)). В ранних версиях персональных компьютеров он представлял собой отдельный чип на материнской плате. В дальнейшем с развитием технологии изготовления процессоров в их кристаллы стали встраивать северный мост. За чтение данных с жёсткого диска в оперативную память отвчает контроллер под названием [**южный мост**](https://ru.wikipedia.org/wiki/Южный_мост_(компьютер)).

### Машинный код

Предположим, что ОС успешно загрузила содержимое исполняемого файла приложения в оперативную память. В этом файле хранятся данные и [**машинный код**](https://ru.wikipedia.org/wiki/Машинный_код) программы. Этот код представляет собой инструкции процессора, которые могут быть исполнены его логическими блоками. Каждая такая инструкция является элементарной операцией над данными, загруженными в регистры CPU.

Если вы откроете исполняемый файл в [**Hex-редакторе**](https://ru.wikipedia.org/wiki/Hex-редактор), то увидите машинный код в [шестнадцатеричной системе счисления](https://ru.wikipedia.org/wiki/Шестнадцатеричная_система_счисления). На самом деле в файле хранится [**двоичный код**](https://ru.wikipedia.org/wiki/Двоичный_код#Примеры_двоичных_чисел), а редактор для удобства чтения переводит его в шестнадцатеричный формат. Именно в двоичном коде процессор получает свои инструкции.

Таблица 1-2 демонстриурет соответствие чисел в двоичной (binary, BIN), десятичной (decimal, DEC) и шестнадцатеричной (hexadecimal, HEX) системах счисления.

{caption: "Таблица 1-2. Числа в разных системах счисления", width: "50%"}
| Десятичная | Шестнадцатеричная | Двоичная |
| --- | --- | --- |
| 0 | 0 | 0000 |
| 1 | 1 | 0001 |
| 2 | 2 | 0010 |
| 3 | 3 | 0011 |
| 4 | 4 | 0100 |
| 5 | 5 | 0101 |
| 6 | 6 | 0110 |
| 7 | 7 | 0111 |
| 8 | 8 | 1000 |
| 9 | 9 | 1001 |
| 10 | A | 1010 |
| 11 | B | 1011 |
| 12 | C | 1100 |
| 13 | D | 1101 |
| 14 | E | 1110 |
| 15 | F | 1111 |

I> Для перевода из одной системы счисления в другую вы можете воспользоваться стандартным калькулятором Windows. Эта функция доступна в [**режиме "Программист"**](https://ru.wikipedia.org/wiki/Калькулятор_(Windows)#Режим_«Программист»).

Почему в программировании наряду с десятичной системой активно используются двоичная и шестнадцатеричная? На двоичной системе строится вся современная [**цифровая техника**](https://ru.wikipedia.org/wiki/Цифровые_технологии). Самый простой способ представления [**сигнала**](https://ru.wikipedia.org/wiki/Сигнал) это различие двух состояний: когда он есть и когда его нет. Наличие сигнала кодируется единицей, а отсутствие - нулём. Дальше возможно построить [логические элементы](https://ru.wikipedia.org/wiki/Логический_вентиль), которые на вход принимают несколько сигналов, а на выход выдают результирующий сигнал, согласно одной из операций [**булевой алгебры**](https://ru.wikipedia.org/wiki/Булева_алгебра). Последовательное соединение таких элементов позволяет получить достаточно сложное поведение. По-сути центральный процессор есть ни что иное, как огромная сеть логических элементов. Получается, что использование двоичной системы счисления в программировании продиктовано особенностью работы аппаратуры.

Зачем нам понадобилась шестнадцатеричная система? На самом деле программисты либо используют десятичную систему, либо двоичную. DEC удобна при написании высокоуровневой логики программы. Например, сколько раз следует повторить то или иное действие. BIN появляется, когда программе приходится взаимодействовать с аппаратурой. Например, подготовка данных для передачи на устройство, скорее всего, будет происходить в двоичной системе. Проблема двоичной системы в том, что она неудобна человеку для записи, чтения, запоминания и произношения. Перевод же из DEC в BIN достаточно сложен. Именно эту проблему решает шестнадцатеричная система. Она такая же компактная, как и десятичная, а перевод из BIN в HEX и обратно можно производить в уме.

I> Чтобы перевести число из BIN в HEX достаточно разбить его на группы по четыре разряда, начиная с конца. Если последняя группа оказалась меньше четырёх разрядов её надо дополнить нулями впереди. Затем по таблице 1-2 каждую четвёрку заменяем на шестнадцатеричное число. Пример перевода:
```
110010011010111 = 0110 0100 1101 0111 = 6 4 D 7 = 64D7 
```

{quiz, id: "Упражнение 1. Перевод чисел из BIN в HEX"}
? Чему равно BIN число 10100110100110 в шестнадцатеричной системе счисления?

! 29A6
{/quiz}

Вернёмся к нашему исполняемому файлу приложения. Кроме него в оперативную память загружаются все необходимые для его работы библиотеки (в том числе и системные). За эту процедуру отвечает [**загрузчик программ Windows**](https://ru.wikipedia.org/wiki/Загрузчик_программ). Только после этого программа исполняется процессором, начиная с её первой инструкции. Когда программа вызывает функцию из какой-то библиотеки, соответствующий код уже находится в оперативной памяти. Благодаря этому, удаётся избежать простоев процессора из-за чтения данных с жёсткого диска.

После окончания работы программы, занимаемая ей и необходимыми библиотеками область RAM очищается и используется для другого приложения.

### Исходный код

Очевидно, для человека неудобно и трудоёмко писать программу в двоичных кодах. Особенно остро эта проблема начала проявляться с увеличением мощности компьютеров и усложнении программ для них. Для решения этой проблемы появились специальные приложения: [**компиляторы**](https://ru.wikipedia.org/wiki/Компилятор) и [**интерпретаторы**](https://ru.wikipedia.org/wiki/Интерпретатор). Они решают одну и ту же задачу - прочитать текст программы, написанный на каком-то [**языке программирования**](https://ru.wikipedia.org/wiki/Язык_программирования) и перевсти его на язык, понятный процессору. Этот текст программы называется [**исходным кодом**](https://ru.wikipedia.org/wiki/Исходный_код).

Подход компиляторов и интерпретаторов различается. Ключевое отличие в моменте генерации машинного кода из исходного. Компиляторы генерируют инструкции процессора заранее. Интерпретаторы же выполняют эту генерацию непосредственно в момент исполнения программы.

Предположим, что вы пишете программу и сохраняете её исходный код в файле на жёстком диске. Дальше вы решаете применить компилятор. После его запуска на диске бует создан новый файл. В нём содержится машинный код, соответствующий исходному коду вашей программы. Теперь достаточно запустить полученный файл и ваша программа будет выполнена.

Иллюстрация 1-12 демонстрирует процесс компиляции программы.

{caption: "Иллюстрация 1-12. Компиляция программы", height: "50%", width: "100%"}
![Компиляция программы](images/GeneralInformation/compiler.png)

Из иллюстрации видно, что процесс компиляции на самом деле состоит из двух этапов. Первый этап выполняется компилятором. Второй этап выполняется [**компановщиком**](https://ru.wikipedia.org/wiki/Компоновщик) и называется **линковка**.

Может возникнуть вопрос - зачем нужен промежуточный этап с созданием объектных файлов? Почему нельзя объединить компилятор и линковщик в одну программу?

У такого решения есть две проблемы. Первая из них заключается в ограниченном размере оперативной памяти. Когда компилятор читает исходный код программы, он строит его промежуточное представление. Это представление хранится в RAM и может по различным причинам значительно превосходить по размеру файл исходного кода. Теперь представьте, что компиляция всех текстовых файлов происходит одновременно. В этом случае очень высока вероятность, что оперативной памяти просто не хватит.

Вторая проблема заключается в разрешении зависимостей. Функции каждого из трёх текстовых файлов могут вызывать друг друга. Компилятору потребовалось бы намного больше времени, чтобы сопоставить эти перекрёстные вызовы сразу в процессе компиляции. Кроме того возможны случаи, когда для получения исполняемого файла необходима дополнительная библиотека. В этом случае она выполняет роль ещё одного объектного файла, который подаётся на вход компоновщика. Из-за этих проблем разделение компиляции на два этапа даёт более надёжное и гибкое решение.

Теперь допустим, что для исполнения программы вы выбираете интерпретатор. В этом случае файл с исходным кодом уже готов для исполнения. Чтобы его исполнить, ОС сначала запускает интерпретатор. Далее интерпретатор читает файл с исходным кодом с диска в оперативную память и начинает его выполнение строка за строкой. При этом преобразование каждой команды исходного кода в машинный код происходит в оперативной памяти. В целях оптимизации некоторые интерпретаторы сохраняют на жёсткий диск файлы с промежуточным представлением программы. Но главная идея остаётся неизменной - для исполнения программы всегда нужен интерпретатор.

Иллюстрация 1-13 демонстрирует процесс интерпретации программы.

{caption: "Иллюстрация 1-13. Интерпретация программы", height: "50%", width: "100%"}
![Интерпретация программы](images/GeneralInformation/interpreter.png)

Задумайтесь над рассмотренными нами проблемами компиляции за один этап, а затем посмотрите ещё раз на иллюстрацию 1-13. Кажется, что интерпретатор делает нечто,  похожее на работу "одноэтапного" компилятора. Он загружает все текстовые файлы в оперативную память, строит их промежуточное представление, а затем разрешает зависимости. Как ему всё это удаётся?

На самом деле интерпретатор работает по-другому. Как уже было замечено, он выполняет программу строка за строкой. Это значит, что ему нет необходимости хранить в памяти код всего приложения и его промежуточное представление. Достаточно обрабатывать исходный код по мере надобности. В случае нехватки оперативной памяти, уже обработанные команды могут быть выгружены.

Если вы вспомните схему иерархии памяти, то поймёте насколько медленно работает интерпретатор. Загрузки и выгрузки кода из RAM обходятся очень дорогими простоями процессора. Кроме того на выполнение кода самого интепретатора, также требуются аппаратные ресурсы. Всё это приводит к тому, что интерпретация программ - это очень требовательный к ресурсам вычислительный процесс.

Как мы выяснили, использование интерпретатора приводит к накладынм расходам во время исполнения программы. Есть ли подобная плата при использовании компилятора? Компилятор производит файл с машинным кодом. Поэтому с небольшими оговорками можно утверждать, что эффективность выполнения скомпилированного приложения почти такая же, как и приложения, написанном изначально в машинных кодах. Плата возникает ранее, на этапе компиляции. Если речь идёт о небольших приложениях, то необходимые для их компиляции время и вычислительные ресурсы незначительны. Но когда скомпилировать надо большой и сложный проект (например, ядро ОС), этот процесс может занимать несколько часов на достаточно мощном компьютере. Любое изменение исходного кода приведёт к повторной компиляции. Поэтому накладные расходы есть при использовании любого языка программирования. Вопрос только в том, когда произойдёт эта плата за удобство.

Может возникнуть мысль, что использование языков неоправдано. Часы необходимые на компиляцию проекта, которые вместо этого могли бы быть потрачены на разработку программы. Расход аппаратных ресурсов на работу интерпретатора. Всего этого можно было бы избежать, просто написав программу сразу в машинных кодах. Но обратимся к примеру, чтобы оценить преимущества, которые дают языки программирования. Листинг 1-1 демонстрирует исходный код программы на языке C. Она выводит на консоль текст "Hello world!".

{caption: "Листинг 1-1. Исходный код программы на языке C", format: C}
![`HelloWorld.c`](code/GeneralInformation/HelloWorld.c)

В листинге 1-2 приведена та же самая программа в виде машинного кода (в шестнадцатеричном представлении).

{caption: "Листинг 1-2. Машинный код программы"}
![`MachineCode.txt`](code/GeneralInformation/MachineCode.txt)

Очевидно, что код из листинга 1-1 намного проще прочитать, понять и отредактировать в случае необходимости. Возможно код из листинга 1-2 просто написать, но разобраться в нём другому программисту будет очень непросто.

Любой язык программирования удобнее и выразительнее двоичного кода. Благодаря чему, написанные на нём программы намного проще (а значит быстрее и дешевле) разрабатывать и поддерживать.
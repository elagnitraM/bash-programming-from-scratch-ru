# Компьютерная программа

Мы рассмотрели функции ОС. Теперь познакомимся с компьютерной программой. Что она из себя представляет? Как происходит её запуск и исполнение? Попробуем отвтить на эти вопросы.

## Память компьютера

Любая компьютерная программа исполняется [центральным процессором](https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80) (CPU). Она хранится на жёстком диске в виде файла. Когда вы запускаете её, ОС загружает содержимое этого файла в оперативную память. Сразу возникает вопрос: зачем это нужно? Почему нельзя просто исполнить файл на диске?

В современном компьютере есть [несколько уровней памяти](https://ru.wikipedia.org/wiki/%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8). Они изображены на иллюстрации 1-1.

![Уровни памяти](memory-levels.png)

_**Иллюстрация 1-1.** Уровни памяти персонального компьютера_

Стрелки на иллюстрации 1-1 соответствуют потокам данных. Их загрузка и выгрузка возможна только между соседними уровнями памяти. Другими словами если процессору нужны данные с дисковой памяти, они будут сначала загружены в оперативную память, затем в кэш и только потом попадут в регистры. Аналогичным образом происходит и обратный процесс записи данных на диск.

Уровни памяти отличаются друг от друга несколькими параметрами:

1. **Скорость доступа** определяет объём данных, читаемый или записываемых в единицу времени на носитель. Обычно измеряется в [**байтах**](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B9%D1%82) за секунду (байт/с).

2. **Объём** — количество данных, которое может храниться на носителе. Измеряется в байтах.

3. **Стоимость** — цена носителя в соотношении к его объёму. Измеряется в долларах или центах за байт или бит.

4. **Время доступа** — время, через которое процессор получит доступ к прочитанным данным. Обычно измеряется в **тактовых сигналах** проецссора.

Соотношение рассмотренных параметров для разных типов памяти приведено в таблице 1-1.

_**Таблица 1-1.** Уровни памяти персонального компьютера_

| Уровень | Память | Объём | Скорость доступа | Время доступа | Стоимость |
| --- | --- | --- | --- | --- | --- |
| 1 | [**Регистры**](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0) процессора. | до тысячи байтов | — | 1 такт | — |
| 2 | [**Кэш**](https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0) память процессора. | от одного килобайта до нескольких мегабайтов | от 700 до 100 гигабайт/сек | от 2 до 100 тактов | — |
| 3 | Оперативная память (RAM) | десятки гигабайтов | 10 гигабайт/сек | до 1000 тактов | $10<sup>-9</sup>/байт |
| 4 | Дисковая память ([**жёсткие диски**](https://ru.wikipedia.org/wiki/%D0%96%D1%91%D1%81%D1%82%D0%BA%D0%B8%D0%B9_%D0%B4%D0%B8%D1%81%D0%BA) и [**твёрдотельные накопители**](https://ru.wikipedia.org/wiki/%D0%A2%D0%B2%D0%B5%D1%80%D0%B4%D0%BE%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BD%D0%B0%D0%BA%D0%BE%D0%BF%D0%B8%D1%82%D0%B5%D0%BB%D1%8C)) | терабайты | 2000 мегабайт/сек | до 10000000 тактов | $10<sup>-12</sup>/байт |

Таблица 1-1 вызывает вопросы. Разве скорости доступа к данным в 2000 Мб/с недостаточно для чтения и исполнения файла приложения размером с десятки мегабайт? На самом деле важна не столько скорость чтения данных в байтах, а то как долго простаивает процессор, дожидаясь доступа к ним. Это время доступа к памяти измеряется в числе [тактовых сигналов](https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%BA%D1%82%D0%BE%D0%B2%D1%8B%D0%B9_%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB) или тактах. Такт синхронизирует выполнение всех операций процессора. Как правило, элементарная операция занимает от одного до нескольких тактов.

Итак, если бы процессору приходилось читать код программы с жёсткого диска и записывать на него промежуточные данные и результаты, выполнение простейших алгоритмов заняло бы в лучшем случае недели. Причём большую часть этого времени процессор простаивал бы, находясь в ожидании выполнения операций чтения и записи. Иерархическая организация памяти позволяет на порядки ускорить доступ к данным, необходимым процессору в данный момент. Тем самым решается проблема его простаивания.

Обратите внимание, что чем меньше время доступа к памяти, тем ближе она физически расположена к процессору. Наример, внутренняя память CPU (регистры и кэш) находится внутри его кристалла. Оперативная память расположена на [**материнской плате**](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%BD%D1%81%D0%BA%D0%B0%D1%8F_%D0%BF%D0%BB%D0%B0%D1%82%D0%B0) рядом с процессором и соединена с ним по высокочастотной [**шине данных**](https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D0%BD%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85). Дисковая память подключается к материнской плате через относительно медленную шину данных.

## Машинный и исходный код

Предположим ОС успешно загрузила данные из исполняемого файла приложения в оперативную память. В этом файле хранится [**машинный код**](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4). Он представляет собой инструкции процессора, которые могут быть исполнены его логическими блоками. Каждая такая инструкция представляет собой элементарную операцию над данными, хранящимися в регистрах или кэше CPU.

Если вы откроете исполняемый файл в редакторе, то увидите машинный код в [шестнадцатеричном](https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D1%81%D1%82%D0%BD%D0%B0%D0%B4%D1%86%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F) представлении. На самом деле в файле хранится [**двоичный код**](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%C2%AB%D0%B4%D0%BE%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B3%D0%BE%C2%BB_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2), а редактор для удобства чтения переводит его в шестнадцатеричный формат. Именно в двоичном коде процессор принимает свои инструкции. Очевидно, для человека писать программу в двоичных кодах неудобно и трудоёмко. Поэтому появились специальные приложения: [**компиляторы**](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80) и [**интерпретаторы**](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%82%D0%BE%D1%80#%D0%98%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F). Их задача заключается в трансляции текста программы, написанном на каком-то [**языке программирования**](https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F), в машинный код. Этот текст называется [**исходным кодом**](https://ru.wikipedia.org/wiki/%D0%98%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4).

Рассмотрим пример. Листинг 1-1 демонстрирует исходный код программы на языке C, выводящий на консоль текст "Hello world!".

_**Листинг 1-1.** Исходный код программы на языке C_
```C
#include <stdio.h>

int main(void)
{
    printf("Hello world!\n");
}
```

В листинге 1-2 приведена та же самая программа в виде машинного кода (в шестнадцатеричном представлении).

_**Листинг 1-2.** Машинный код программы_
```
BB 11 01 B9 0D 00 B4 0E 8A 07 43 CD 10 E2 F9 CD 20 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21
```

Очевидно, что код из листинга 1-1 намного проще прочитать, понять и отредактировать в случае необходимости. Именно эти преимущества работы с исходным кодом и обеспечивают компиляторы и интерпретаторы. Рассмотрим подробнее принцип их работы и различия.

### Компилятор

// TODO: Сделать схему компиляции исходного кода в машинный и его исполнение.

### Интерпретатор

// TODO: Сделать схему интерпретации исходного кода в машинный и его исполнение.

Идея интерпретаторов заключается в том, чтобы читать команды программы из файла построчно и сразу же отправлять их процессору для исполнения. То есть можно сказать, что интерпретатор — это программа, которая переводит команды программы на "язык" процессора.

Текст приложения пишется на каком-то [языке программирования](https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F), отличном от двоичного кода процессорных инструкций. Этот текст называется [**исходным кодом**](https://ru.wikipedia.org/wiki/%D0%98%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4). Интерпретатор читает исходный код из файла на диске и исполняет указанные в нём команды друг за другом.

Очевидно, процесс интерпретации значительно замедляет работу приложения. Вместо его непосредственного исполнения на процессоре, появляется программа-посредник. Получается, что компьютер должен предоставлять ресурсы не только вашему приложению, но и его интерпретатору. Однако, эта плата за удобство разработки программ зачастую приемлема. Как правило, язык программирования намного удобнее и выразительнее двоичного кода. Благодаря чему, написанные на нём программы намного проще (а значит и дешевле) разрабатывать и поддерживать.

// TODO: Рассказать про альтернативы интерпретаторов компиляторы. Начать с них, а потом перейти к интерпретаторам.
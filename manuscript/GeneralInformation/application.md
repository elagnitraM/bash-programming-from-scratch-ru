## Компьютерная программа

Мы рассмотрели функции ОС. Теперь познакомимся с компьютерной программой. Что она из себя представляет? Как происходит её запуск и исполнение? Попробуем отвтить на эти вопросы.

### Память компьютера

Любая компьютерная программа исполняется центральным процессором (CPU). Она хранится на жёстком диске или другом носителе информации в виде файла. Когда вы запускаете её, ОС загружает содержимое этого файла в оперативную память. Сразу возникает вопрос: зачем это нужно? Почему нельзя просто исполнить файл на диске?

В современном компьютере есть несколько [уровней памяти](https://ru.wikipedia.org/wiki/Иерархия_памяти). Они изображены на иллюстрации 1-10.

{caption: "Иллюстрация 1-10. Уровни памяти персонального компьютера", height: "50%"}
![Уровни памяти](images/GeneralInformation/memory-levels.png)

Стрелки на иллюстрации 1-10 соответствуют потокам данных, загрузка и выгрузка которых возможна только между соседними уровнями памяти. Другими словами если процессору нужны данные с дисковой памяти, они будут сначала загружены в оперативную память, затем в кэш CPU и только потом попадут в его регистры. Аналогичным образом происходит и обратный процесс записи данных на диск.

Уровни памяти отличаются друг от друга несколькими параметрами:

1. **Скорость доступа** определяет объём данных, читаемый или записываемых в единицу времени на носитель. Обычно измеряется в [**байтах**](https://ru.wikipedia.org/wiki/Байт) за секунду (байт/с).

2. **Объём** — количество данных, которое может храниться на носителе. Измеряется в байтах.

3. **Стоимость** — цена носителя в соотношении к его объёму. Измеряется в долларах или центах за байт или бит.

4. **Время доступа** — время, через которое процессор получит доступ к прочитанным данным. Обычно измеряется в [**тактовых сигналах**]((https://ru.wikipedia.org/wiki/Тактовый_сигнал)) проецссора.

Соотношение рассмотренных параметров для разных типов памяти приведено в таблице 1-1.

{caption: "Таблица 1-1. Уровни памяти персонального компьютера", width: "100%", column-widths: "10%,30%,*"}
| Уровень | Память | Объём | Скорость доступа | Время доступа | Стоимость |
| --- | --- | --- | --- | --- | --- |
| 1 | [**Регистры**](https://ru.wikipedia.org/wiki/Регистр_процессора) процессора. | до тысячи байтов | — | 1 такт | — |
| 2 | [**Кэш**](https://ru.wikipedia.org/wiki/Кэш_процессора) память процессора. | от одного килобайта до нескольких мегабайтов | от 700 до 100 гигабайт/сек | от 2 до 100 тактов | — |
| 3 | Оперативная память (RAM) | десятки гигабайтов | 10 гигабайт/сек | до 1000 тактов | $10^-9^/байт |
| 4 | Дисковая память ([**жёсткие диски**](https://ru.wikipedia.org/wiki/Жёсткий_диск) и [**твёрдотельные накопители**](https://ru.wikipedia.org/wiki/Твердотельный_накопитель)) | терабайты | 2000 мегабайт/сек | до 10000000 тактов | $10^-12^/байт |

Таблица 1-1 вызывает вопросы. Разве скорости доступа к данным в 2000 Мбайт/с недостаточно для чтения и исполнения файла приложения размером с десятки мегабайт? На самом деле важна не столько скорость чтения данных в байтах, а то как долго простаивает процессор, дожидаясь доступа к ним. Это время доступа к памяти измеряется в числе тактовых сигналов или тактах. Такт синхронизирует выполнение всех операций процессора. Как правило, элементарная операция занимает от одного до нескольких тактов.

Итак, если бы процессору приходилось читать код программы с жёсткого диска и записывать на него промежуточные данные и результаты, выполнение простейших алгоритмов заняло бы в лучшем случае недели. Причём большую часть этого времени процессор простаивал бы, находясь в ожидании выполнения операций чтения и записи. Иерархическая организация памяти позволяет на порядки ускорить доступ к данным, необходимым процессору в данный момент. Тем самым решается проблема его простаивания. Как это происходит?

Представьте, что процессор исполняет программу. Например, она читает файл с диска и выводит его содержимое на экран. При этом, согласно иллюстрации 1-10, данные с диска сначала будут загружены в оперативную память. Затем по частям они будут загружаться в кэш процессора, а оттуда в его регистры. После этого CPU вызовет функцию из системной библиотеки ОС, в которую эти данные передаются. Функция с помощью драйвера видеокарты выведет данные на экран. Проблема может возникнуть, когда процессор вызвал функцию и переходит к следующему блоку данных из файла. Если окажется, что они ещё не загружены в регистры из кэша, то CPU проведёт в ожидании от 2 до 100 тактов (согласно таблице 1-1). Аналогично, если данные ещё не были загружены из RAM в кэш, то время ожидания вырастет на порядок (до 1000 тактов). Предположим, что читаемый файл оказался слишком велик и не помещается целиком в оперативную память. Тогда возможна ситуация, когда его часть, необходимая в данный момент процессору, еще не была загружена в RAM. Тогда время простоя CPU увеличится на 4 порядка (до 10000000 тактов).

Надеюсь, этот пример помог вам оценить, насколько дорого обходятся ошибка механизма кэширования, называемая **промахом**. Программист должен всегда помнить об иерархии памяти и учитывать её при разработке своих алгоритмов. Некоторые алгориты приводят к большему числу промахов, чем другие.

Обратите внимание, что чем меньше время доступа к памяти, тем ближе она физически расположена к процессору (см. иллюстрацию 1-11). Наример, внутренняя память CPU (регистры и кэш) находится внутри его кристалла. Оперативная память (RAM) расположена на [**материнской плате**](https://ru.wikipedia.org/wiki/Материнская_плата) рядом с процессором и соединена с ним по высокочастотной [**шине данных**](https://ru.wikipedia.org/wiki/Шина_данных). Дисковая память подключается к материнской плате через относительно медленную шину данных (например, [SATA](https://ru.wikipedia.org/wiki/SATA)).

{caption: "Иллюстрация 1-11. Материнская плата PC", height: "50%"}
![Материнская плата](images/GeneralInformation/motherboard-memory.png)

### Машинный код

Предположим, что ОС успешно загрузила содержимое исполняемого файла приложения в оперативную память. В этом файле хранятся данные и [**машинный код**](https://ru.wikipedia.org/wiki/Машинный_код). Этот код представляет собой инструкции процессора, которые могут быть исполнены его логическими блоками. Каждая такая инструкция является элементарной операцией над данными, загруженными в регистры CPU.

Если вы откроете исполняемый файл в редакторе, то увидите машинный код в [шестнадцатеричном](https://ru.wikipedia.org/wiki/Шестнадцатеричная_система_счисления) представлении. На самом деле в файле хранится [**двоичный код**](https://ru.wikipedia.org/wiki/Двоичный_код#Пример_«доисторического»_использования_кодов), а редактор для удобства чтения переводит его в шестнадцатеричный формат. Именно в двоичном коде процессор получает свои инструкции.

Кроме исполняемого файла приложения в оперативную память загружаются все необходимые для его работы библиотеки (в том числе и системные). За эту процедуру отвечает [**загрузчик программ Windows**](https://ru.wikipedia.org/wiki/Загрузчик_программ). Только после этого программа исполняется процессором, начиная с её первой инструкции.

### Исходный код

Очевидно, для человека неудобно и трудоёмко писать программу в двоичных кодах. Для решения этой проблемы появились специальные приложения: [**компиляторы**](https://ru.wikipedia.org/wiki/Компилятор) и [**интерпретаторы**](https://ru.wikipedia.org/wiki/Интерпретатор). Задача этих приложений одна и та же - прочитать текст программы, написанный на каком-то [**языке программирования**](https://ru.wikipedia.org/wiki/Язык_программирования) и перевсти его на язык, понятный процессору. Этот текст программы называется [**исходным кодом**](https://ru.wikipedia.org/wiki/Исходный_код). 

Подход компиляторов и интерпретаторов отличается. Ключевое их отличие заключается в моменте генерации машинного кода из исходного. Компиляторы генерируют инструкции процессора заранее. Интерпретаторы же выполняют эту генерацию непосредственно в момент исполнения программы.

Предположим, что вы пишете программу и сохраняете её исходный код в файле на жёстком диске. Дальше вы решаете применить компилятор. После его запуска на диске бует создан новый файл. В нём содержится машинный код, соответствующий исходному коду вашей программы. Теперь достаточно запустить полученный файл и ваша программа будет выполнена.

Рассмотрим пример. Листинг 1-1 демонстрирует исходный код программы на языке C, выводящий на консоль текст "Hello world!".

{caption: "Листинг 1-1. Исходный код программы на языке C", format: C}
![`HelloWorld.c`](code/GeneralInformation/HelloWorld.c)

В листинге 1-2 приведена та же самая программа в виде машинного кода (в шестнадцатеричном представлении).

{caption: "Листинг 1-2. Машинный код программы"}
![`MachineCode.txt`](code/GeneralInformation/MachineCode.txt)

Очевидно, что код из листинга 1-1 намного проще прочитать, понять и отредактировать в случае необходимости. Именно эти преимущества работы с исходным кодом и обеспечивают компилятор.

Допустим, что вместо компилятора вы выбираете интерпретатор. Опять же ваша программа сохранена в файле. 

#### Компилятор

// TODO: Сделать схему компиляции исходного кода в машинный и его исполнение.

#### Интерпретатор

// TODO: Сделать схему интерпретации исходного кода в машинный и его исполнение.

Идея интерпретаторов заключается в том, чтобы читать команды программы из файла построчно и сразу же отправлять их процессору для исполнения. То есть можно сказать, что интерпретатор — это программа, которая переводит команды программы на "язык" процессора.

Текст приложения пишется на каком-то [языке программирования](https://ru.wikipedia.org/wiki/Язык_программирования), отличном от двоичного кода процессорных инструкций. Этот текст называется [**исходным кодом**](https://ru.wikipedia.org/wiki/Исходный_код). Интерпретатор читает исходный код из файла на диске и исполняет указанные в нём команды друг за другом.

Очевидно, процесс интерпретации значительно замедляет работу приложения. Вместо его непосредственного исполнения на процессоре, появляется программа-посредник. Получается, что компьютер должен предоставлять ресурсы не только вашему приложению, но и его интерпретатору. Однако, эта плата за удобство разработки программ зачастую приемлема. Как правило, язык программирования намного удобнее и выразительнее двоичного кода. Благодаря чему, написанные на нём программы намного проще (а значит и дешевле) разрабатывать и поддерживать.

// TODO: Рассказать про альтернативы интерпретаторов компиляторы. Начать с них, а потом перейти к интерпретаторам.
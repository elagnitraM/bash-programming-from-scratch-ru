## Интерпретатор командной строки

Мы познакомились с интерпретаторами. Они позволяют загружать с жёсткого диска и исполнять текстовые файлы с исходным кодом программ. Но это не единственный способ применения интерпретатора. Альтернативный способ заключается в его запуске в интерактивном режиме. В таком режиме команды для исполнения будут читаться не из файла, а из командной строки. То есть пользователь может набирать команды и сразу их исполнять. Программы поддерживающие такую возможность называются [**интерпретаторами командной строки**](https://ru.wikipedia.org/wiki/Интерпретатор_командной_строки).

Как правило, интерпретаторы командной строки являются частью ОС и предоставляют пользователю интерфейс для доступа к её функциям. Также через командную строку происходит запуск других приложений.

Как было отмечено ранее, интерфейс командной строки возник раньше чем GUI. Поэтому он был единственным средством управления компьютером в ОС 70-х и 80-х годов.

### Востребованность

Прежде чем начать писать скрипты на Bash, было бы полезно освоить работу его интерпретатора в режиме командной строки. Мы уже рассматривали этот тип интерфейса с исторической точки зрения. Он был повсеместно распространён 40 лет назад на относительно слабых по современным меркам компьютерах. Возникший позднее GUI полностью его вытеснил, по крайней мере на платформе PC.

Может возникнуть вопрос - есть ли какая-то практическая польза от изучения Bash сегодня? Ведь судя по всему следует, что это устаревшая технология, давно отжившая свой век. Это утверждение ошибочно. Не просто так Bash входит в [дистрибутивы](https://ru.wikipedia.org/wiki/Дистрибутив_операционной_системы) современных версий macOS и Linux. В Windows тоже есть редко используемый обычными пользователями интерпретатор командной строки [Cmd.exe](https://ru.wikipedia.org/wiki/Cmd.exe), поддерживающий исполнение [пакетных файлов](https://ru.wikipedia.org/wiki/Пакетный_файл). Впоследствии он был заменён на более мощный [PowerShell](https://ru.wikipedia.org/wiki/PowerShell). Задумайтесь над этим: в 2006 году Microsoft разрабатывает новый интерпретатор командной строки. На это определённо были свои причины.

Для чего же используется интерфейс командной строки сегодня? Прежде всего для задач [администрирования](https://ru.wikipedia.org/wiki/Системный_администратор) ОС. Современная ОС представляет собой множество взаимодействующих программ, у многих из которых есть свои параметры и настройки. Было бы очень трудоёмко разрабатывать GUI для конфигурации каждого из этих параметров, особенно если в обычной работе они используются редко. Но доступ к такой внутренней конфигурации и функциям становится крайне необходим, чтобы восстановить вышедшую из строя ОС. Кроме того, при сбое системы, её GUI может оказаться недоступен. Утилиты же восстановления часто имеют только интерфейс командной строки.

I> Интерпретатор Bash хорошо интегрирован в операционные системы семейств Linux и macOS. Через него можно получить доступ практически ко всем важным функциям ОС. Однако, интеграция Bash с Windows достаточно слабая. Вместо него для целей администрирования системы лучше подойдёт PowerShell. Почему же тогда мы изучаем Bash? Потому что он совместим со стандартом [POSIX](https://ru.wikipedia.org/wiki/POSIX) и на практике встречается чаще, чем PowerShell. Кроме того, в отличие от PowerShell, Bash доступен на всех популярных сегодня ОС.

CLI удобен при [подключении](https://ru.wikipedia.org/wiki/Программы_удалённого_администрирования) к удалённому компьютеру по сети. В этом случае для нормальной работы GUI требуется стабильное и быстрое сетевое соединения, которое доступно не всегда.

Когда возникают неполадки, знание интерфейса командной строки окажется полезным. Но нужно ли оно рядовому пользователю? На самом деле, CLI может значительно ускорить работу и рутинные операции. Хорошим примером служит обработка большого количества файлов. Представтье себе, что у вас есть десять файлов. К имени каждого из них вам нужно добавить некоторый суффикс. Эти переименования можно достаточно быстро выполнить вручную через [Проводник Windows](https://ru.wikipedia.org/wiki/Проводник_Windows). Теперь допустим, что вам надо переименовать не десять файлов, а пять тысяч. Как долго вы будете заниматься этим через GUI? Этот пример демонстрирует одну из сильных сторон CLI - многие команды интерпретатора хорошо [масштабируются](https://wiki.monavista.ru/Масштабируемость). В данном случае это означает, что они не требуют дополнительных действий от пользователя при значительном увеличении входных данных.

Программисты в своей профессиональной деятельности часто сталкиваются с большим количеством текстовых файлов с исходным кодом. Для работы с ними есть много удобных редакторов. Но эти редакторы опять же предоставляют графический интерфейс. Часто возникают ситуации, когда требуется внести изменение во все файлы проекта разом. В этом случае мы опять сталкиваемся с проблемой масштабируемости и многократного повторения одних и тех же действий вручную. Интерпретатор командной строки значительно ускоряет работу в подобных случаях.

Есть ещё одна важная особенность разработки [программного обеспечения](https://ru.wikipedia.org/wiki/Программное_обеспечение) (ПО), малоизвестная обычным пользователям. Практически все компиляторы и интерпретаторы имеют только интерфейс командной строки. Это связано с особенностями решаемой ими задачи, котоаря заключается в обработке большого числа файлов. Как мы уже выяснили, GUI плохо с ней справляется. Он неэффективен, и именно поэтому почти всегда отсутствует.

I> Некоторые читатели могут возразить, что большинство [**интегрированных сред разработки**](https://ru.wikipedia.org/wiki/Интегрированная_среда_разработки) (integrated development environment, IDE) предоставляет возможность компиляции и запуска программ из графического интерфейса. Это так. Но на самом деле, когда вы нажимаете на соответствующую кнопку GUI среды, происходит вызов компилятора с CLI интерфейсом. Список файлов и флаги компиляции передаются ему как параметры командной строки.

С разработкой связано ещё одно полезное, но неочевидное свойство командной строки. Программу, имеющую только текстовый интерфейс, обычно быстрее и проще разрабатывать, чем аналогичную с GUI. Почему это важно? Разработчики часто сталкиваются в своей работе с объёмными задачами, требующими большого количества действий. В этом случае принято подсчитывать: сколько времени уйдёт на выполнение задачи вручну и сколько на написание скрипта для автоматизации. Поскольку программы с текстовым интерфейсом быстрее писать, чаще выбор будет сделан в пользу вспомогательных скриптов. Это в свою очередь позволит избежать ошибок при ручной работе.

Надеюсь, я смог вас убедить, что базовые навыки работы с интерфейсом командной строки крайне важны для любого ИТ специалиста.

### Действия над файлами и каталогами

Мы знаем, как найти нужный нам файл или каталог на диске. Какие действия мы можем над ними совершить? Скорее всего, вам этот список хорошо знаком по опыту работы с графическим интерфейсом ОС:

1. Создание
2. Удаление
3. Копирование
4. Переименование

В таблице 2-5 приводятся команды, соответствующие этим действиям.

{caption: "Таблица 2-5. Команды для работы с файлами и каталогами", width: "100%"}
| Команда | Описание | Примеры |
| --- | --- | --- |
| `mkdir` | Создание каталога с указанным именем и путём. | `mkdir /tmp/docs` |
| | | `mkdir -p tmp/docs/report` |
| --- | --- | --- |
| `rm` | Удалить указанный файл или каталог по абсолютному или относительному пути. | `rm readme.txt` |
| | | `rm -rf ~/tmp` |
| --- | --- | --- |
| `cp` | Скопировать файл или каталог. Первым параметром передаётся текущий путь, а вторым - целевой. | `cp readme.txt tmp/readme.txt` |
| | | `cp -r /tmp ~/tmp` |
| --- | --- | --- |
| `mv` | Переименовать указанный первым параметром файл или каталог. | `mv readme.txt documentation.txt.` |
| | | `mv ~/tmp ~/backup` |

Кратко рассмотрим эти команды. Теперь вы знаете, как пользоваться помощью. Поэтому если возникнут вопросы, вам будет просто найти на них ответы.

##### mkdir

Чтобы создать новый каталог, воспольузйтесь командой `mkdir`. Для этого первым параметром передайте его абсолютный или относительный путь. Например, чтобы создать каталог `docs` в домашнем каталоге пользователя выполните команду:
{line-numbers: false}
```
mkdir ~/docs
```
Либо вы можете сначала перейти в каталог пользователя, а потом создать в нём каталог:
{line-numbers: false}
```
cd ~
mkdir docs
```
У команды `mkdir` есть полезный параметр `-p`. Он позволяет создать не только указанный каталог, но и все его родительские каталоги. Например, вы хотите создать каталог для отчета за 2019 год. Он должен находится по пути `~/docs/reports/2019`. Предположим, что каталоги `docs` и `reports ` ещё не созданы. В графическом интерфейсе Windows вам сначала нужно создать их, а только потом каталог `2019`. В Bash для этого достаточно одной команды:
{line-numbers: false}
```
mkdir -p ~/docs/reports/2019
```
Обратите внимание, что если каталоги `docs` или `reports` уже существуют, сообщения об ошибке не будет. Команда создаст только недостающую часть пути.

##### rm

Команда `rm` удаляет файлы и каталоги. Для удаления одного файла просто укажите его относительный или абсолютный путь. Например:
{line-numbers: false}
```
rm report.txt
rm ~/docs/reports/2019/report.txt
```
Вы может также удалить несколько файлов, указав их через пробел:
{line-numbers: false}
```
rm report.txt ~/docs/reports/2019/report.txt
```
Также можно воспользоваться шаблоном поиска. Следующая команда удаляет все TXT файлы начинающиеся с слова "report":
{line-numbers: false}
```
rm ~/docs/reports/2019/report*.txt
```
Если вы попробуете удалить файл с доступом только на чтение, будет выведено предупреждение как на иллюстрации 2-24.

{caption: "Иллюстрация 2-24. Предупреждение при удалении файла с доступом на чтение", width: "100%"}
![Предупреждение `rm`](images/Bash/rm-warning.png)

Чтобы продолжить удаление, нажмите клавишу y (от yes), а затем Enter. Если вы хотите проигнорировать подобные предупреждения, воспользуйтесь параметром `-f` или `--force` команды `rm`:
{line-numbers: false}
```
rm -f ~/docs/reports/2019/report*.txt
```

Для удаления каталога вместе с его содержимым воспользуйтесь командой `rm` с параметром `-r` или `--recursive`:
{line-numbers: false}
```
rm -r ~/docs
```

#### cp и mv

Команды копирования и переименования файлов и каталогов однотипны. В обеих сначала указывается то, над чем совершается действие, потом путь назначения.

Например, команда для копирования файла `report.txt` в текущем каталоге, выглядит следующим образом:
{line-numbers: false}
```
cp report.txt report-2019.txt
```
После её исполнения будет создан файл `report-2019.txt` с тем же содержимым, что и `report.txt`.

Если старый файл `report.txt` вам больше не нужен, воспользуйтесь командой переимнования:
{line-numbers: false}
```
mv report.txt report-2019.txt
```
В этом случае файл `report.txt` будет удалён.

Вы можете указывать полные пути до файлов. Таким образом они будут копироваться или переносится между разными каталогами:
{line-numbers: false}
```
cp ~/report.txt ~/tmp/report-2019.txt
mv ~/report.txt ~/tmp/report-2019.txt
```

Переименование каталогов происходит точно так же, как и файлов:
{line-numbers: false}
```
mv ~/tmp ~/backup
```
В результате этой команды каталог `tmp` будет переименован в `backup`.

Для копирования каталога вместе с его содержимым необходимо указывать параметр `-r`:
{line-numbers: false}
```
cp -r /tmp ~/tmp
```
Эта команда копирует системный каталог `tmp` в домашний каталог пользователя.

Если при копировании или переименовании в целевом каталоге уже есть файл с тем же именем, будет выдано сообщение с подтверждением его перезаписи. Чтобы автоматически перезаписывать, воспользуйтесь параметром `-f`:
{line-numbers: false}
```
cp -f ~/report.txt ~/tmp
mv -f ~/report.txt ~/tmp
```
Если в каталоге `tmp` уже есть файл с именем `report.txt`, в результате этих команд он будет перезаписан.

{caption: "Упражнение 2-6. Использование команд для работы с файлами и каталогами", format: text, line-numbers: false}
```
Попробуйте упорядочить свои фотографии за последние три месяца с помощью изученных нами команд Bash. Перед началом работы обязательно сделайте их резервную копию. Разделите все фотографии по годам и месяцам. Структура каталогов должна получиться примерно следующая:

~/
  photo/
        2019/
             11/
             12/
        2020/
             01/
```

#### Права доступа

На иллюстрации 2-24 обратите внимание на команду `ls`, запущенную с параметром `-l`. Она выводит таблицу с подробной информацией о файлах и каталогах. Каждому из них соответствует одна строка таблицы. В первом её столбце указаны права доступа. Файл `report.txt` имеет права доступа `-r--r--r--`. Рассмотрим, что означает эта запись.

По опыту использования Проводника Windows вы, возможно, уже знакомы с концепцией прав доступа. У пользователя могут быть права на чтение, редактирование и запуск файла. У разных пользователей права могут отличаться. Это может быть полезно, если несколько человек использует один и тот же компьютер. Будет разумно, если они смогут читать и изменять только свои собственные документы.

В Unix информация о доступе хранится в [**битовой маске**](https://ru.wikipedia.org/wiki/Битовая_маска). Битовая маска - это обычное число. Если представить его в двоичной системе счисления, то получится последовательность нулей и единиц. Для хранения каждого из них в памяти требуется один бит. Главная особенность битовой маски заключается в её интерпретации.

Предположим, что у нас есть набор признаков. Каждый признак либо есть, либо его нет. Если признак есть, соответствующий ему бит равен 1, иначе 0. Например, если мы говорим о доступе к файлу, то признаки могут быть следующие:

1. Разрешение на чтение.
2. Разрешение на запись.
3. Разрешение на исполнени.

Набор этих признаков можно закодировать маской из трёх битов. Допустим, что к файлу есть полный доступ и его можно читать, писать и исполнять. Тогда маска выглядит как:
{line-numbers: false}
```
111
```
Если чтение и исполнение запрещёно, то первый и третий биты будут нулями:
{line-numbers: false}
```
010
```
Надеюсь, что вы уловили суть. Теперь вернёмся к правам доступа в Unix. Строка с правами доступа `-r--r--r--` есть ни что иное, как битовая маска. В ней нулям соответствует тире, а единицам какая-то буква. То есть строку `-r--r--r--` можно представить в виде маски 0100100100. Маске 1111111111 будет соответствовать строка `drwxrwxrwx`.

На самом деле маска прав доступа состоит из четырёх частей. Они приведены в таблице 2-6.

{caption: "Таблица 2-6. Значение позиций букв в строке прав доступа", width: "100%"}

| d | rwx | rwx | rwx |
| --- | --- | --- | --- |
| Признак каталога. | Права владельца файла или каталога. По умолчанию это тот, кто его создал. | Права группы пользователей, привязанной к файлу. По умолчанию это группа, к которой относится владелец. | Права всех остальных пользователей кроме владельца и группы, привязанной к файлу. |

Каждая из этих частей представляет собой отдельную маску. Минимальный размер числа, которым оперируют компьютеры, составляет 4 байта. Поэтому уже знакомая нам строка `-r--r--r--` на самом деле представляется маской 0000 0100 0100 0100.

Что означают буквы в строке прав доступа? Как мы выяснили, это равные единице биты. Позиция каждого из них определяет, какое действие над файлом или каталогом разрешено. Буквы были введены, чтобы упростить чтение битовой маски. Согласитесь, что понять строку `-rw-r--r--` проще и быстрее, чем двоичное число 0000011001000100. Значение каждого символа приведено в таблице 2-7.

{caption: "Таблица 2-7. Значение символов в строке прав доступа", width: "50%"}
| Символ | Значение для файла | Значение для каталога |
| --- | --- | --- |
| d | Если вместо d первым символом стоит тире, это права для файла. | Права доступа соответствуют каталогу.  |
| r | Чтение. | Вывод содержимого каталога. |
| w | Запись. | Создание, переименование или удаление файлов в каталоге . |
| x | Выполнение файла. | Переход в каталог, доступ к его файлам и подкаталогам. |
| - | Отсутствие права. | Отсутствие права. |

Когда к файлу имеют полный доступ все пользователи системы, строка прав выглядит как `-rwxrwxrwx`. Для каталога с такими же правами первый символ тире заменяется на d: `drwxrwxrwx`.

I> Чтобы вывести группы, к которым относится текущий пользователь воспользуйтесь командой group. Эта команда доступна только под Linux и macOS.

Теперь если мы вернёмся к иллюстрации 2-24, мы легко сможем прочитать права доступа к файлам `report.txt` и `report1.txt`. Первый могут читать все пользователи, но его изменение и исполнение запрещено. Второй файл могут читать все, а изменять только владелец. При этом его исполнение также запрещено.

Таблица 2-8 демонстрирует необходимые права доступа к файлу или каталогу, необходимые для выполнения рассмотренных нами команд.

{caption: "Таблица 2-8. Права доступа для команд", width: "100%"}
| Команда | Маска | Права доступа | Комментарий |
| --- | --- | --- | --- |
| `ls` | `r--` | Чтение | Только каталоги. |
| `cd` | `--x` | Выполнение | Только каталоги. |
| `mkdir` | `-wx` | Запись и выполнение. | Только каталоги. |
| `rm` | `-w-` | Запись | Для каталогов надо использовать параметр `-r`. |
| `cp` | `r--` | Чтение | Целевой каталог должен быть доступен на запись и исполнение. |
| `mv` | `r--` | Чтение | Целевой каталог должен быть доступен на запись и исполнение. |
| Исполнение | `r-x` | Чтение и выполнение. | Только для файлов. |

#### Запуск файлов

Для запуска файла в Bash достаточно, чтобы он имел только права на чтение и исполнение. В отличие от требований, принятых в ОС Windows, его расширение может быть произвольным. Он может называться например `report.txt`, но всё равно быть исполняемым.

I> В Unix нет общепринятого соглашения о расширении исполняемых бинарных  файлов. Поэтому чтобы узнать тип файла вам пригодится команда `file`. Примеры её использования:
{line-numbers: false}
```
file /usr/bin/ls
cd /bin
file ls
```

Мы уже знаем, что все GNU утилиты находятся в каталогах `/bin` и `/usr/bin`. Bash хранит их пути в переменной `PATH`. Может возникнуть вопрос: куда устанавливаются приложения в Linux окружении?

В Windows на системном диске есть каталоги `Program Files` и `Program Files (x86)`. По умолчанию все приложения устанавливаются туда. Для каждого приложения создаётся новый каталог (например, `C:\Program Files (x86)\Notepad++`). В процессе установки в него копируются исполняемые файлы, DLL библиотеки, файлы конфигурации и ресурсов. Всё это, а также системные библиотеки Windows необходимы для запуска и работы приложения. Вместо каталогов `Program Files` пользователь может указать любой другой путь установки (например, `D:\Games`).

В Linux окружении есть два общепринятых варианта установки приложения. Первый вариант немного напоминает подход Windows. Установка происходит в каталог `/opt`. В нём создаётся подкаталог (например, `/opt/teamviewer`), куда копируются все файлы приложения. Как правило, этот вариант установки используется проприетарными программами, исходный код которых закрыт.

Второй вариант применяется для приложений с открытым исходным кодом. Каждый тип файлов приложения копируется в соответствующий системный каталог. Список этих каталогов приведён в таблице 2-9.

{caption: "Таблица 2-9. Назначение системных каталогов", width: "70%"}
| Каталог | Назначение |
| --- | --- |
| `/bin` | Исполняемые файлы системных утилит. |
| `/etc` | Конфигурационные файлы. |
| `/lib` | Библиотеки, необходимые для работы системных утилит. |
| `/usr/bin` | Исполняемые файлы приложений пользователя. |
| `/usr/lib` | Библиотеки, необходимые для приложений пользователя. |
| `/usr/local` | Приложения, скомпилированные пользователем самостоятельно. |
| `/usr/share` | Архитектурно-независимые файлы ресурсов приложений пользователя. |
| `/var` | Файлы, создаваемые приложением в процессе работы (например лог-файлы). |

Может показаться, что копирование файлов приложения по нескольким системным каталогом приведёт к хаосу в файловой системе. На самом деле всё в точности наоборот. Благодаря тому, что все приложения следует соглашению о назначении каждого системного пути, оказывается намного проще организовать их взаимодействие. В Windows каждое приложение при установке копирует все необходимые ему библиотеки, кроме системных. Таким образом постепенно в файловой системе накапливаются десяткий копий одних и тех же библиотек. В Linux все приложения используют единственный экземпляр этой библиотеки. Это возможно потому, что она установлена по предопределённому системному пути и приложения знают, где её искать. В результате использование пространства жёсткого диска происходит намного эффективнее.

Предположим, что мы установили приложение (например, браузер). Согласно таблице 2-9 его исполняемый файл (например, `firefox`) будет скопирован в каталог `/usr/bin`. Как нам его запустить из Bash? Есть несколько способов:

1. По имени исполняемого файла.
2. По абсолютному пути.
3. По относительному пути.

Рассмотрим каждый способ подробнее.

Первый вариант нам хорошо знаком. Именно таким образом мы вывзывали GNU утилиты до сих пор. Например, запуск `find` из каталога `/usr/bin`:
{line-numbers: false}
```
find --help
```
Точно так же мы запустим и браузер:
{line-numbers: false}
```
firefox
```
Это работает, потому что путь `/usr/bin` хранится в переменной `PATH`. Получив команду `firefox`, Bash ищет исполняемый файл с соответствующим именем в каждом из путей в `PATH`.

I> Обратите внимание, что порядок поиска исполняемого файла соответствует порядку путей в переменной `PATH`. Предположим, что файл есть в обоих каталогах `/usr/local/bin` и `/usr/bin`. В то же время `/usr/local/bin` идёт первым в `PATH`. Тогда Bash всегда будет запускать файл из него.

Во втором способе запуска мы просто набираем абсолютный путь к исполняемому файлу:
{line-numbers: false}
```
/usr/bin/firefox
```
Как правило, этот способ применяется для запуска проприетарных приложений, установленных в каталог `/opt`. Этот каталог обычно не указывается в переменной `PATH`. Поэтому Bash не может самостоятельно найти каталог исполняемого файла.

Третий способ запуска файла покажется непривычным для Windows пользователей. Если вы перейдёте в каталог `/usr`, то запустить браузер можно командой:
{line-numbers: false}
```
bin/firefox
```
Это очевидно и не вызывает вопросов. Но предположим, что исполняемый файл `firefox` находится в каталоге `/opt/firefox/bin`. Перейдём в этот каталога командой `cd` и попробуем запустить браузер:
{line-numbers: false}
```
cd /opt/firefox/bin
firefox
```
Такой способ не сработает. Почему? Дело в том, что сейчас вы попытались запустить приложение по имени исполняемого файла. В этом случае, как мы уже знаем, Bash будет искать его в путях переменной `PATH`. Но приложение установлено в `/opt`, которого в `PATH` нет. Тогда Bash выдаст ошибку, что файл не найден.

Правильно указывать относительный путь с текущим каталогом:
{line-numbers: false}
```
./firefox
```
Тогда Bash поймёт, что искать исполняемый файл следует в текущем каталоге.

Рассмотрим, как добавить свой путь (например, `/opt/firefox/bin`) в переменную `PATH`. Для этого выполните следующией действия:

1. Перйдите в домашний каталог пользователя:
{line-numbers: false}
```
cd ~
```

2. Выведите соответствующий ему Windows путь (см. пример на иллюстрации 2-6):
{line-numbers: false}
```
pwd -W
```

3. В редакторе Notepad++ откройте файл `.bash_profile` из этого каталога.

4. Найдите следующий код на строке 23:
{number-from: "23"}
```
# Set PATH so it includes user's private bin if it exists
# if [ -d "${HOME}/bin" ] ; then
#   PATH="${HOME}/bin:${PATH}"
# fi
```
В начале строк 24, 25 и 26 удалите символ `#`, который означает закоментированный код. Также в строке 25 замените путь `${HOME}/bin` на нужный нам `/opt/firefox/bin`. После редактирования должно получиться следующее:
{number-from: "23"}
```
# Set PATH so it includes user's private bin if it exists
if [ -d "${HOME}/bin" ] ; then
    PATH="/opt/firefox/bin:${PATH}"
fi
```

Чтобы изменения вступили в силу, вам нужно перезапустить терминал MSYS2. Теперь если вы наберёте команду `firefox`, Bash найдёт соответствующий исполняемый файл по пути `/opt/firefox/bin` и запустит.

### Дополнительные возможности Bash

Мы рассмотрели основные возможности Bash и часто используемые команды для работы с файловой системой. Этого вполне достаточно для ежедневных задач вроде запуска программ и копирования файлов, которые сегодня принято выполнять в графическом интерфейсе. Однако, весь потенциал масштабируемости GNU утилит раскрывается благодаря дополнительным возможностям Bash. К ним относятся:

1. Перенаправление ввода-вывода.
2. Конвейеры.
3. Коннекторы.
4. alias.

Расмотрим подробнее каждую из них.

#### Перенаправление ввода-вывода

Все GNU утилиты строятся вокруг текстовых данных. Они получают их на вход в виде строк или файлов. Результат их работы также чаще всего выводится на экран в текстовом виде. Имея универсальный формат данных, очень удобно комбинировать утилиты друг с другом. Таким образом из ограниченного набора узкоспециализированных инструментов можно составлять решения для достаточно сложных задач.

При сочетании GNU утилит возникает проблема. Как передавать выход одной программы на вход другой? У этой задачи есть несколько решений. Если речь идёт об одной строке, можно использовать буфер обмена. Просто выделите мышью вывод команды, затем наберите следующую команду и вставьте содержимое из буфера обмена. Этот метод перестаёт работать, когда надо скопировать несколько строк. При вставке Bash будет интерпретировать первый встретившийся символ перевод строки как нажатие Enter и начнёт исполнять команду, игнорируя оставшиеся строки.

Другое решение заключается в использоании файловой системы. Её можно использовать для временного хранения данных. Это намного удобнее буфера обмена. Во-первых снимается ограничение на количество строк. Во-вторых не требуются ручные операции копирования в буфер. Рассмотрим пример. Предположим, что нам для отчёта нужно сохранить список файлов, найденных командой `find`. Для этого воспользуемся командой `1>`:
{line-numbers: false}
```
find / -path */doc/* -name README 1> readme_list.txt
```

В результате выполнения этой команды на жёстком диске будет создан файл `readme_list.txt`. В него будет записан весь вывод команды `find`. Формат вывода точно такой же, как если бы он печатался на экран. Обратите внимание, что если файл с именем `readme_list.txt` уже существует в текущем каталоге, его содержимое будет удалено и перезаписано выводом `find`.

Что означает команда `1>`? Это [перенаправление стандартного потока вывода](https://ru.wikipedia.org/wiki/Перенаправление_ввода-вывода). В Unix окружении есть три стандартных потока. Они приведены в таблице 2-10.

{caption: "Таблица 2-10. Стандартные потоки POSIX", width: "100%"}
| Номер | Название | Применение |
| --- | --- | --- |
| 0 | Стандартный поток ввода (standard input или stdin). | Данные, которые передаются на вход программы. Обычно они поступают с устройства ввода типа клавиатуры. |
| 1 | Стандартный поток вывода (standard output или stdout). | Данные, которые выводит программа. Обычно они печатаются в окне терминала. |
| 2 | Стандартный поток ошибок (standard error или stderr). | Данные об ошибках, которые выводит программа. Как правило, они выводятся так же в окне терминала. |

Если с потоками ввода и вывода всё ясно, то поток ошибок вызывает вопросы. Зачем он нужен, если есть stdout? На самом деле он даёт возможность разделять сообщения об ошибках от вывода результата работы программы. Представьте, что вы вызываете команду `find` для поиска файлов. К некоторым каталогам файловой системы у вас нет доступа. О каждой попытке доступа к ним будет вывведено сообщение об ошибке. Но эти сообщения потеряются в списке найденных файлов. Отдельный поток ошибок позволит вам прочитать только эти сообщения.

Чтобы перенаправить стандартный поток ошибок, воспользуйтесь командой `2>`:
{line-numbers: false}
```
find / -path */doc/* -name README 2> errors.txt
```

Как вы возможно уже догадались, цифра перед знаком больше означает номер потока.

Для перенаправления стандартного потока ввода, используется команда `0<`:
{line-numbers: false}
```
grep "Bash" 0< README.txt
```

Команды перенаправления стандартных потоков вывода и ввода используются настолько часто, что для них ввели сокращённую форму: `>` и `<` соответственно. Применим её для рассмотренных ранее команд:
{line-numbers: false}
```
find / -path */doc/* -name README > readme_list.txt
grep "Bash" < README.txt
```

Когда вы перенаправляете стандартный поток вывода, может возникнуть необходимость сохранить текущее содержимое файла и дописать новые данные в его конец Представьте, что у вас есть жёсткий диск с большим числом лог файлов. Они хранятся в катологах, соответствующих году и месяцу их создания. Нам требуется найти файлы с определённым именем только за 2018 и 2019 годы. Поиск на всём жёстком диске займет много времени. Поэтому логичнее будет запустить две команды `find` только в интересующих нас каталогах. 

Предположим, что нас интересуют логи с расширением `log`. Они хранятся  в каталоге `/var/log`. Тогда команды поиска будут выглядеть следующим образом:
{line-numbers: false}
```
find /var/log/2019 -name "*.log" > result.txt
find /var/log/2018 -name "*.log" > result.txt
```

Мы знаем, что перенаправление командой `>` приведёт к перезаписи содержимого файла `result.txt`. Чтобы этого не произошло, воспользуемся командой `>>`:
{line-numbers: false}
```
find /var/log/2019 -name "*.log" > result.txt
find /var/log/2018 -name "*.log" >> result.txt
```

В результате первый вызов `find` создаст новый файл или очистит уже существующий и запишет в него свой результат. Второй вызов допишет свои данные в конец `result.txt`. Если указанного файла не существует, команда `>>` его создаст.

Полная форма команды перенаправления стандартного вывода с запаисью в конец файла выглядит как `1>>`. Точно так же можно перенаправить и поток ошибок: `2>>`. Если вам нужно перенаправить оба этих потока в один файл, воспользуйтесь командой `&>` или `&>>`:
{line-numbers: false}
```
find / -path */doc/* -name README &> result_and_errors.txt
```

Если потоки вывода и ошибок надо записать в разные файлы, вы можете указать команды перенаправления одну за другой через пробел:
{line-numbers: false}
```
find / -path */doc/* -name README > result.txt 2> errors.txt
```

#### Конвейеры

Перенаправлять вывод одной команды на вход дургой можно и без создания временных файлов на жёстком диске. Для этого есть специальный механизм взаимодействия приложений под названием [**конвейер**](https://ru.wikipedia.org/wiki/Конвейер_(Unix)) (pipeline). Рассмотрим его использование на примере.

Предположим, что вам надо найти в документации по Bash информацию о лицензии. Вы можете выполнить команду `grep` над файлами с документацией из каталога `/usr/share/doc/bash`. Другой способ заключается в том, чтобы получить справку командой `info` и выполнить `grep` над её выводом. Для этого выполним следующее:
{line-numbers: false}
```
info bash | grep -n "GNU"
```

Команда `info` выводит справку по Bash на стандартный поток вывода. Следующий далее символ `|` означает, что вывод команды слева передаётся на вход программы справа. Таким образом `grep` получит текст справки и выведет все вхождения строки "GNU". Параметр `-n` добавляет в вывод `grep` номера строк для удобства.

Ещё один пример. Конвейеры часто используются для анализа вывода команды `ls`. Если вам надо получить имена файлов в указанном каталоге, в которых встречается некоторое слово, вы можете воспользоваться командой `find`. Но вместо этого можно сочетать команды `ls` и `grep`. Результат получится короче и удобнее для чтения:
{line-numbers: false}
```
ls /usr/share/doc/bash | grep html
```

С помощью конвейеров можно объединять более двух команд. К предыдущему примеру можно добавить сортировку найденных HTML файлов по имени с помощью утилиты `sort`:
{line-numbers: false}
```
ls /usr/share/doc/bash | grep html | sort
```

Конвейеры можно сочетать с перенаправлением потоков:
{line-numbers: false}
```
ls /usr/share/doc/bash | grep html | sort > result.txt
```

В результате этой команды отсортированный список HTML файлов из каталога `/usr/share/doc/bash` будет записан в `result.txt`.

В случае сочетания конвейеров и перенаправления потоков возникает одна проблема. Что делать, если необходимо одновременно направить вывод команды в файл и на вход другой программы? Синтаксис Bash не имеет встроенного средства, которое бы позволяло такое поведение. На помощь приходит утилита под названием `tee`. Рассмотрим пример:
{line-numbers: false}
```
ls /usr/share/doc/bash | tee result.txt
```

Если вы запустите эту команду, то увидите вывод `ls` на экране. При этом он же будет записан в файл `result.txt`, который будет создан в текущем каталоге. Параметр `-a` команды `tee` позволит вам дописывать в конец уже существующего файла, а не очищать его.

Утилита `tee` позволяет сохранять в файл не только конечный результат команды, но и промежуточные:
{line-numbers: false}
```
ls /usr/share/doc/bash | tee ls.txt | grep html | tee grep.txt | sort > result.txt
```

В результате выполнения этой команды, вывод `ls` будет сохранён в файле `ls.txt`, а `grep` - в `grep.txt`. Конечный результат по прежнему окажется в `result.txt`.

Мы уже знаем, как с помощью параметра `-exec` команды `find` указатать действие над каждым найденным файлом. Возможно ли сделать подобное с помощью конвейеров?

Утилита `find` имеет встроенный небольшой интерпретатор. Он позволяет запускать внешние утилиты для выполнения указанных действий. Благодаря такой возможности, `find` свободно может вызывать программу `cp` и передавать в неё найденные файлы один за другим.

Если мы говорим об интерпретаторе Bash, ситуация меняется. Предположим, что мы запускаем утилиту `ls` и фильтруем её вывод с помощью `grep`. Bash не имеет доступа к промежуточным результатам работы каждой из команд. Он получает конечный результат целиком в стандартном потоке вывода. Если вы хотите скопировать файлы, имена которых отфильтровал `grep`, просто конвейер не подойдёт:
{line-numbers: false}
```
ls /usr/share/doc/bash/* | grep html | cp -t ~
```

Такой вызов завершится ошибкой от утилиты `cp`, потмоу что она не читает стандартный поток ввода, а ожидает имя копируемого файла в первом параметре. Наша задача заключается в том, чтобы сконструировать строку параметров из данных со стандартного потока ввода. Утилита `xargs` делает именно то, что нам нужно:
{line-numbers: false}
```
ls /usr/share/doc/bash/* | grep html | xargs cp -t ~
```

I> Обратите внимание на маску `/usr/share/doc/bash/*`, переданную на вход `ls`. Благодаря ей, утилита выведет абсолютные пути для каждого файла. Они нужны для команды `cp`. Альтернативным решением может быть предварительный переход в каталог `/usr/share/doc/bash`. Тогда команду копирования можно упростить:
{line-numbers: false}
```
cd /usr/share/doc/bash
ls | grep html | xargs cp -t ~
```

В этом вызове стандартный поток вывода команды `grep` передаётся на вход `xargs`. Далее `xargs` вызывает команду `cp` с параметром `-t ~`. Он означает копирование в указанный каталог. После этого `xargs` подставляет каждый файл из вывода `grep` в качестве параметра командной строки. Если в вывод `grep` попало только два HTML файла `bash.html` и `bashref.html`, тогда `xargs` подставит их в конец вызова `cp`. Он будет выглядеть следующим образом:
{line-numbers: false}
```
cp -t /home/ilya.shpigor /usr/share/doc/bash/bash.html /usr/share/doc/bash/bashref.html
```

Такая подстановка происходит в памяти утилиты `xargs` и по умолчанию не выводится на экран. Вы можете включить функцию вывода сформированной команды с помощью параметра `-t`:
{line-numbers: false}
```
ls /usr/share/doc/bash/* | grep html | xargs -t cp -t ~
```

I> Способность представлять в уме то, что будет делать написанная вами программа - это важнейший навык программиста. Конечно, всегда можно запустить и проверить, но умение прокручивать исполнение кода в уме значительно ускоряет проектирование, разработку и поиск ошибок.

Может возникнуть ситуация, когда стандартный поток ввода содержит слишком много данных. У команд типа `rm` и `cp` есть ограничение на число входных параметров. Утилита `xargs` позволяет разделить свои входные данные на части и вызывать указанную команду для каждой из них. Для такого разделения используется параметр `-l` с указанием числа строк:
{line-numbers: false}
```
ls /usr/share/doc/bash/* | grep html | xargs -l2 cp -t ~
```

В результате для каждых двух файлов из вывода `ls` будет вызываться своя команда `cp`.

По умолчанию утилита `xargs` добавляет параметры, сконвертированные из стандартного потока ввода, в конец указанной команды. Могут быть ситуации, когда требуется указать место их подстановки. В этом случае можно воспользоваться параметром `-I`:
{line-numbers: false}
```
ls /usr/share/doc/bash/* | grep html | xargs -I% cp % ~
```

Параметр `-I%` сообщает утилите `xargs`, что подстановку надо совершить в место символа `%` в следующем далее вызове. При этом команда `cp` будет вызвана для каждой строки, переданной на ввод утилите `xargs`. В нашем случае сформируются следующие команды:
{line-numbers: false}
```
cp /usr/share/doc/bash/bash.html /home/ilya.shpigor
cp /usr/share/doc/bash/bashref.html /home/ilya.shpigor
```

Есть ряд GNU утилит, которые работают со стандартным потоком вывода. Обычно именно их применяют вместе с конвейерами. Таблица 2-11 приводит наиболее часто используемые из них.

{caption: "Таблица 2-11. GNU утилиты для обработки стандартного потока ввода", width: "100%"}
| Утилита | Описание | Примеры |
| --- | --- | --- |
| `xargs` | Формирование параметров команды по тексту из стандартного потока ввода. | `ls | xargs cp -t ~`  |
| `grep` | Поиск по указанному шаблону. | `ls | grep txt` |
| | `info ls | grep -A 3 -B 3 GNU` |
| `tee` | Перенаправление потока ввода одновременно в поток вывода и в файл. | `ls | tee result.txt` |
| `sort` | Сортировка строк в потоке ввода в прямом и обратном (параметр `-r`) порядке. |  `ls | sort` |
| | | `ls | sort -r` |
| `wc` | Подсчёт строк (параметр `-l`), слов (`-w`), букв (`-m`) и байтов (`-с`) в указанном файле или потоке ввода. | `ls | wc -l` |
| | | `info ls | wc -m` |
| `tail` | Вывести указанное число байтов (параметр `-c`) или строк (`-n`) файла или текста из потока ввода. | `info ls | tail -n 10` |
| `less` | Утилита для навигации по тексту из стандартного потока ввода. Для выхода из неё нажмите клаившу Q. | `cat /usr/share/doc/bash/README | less` |

{caption: "Упражнение 2-7. Использование конвейеров и перенаправления потоков ввода-вывода", format: text, line-numbers: false}
```
Напишите команду для архивирования ваших фотографий с помощью утилиты bsdtar (или tar для Linux пользователей). Предположим, что фотографии находятся в структуре каталогов, которую мы получили в упражнении 2-6:

~/
  photo/
        2019/
             11/
             12/
        2020/
             01/

Фотографии из одного и того же месяца должны попасть в один архив. После выполнения команды должно получиться следующее:

~/
  photo/
        2019/
             11.tar
             12.tar
        2020/
             01.tar
```

#### Коннекторы

#### alias

### Пакетный менеджер
## Дополнительные возможности Bash

Мы рассмотрели часто используемые встроенные команды Bash и GNU утилиты для работы с файловой системой. Этого вполне достаточно для ежедневных задач вроде запуска программ и копирования файлов, которые сегодня принято выполнять в графическом интерфейсе. Однако, весь потенциал масштабируемости GNU утилит раскрывается благодаря дополнительным возможностям Bash. Эти возможности следующие:

1. Перенаправление ввода-вывода.
2. Конвейеры.
3. Логические операторы.

Рассмотрим подробнее каждый из этих механизмов.

### Перенаправление ввода-вывода

Все GNU утилиты строятся вокруг текстовых данных. Они получают эти данные на вход в виде строк или файлов. Результат работы утилит также чаще всего выводится на экран в текстовом виде. Имея универсальный формат данных, очень удобно комбинировать утилиты друг с другом. Таким образом из ограниченного набора узкоспециализированных инструментов можно составлять решения для широкого круга сложных задач.

Однако, при сочетании GNU утилит возникает проблема. Как передавать выход одной программы на вход другой? У этой задачи есть несколько решений. Если речь идёт об одной строке, можно использовать буфер обмена. Просто выделите мышью вывод утилиты, затем наберите следующую команду и в качестве параметров вставьте содержимое из буфера обмена. Этот метод перестаёт работать, когда надо скопировать несколько строк. При вставке Bash будет интерпретировать первый встретившийся разделитель строки как нажатие Enter и начнёт исполнять команду. Таким образом часть копируемых данных будет потеряна.

Другое решение заключается в использовании файловой системы. Файлы можно использовать для временного хранения данных и передачи их между утилитами. Это намного удобнее буфера обмена. Во-первых, снимается ограничение на количество строк. Во-вторых, не требуются ручные операции копирования в буфер.

Рассмотрим пример. Предположим, что нам для отчёта нужно сохранить список файлов, найденных командой `find`. Для этого воспользуемся оператором перенаправления `1>`:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README 1> readme_list.txt
```

В результате выполнения этой команды на жёстком диске будет создан файл `readme_list.txt`. В него будет записан весь вывод утилиты `find`. Формат вывода точно такой же, как если бы он печатался на экран. Обратите внимание, что если файл с именем `readme_list.txt` уже существует в текущем каталоге, его содержимое будет удалено и перезаписано выводом `find`.

Что означает оператор `1>`? Это [перенаправление стандартного потока вывода](https://ru.wikipedia.org/wiki/Перенаправление_ввода-вывода). В Unix-окружении есть три [стандартных потока](https://ru.wikipedia.org/wiki/Стандартные_потоки). Они приведены в таблице 2-11.

{caption: "Таблица 2-11. Стандартные потоки POSIX", width: "100%"}
| Номер | Название | Применение |
| --- | --- | --- |
| 0 | Стандартный поток ввода (standard input или stdin). | Данные, которые передаются на вход программы. Обычно они поступают с устройства ввода типа клавиатуры. |
|  | | |
| 1 | Стандартный поток вывода (standard output или stdout). | Данные, которые выводит программа. Обычно они печатаются в окне терминала. |
|  | | |
| 2 | Стандартный поток ошибок (standard error или stderr). | Данные об ошибках, которые выводит программа. Как правило, они выводятся так же в окне терминала. |

Поток представляет собой программный канал передачи данных между приложением и окружением, в котором оно запущено. В ранних Unix-системах ввод и вывод информации происходил через физические каналы. Ввод был привязан к клавиатуре, а вывод к монитору. Потоки были введены как [абстракция](https://ru.wikipedia.org/wiki/Уровень_абстракции_(программирование)) над этими каналами. Благодаря ей, стало возможно заменять ввод с реального устройства на ввод из файла на жёстком диске и аналогично поступать с выводом.

Если с потоками ввода и вывода всё ясно, то поток ошибок вызывает вопросы. Зачем он нужен, если есть stdout? На самом деле он даёт возможность разделять сообщения об ошибках от вывода результата работы программы. Представьте, что вы вызываете утилиту `find` для поиска файлов. К некоторым каталогам файловой системы у вас нет доступа. О каждой попытке несанкционированного доступа будет выведено сообщение об ошибке. Но эти сообщения потеряются в списке найденных файлов. Их будет намного проще прочитать в отдельном выводе.

Чтобы перенаправить стандартный поток ошибок, воспользуйтесь оператором перенаправления `2>`:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README 2> errors.txt
```

Как вы возможно уже догадались, цифра перед знаком больше означает номер потока. Для перенаправления стандартного потока ввода, используется оператор `0<`. Рассмотрим простой, но не совсем правильный пример поиска шаблона в файле:
{line-numbers: false, format: Bash}
```
grep "Bash" 0< README.txt
```

В этой команде мы используем интерфейс утилиты `grep` для обработки стандартного потока ввода. Лучше в `grep` всегда передавать имя файла:
{line-numbers: false, format: Bash}
```
grep "Bash" README.txt
```

В качестве более сложного примера рассмотрим способ вывода содержимого файла на экран, рекомендуемый в некоторых руководствах по Bash. Он выглядит следующим образом:
{line-numbers: false, format: Bash}
```
echo $( 0< README.txt )
```

Здесь используется встроенная команда интерпретатора `echo`. Ей на вход передаётся результат выполнения команды `0< README.txt`, то есть содержимое файла `README.txt`. В этом примере выполняется **подстановка команд**. Она заключается в том, что интерпретатор встретив символы `$(` и `)` выполняет заключенную между ними команду и подставляет её вывод.

Команды перенаправления стандартных потоков вывода и ввода используются настолько часто, что для них ввели сокращённую форму: `>` и `<` соответственно. Применим её для рассмотренных ранее примеров:
{line-numbers: true, format: Bash}
```
find / -path */doc/* -name README > readme_list.txt
echo $( < README.txt )
```

Когда вы перенаправляете стандартный поток вывода, может возникнуть необходимость сохранить текущее содержимое файла и дописать новые данные в его конец.

Обратимся к примеру. Представьте, что у вас есть жёсткий диск с большим числом лог-файлов. Они хранятся в каталогах, соответствующих году и месяцу их создания. Вам требуется найти файлы с определённым именем только за 2018 и 2019 годы. Поиск на всём жёстком диске займет много времени. Поэтому логичнее будет запустить две команды `find` только в интересующих нас каталогах. 

Предположим, что нас интересуют только файлы с расширением `log`. Они хранятся в каталоге `/var/log`. Тогда команды поиска будут выглядеть следующим образом:
{line-numbers: true, format: Bash}
```
find /var/log/2019 -name "*.log" > result.txt
find /var/log/2018 -name "*.log" > result.txt
```

Мы знаем, что перенаправление оператором `>` приведёт к перезаписи содержимого файла `result.txt`. Чтобы этого не произошло, воспользуемся оператором `>>`:
{line-numbers: true, format: Bash}
```
find /var/log/2019 -name "*.log" > result.txt
find /var/log/2018 -name "*.log" >> result.txt
```

В результате первый вызов `find` создаст новый файл или очистит уже существующий и запишет в него свой результат. Второй вызов допишет свои данные в конец `result.txt`. Если указанного файла не существует, оператор `>>` его создаст.

Полная форма оператора перенаправления стандартного потока вывода с записью в конец файла выглядит как `1>>`. Аналогично можно перенаправить и поток ошибок: `2>>`. Если вам нужно перенаправить оба потока в один файл, воспользуйтесь оператором `&>` или `&>>`:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README &> result_and_errors.txt
```

Такое перенаправление работает только в Bash, но не в Bourne shell. Если вам важна POSIX-совместимость, перенаправляйте поток ошибок в поток вывода с помощью команды `2>&1`:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README > result_and_errors.txt 2>&1
```

Такое перенаправление называется **дублированием** (duplicating). Оно используется, когда оба потока должны быть записаны в файл или переданы другой команде через конвейер.

Обратите внимание на важный момент. В результате следующей команды поток ошибок всё равно будет выводиться на экран:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README 2>&1 > result_and_errors.txt
```

Почему это происходит? Ведь мы перенаправили stderr в stdout. Не всё так просто. Дело в том, что для удобства работы с потоками стандарт POSIX вводит понятие [**файлового дескриптора**](https://ru.wikipedia.org/wiki/Файловый_дескриптор). Дескриптор представляет собой абстрактный указатель на файл или канал коммуникации (в нашем случае поток). При запуске программы дескрипторы потоков вывода и ошибок указывают на окно терминала. Перенаправляя эти потоки, мы переназначаем их дескрипторы на реальные файлы, хранящиеся на жёстком диске или в оперативной памяти. Подробнее этот механизм описан в [статье BashGuide](http://mywiki.wooledge.org/BashFAQ/055).

Теперь вернёмся к нашей команде и рассмотрим происходящие в ней перенаправления в порядке их исполнения слева направо:

1. `2>&1`
Теперь стандартный поток ошибок указывает на то же, на что и поток вывода (в данном случае на окно терминала).

2. `> result_and_errors.txt`
Теперь стандартный поток вывода указывает на файл `result_and_errors.txt`. При этом поток ошибок по-прежнему связан с окном терминала.

Чтобы наша команда перенаправляла оба потока в файл, её надо исправить следующим образом:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README > result_and_errors.txt 2>&1
```

Сначала мы связываем стандартный поток вывода с файлом, а затем перенаправляем в него же поток ошибок.

Если потоки вывода и ошибок надо записать в разные файлы, вы можете указать операторы перенаправления один за другим через пробел:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README > result.txt 2> errors.txt
```

### Конвейеры

Перенаправлять вывод одной утилиты на вход другой можно и без создания временных файлов на жёстком диске. Для этого есть специальный механизм взаимодействия процессов под названием [**конвейер**](https://ru.wikipedia.org/wiki/Конвейер_(Unix)) (pipeline). Рассмотрим его использование на примере.

Предположим, что вам надо найти в документации по Bash информацию о лицензии. Вы можете найти её с помощью утилиты `grep`, запущенной в каталоге `/usr/share/doc/bash`. Другой способ заключается в том, чтобы получить справку утилитой `info` и обработать её вывод в `grep`. Для этого выполним следующее:
{line-numbers: false, format: Bash}
```
info bash | grep -n "GNU"
```

Утилита `info` выводит справку по Bash на стандартный поток вывода. Следующий далее символ `|` означает, что вывод команды слева от него передаётся на вход программы справа. Таким образом `grep` получит текст справки и выведет все вхождения строки "GNU". Параметр `-n` добавляет в вывод `grep` номера строк для удобства.

#### du

Рассмотрим ещё один пример использования конвейеров. GNU утилита `du` выводит статистику по использованию дискового пространства файлами и каталогами. Если вы запустите утилиту без параметров в текущем каталоге, она рекурсивно обойдёт все подкаталоги и выведет число байт, занимаемым на диске каждым из них.

Утилита принимает на вход список путей до каталогов, которые необходимо рекурсивно обойти. Также ей можно передать список путей до файлов. Тогда она выведет статистику только по ним.

Попробуйте выполнить `du` для системного каталога `/usr/share` следующим образом:
{line-numbers: false, format: Bash}
```
du /usr/share
```

Вот сокращенный пример вывода:
{line-numbers: true, format: Bash}
```
261     /usr/share/aclocal
58      /usr/share/awk
3623    /usr/share/bash-completion/completions
5       /usr/share/bash-completion/helpers
3700    /usr/share/bash-completion
2       /usr/share/cmake/bash-completion
2       /usr/share/cmake
8       /usr/share/cygwin
1692    /usr/share/doc/bash
85      /usr/share/doc/flex
...
```

Мы получили таблицу, состоящую из двух столбцов. В правом указан подкаталог, а в левом — число байтов, занимаемое им на диске. К этому выводу вы можете добавить файлы в подкаталогах. Для этого воспользуйтесь опцией утилиты `-a`. Получим следующую команду:
{line-numbers: false, format: Bash}
```
du /usr/share -a
```

Опция `-h` сделает вывод размера файлов и каталогов более удобным для чтения. Вместо количества байтов, вы получите значения в килобайтах, мегабайтах и гигабайтах.

Предположим, что нас интересует размер всех файлов в подкаталогах `/usr/share`, имеющих расширение `.html`. Эту информацию можно получить с помощью следующей команды:
{line-numbers: false, format: Bash}
```
du /usr/share -a -h | grep "\.html"
```

Весь вывод утилиты `du` передаётся на вход `grep` через конвейер. Получив данные на стандартный поток ввода, `grep` отфильтрует их согласно шаблону.

Почему в нашем шаблоне пришлось экранировать точку? Дело в том, что точка означает однократное вхождение любого символа. Если вы примените шаблон `".html"`, в вывод утилиты `grep` попадут также файлы (например, `pod2html.1perl.gz`) и подкаталоги (как `/usr/share/doc/pcre/html`). Правильный шаблон с экранированием позволит избежать этой ошибки.

С помощью конвейеров можно объединять более двух команд. Например, воспользовавшись утилитой `sort` с опциями `-r` и `-n` мы можем отсортировать найденные файлы по убыванию их размера. Команда для этого выглядит так:
{line-numbers: false, format: Bash}
```
du /usr/share -a | grep "\.html" | sort -n -r
```

Опция `-r` утилиты `sort` означает сортировку в обратном порядке. Опция `-n` включает режим сортировки чисел. В противном случае `sort` выполняет [**лексикографическую сортировку**]((https://ru.wikipedia.org/wiki/Лексикографический_порядок)) строк. Именно потому что мы сортируем числа, в этой команде утилита `du` вызывается без опции `-h`. Нам важно получить числа в байтах без сокращений. Иначе при сортировке возникнут ошибки. Например, размер в 1M (один мегабайт) окажется меньше чем 100K (сто килобайт).

Конвейеры можно сочетать с перенаправлением потоков. Если нам нужно сохранить отсортированный вывод утилиты `du` в файл для дальнейшего анализа, можно выполнить следующую команду:
{line-numbers: false, format: Bash}
```
du /usr/share -a | grep "\.html" | sort -n -r > result.txt
```

В результате этой команды весь вывод утилиты `sort` будет записан в файл с именем `result.txt`.

В случае сочетания конвейеров и перенаправления потоков возникает одна проблема. Что делать, если необходимо одновременно направить вывод команды в файл и на вход другой программы? Синтаксис Bash не имеет встроенного средства, которое бы позволяло такое поведение. На помощь приходит утилита под названием `tee`. Рассмотрим следующий пример:
{line-numbers: false, format: Bash}
```
du /usr/share -a -h | tee result.txt
```

Если вы запустите эту команду, то увидите вывод `du` на экране. При этом он же будет записан в файл `result.txt`. Опция `-a` утилиты `tee` позволит вам дописывать в конец уже существующего файла, а не очищать его. Это может быть полезно для накопления нескольких результатов запуска утилиты `du`.

С помощью утилиты `tee` можно сохранить в файл промежуточный результат выполнения команды. Для этого вызовите её между конвейерами. Например:
{line-numbers: false, format: Bash}
```
du /usr/share -a | tee du.txt | grep "\.html" | tee grep.txt | sort -n -r > result.txt
```

В результате выполнения этой команды, вывод утилиты `du` будет сохранён в файле `du.txt`, а `grep` — в `grep.txt`. Конечный результат по-прежнему окажется в `result.txt`. Такой раздельный вывод может помочь в поиске ошибок.

#### xargs

Мы уже знаем, как с помощью параметра `-exec` команды `find` выполнить действие над каждым найденным файлом. В некоторых случаях может понадобиться передать найденные файлы через конвейер другой утилите, которая в свою очередь их обработает.

Утилита `find` имеет встроенный небольшой интерпретатор. С помощью опции `-exec` он позволяет запускать внешние утилиты для выполнения указанных действий. Благодаря такой возможности, `find`, например, может вызывать программу `cp` и передавать в неё найденные файлы один за другим.

Когда вывод `find` перенаправляется через конвейер другой утилите или команде, вместо отдельных имён файлов мы получаем текст в стандартном потоке ввода. Например, выполните следующую команду:
{line-numbers: false, format: Bash}
```
find ~ -type f | grep "bash"
```

Вы получите вывод наподобие следующего:
{line-numbers: true, format: Bash}
```
/home/ilya.shpigor/.bashrc
/home/ilya.shpigor/.bash_history
/home/ilya.shpigor/.bash_logout
/home/ilya.shpigor/.bash_profile
```

В данном случае вывод `find` был передан на стандартный поток ввода утилите `grep`. В результате `grep` просто отфильтровала текст и вывела только имена файлов, в которых встречается шаблон `"bash"`.

Вопрос — как сделать так, чтобы `grep` обработала переданные ей данные не как обычный текст, а как имена файлов? Другими словами, как выполнить поиск шаблона не по именам файлов, а по их содержимому? Для решения этой задачи нам нужно сконструировать строку параметров из данных, полученных на стандартном потоке ввода. Утилита `xargs` служит именно для этой цели. Просто добавим её вызов в нашу команду следующим образом:
{line-numbers: false, format: Bash}
```
find ~ -type f | xargs grep "bash"
```

I> Эта команда не сможет корректно обработать файлы, имена которых содержат пробелы и символы перевода строки. Решение этой проблемы рассматривается в следующем разделе.

Вывод этой команды выглядит следующим образом:
{line-numbers: true, format: Bash}
```
/home/ilya.shpigor/.bashrc:# ~/.bashrc: executed by bash(1) for interactive shells.
/home/ilya.shpigor/.bashrc:# The copy in your home directory (~/.bashrc) is yours, please
/home/ilya.shpigor/.bashrc:# User dependent .bashrc file
/home/ilya.shpigor/.bashrc:# See man bash for more options...
/home/ilya.shpigor/.bashrc:# Make bash append rather than overwrite the history on disk
/home/ilya.shpigor/.bashrc:# When changing directory small typos can be ignored by bash
...
```

Теперь утилита `grep` получает на вход имена файлов в качестве параметров и, соответственно, ищет шаблон в их содержимом.

По умолчанию утилита `xargs` добавляет параметры, сконвертированные из стандартного потока ввода, в конец формируемой ей команды. Могут быть ситуации, когда требуется явно указать место их подстановки. В этом случае можно воспользоваться параметром `-I`.

Предположим, что нам надо скопировать все файлы найденные утилитой `find` в домашний каталог пользователя. Тогда вы можете выполнить следующую команду:
{line-numbers: false, format: Bash}
```
find /usr/share/doc/bash -type f -name "*.html" | xargs -I% cp % ~
```

Опция `-I%` сообщает утилите `xargs`, что подстановку надо совершить вместо символа `%` в следующем далее вызове. При этом утилита `cp` будет вызвана для каждой строки, переданной на стандартный поток ввода `xargs` через конвейер. В нашем случае `xargs` сконструирует следующие команды:
{line-numbers: true, format: Bash}
```
cp /usr/share/doc/bash/bash.html /home/ilya.shpigor
cp /usr/share/doc/bash/bashref.html /home/ilya.shpigor
```

С помощью опции `-t` утилиты `xargs` вы можете включить вывод на экран сконструированных ею команд перед их исполнением. Например так:
{line-numbers: false, format: Bash}
```
find /usr/share/doc/bash -type f -name "*.html" | xargs -t -I% cp % ~
```

Рассмотренные нами примеры использования утилиты `find` с конвейерами приведены исключительно в образовательных целях. Во всех подобных случаях предпочитайте обрабатывать найденные файлы с помощью опции `-exec`. Тогда вы сможете избежать ошибок обработки файлов, содержащих пробелы и перевод строки.

Один из немногих случаев, когда вам на самом деле может понадобиться передача вывода `find` через конвейер утилите `xargs` — это параллельная обработка каждого файла.

Рассмотрим пример. При вызове утилиты `cp` через опцию `-exec` файлы копируются по очереди друг за другом. Это неэффективно, если ваш жёсткий диск имеет высокую скорость доступа. Вы можете ускорить копирование файлов, если запустите его одновременное выполнение в нескольких процессах. Максимальное количество параллельно работающих процессов можно указать с помощью опции `-P` утилиты `xargs`.

Предположим, что процессор вашего компьютера имеет четыре ядра. Тогда можно переписать команду копирования следующим образом:
{line-numbers: false, format: Bash}
```
find /usr/share/doc/bash -type f -name "*.html" | xargs -P 4 -I% cp % ~
```

В результате выполнения этой команды для каждого файла, найденного `find`, будет запускаться отдельный процесс, в котором утилита `cp` выполнит его копирование. В зависимости от конфигурации вашего процессора и жёсткого диска это может значительно ускорить выполнение команды.

Есть ряд GNU утилит, которые получают входные данные из стандартного потока ввода. Обычно они применяются вместе с конвейерами для поиска и анализа текста. Таблица 2-12 приводит наиболее часто используемые из них.

{caption: "Таблица 2-12. GNU утилиты для обработки стандартного потока ввода", width: "100%"}
| Утилита | Описание | Примеры |
| --- | --- | --- |
| `xargs` | Формирование параметров команды по тексту из стандартного потока ввода. | `find . -type f -print0 | xargs -0 cp -t ~` |
|  | | |
| `grep` | Поиск по указанному шаблону. | `grep -A 3 -B 3 "GNU" file.txt` |
| | | `du /usr/share -a | grep "\.html"` |
|  | | |
| `tee` | Перенаправление потока ввода одновременно в поток вывода и в файл. | `grep "GNU" file.txt | tee result.txt` |
|  | | |
| `sort` | Сортировка строк в потоке ввода в | `sort file.txt` |
| | прямом и обратном (параметр `-r`) порядке. | `du /usr/share | sort -n -r` |
|  | | |
| `wc` | Подсчёт строк (параметр `-l`), слов (`-w`), | `wc -l file.txt` |
| | букв (`-m`) и байтов (`-с`) в указанном файле или потоке ввода. | `info find | wc -m` |
|  | | |
| `head` | Вывести указанное число байтов | `head -n 10 file.txt` |
| | (параметр `-c`) или строк (`-n`) файла или текста из начала потока ввода. | `du /usr/share | sort -n -r | head -10` |
|  | | |
| `tail` | Вывести указанное число байтов | `tail -n 10 file.txt` |
| | (параметр `-c`) или строк (`-n`) файла или текста из конца потока ввода. | `du /usr/share | sort -n -r | tail -10` |
|  | | |
| `less` | Утилита для навигации по тексту из стандартного потока ввода. Для выхода из неё нажмите клавишу Q. | `less /usr/share/doc/bash/README` |
|  | | `du | less` |

### Проблемы передачи имён файлов через конвейер

Конвейеры часто используются неправильно для анализа вывода утилит `ls` и `find`. Например, можно ожидать, что следующие две команды для поиска файлов с расширением html вернут одинаковый результат:
{line-numbers: true, format: Bash}
```
find /usr/share/doc/bash -type f -name "*.html"
ls /usr/share/doc/bash | grep "\.html"
```

Однако, в общем случае результат будет отличаться. Дело не только в том, что утилита `find` с помощью опции `-type` позволяет исключить из вывода имена каталогов, а у `ls` такой возможности нет. Проблема заключается в передаче имён файлов через конвейер. Рассмотрим её подробнее.

Стандарт POSIX разрешает любые символы в именах файлов, в том числе пробелы и перевод строки. Единственный запрещённый символ — это [**нуль-терминатор**](https://ru.wikipedia.org/wiki/Нуль-терминированная_строка) (NUL). К чему это может привести? Обратимся к конкретному примеру.

Создайте в домашнем каталоге пользователя файл, в имени которого содержится символ перевода строки. Он обозначается как `\n`.  Для этого воспользуйтесь утилитой `touch`:
{line-numbers: false, format: Bash}
```
touch ~/$'test\nfile.txt'
```

Основное назначение утилиты `touch` — изменять время последней модификации файла на текущее. При этом если указанного файла не существует, он будет создан пустым.

Также для примера создайте файлы `test1.txt` и `file1.txt` следующей командой:
{line-numbers: false, format: Bash}
```
touch ~/test1.txt ~/file1.txt
```

Теперь вызовем утилиту `ls` для наших трёх файлов и обработаем её вывод с помощью `grep`. Для этого выполните следующие команды:
{line-numbers: true, format: Bash}
```
ls ~ | grep test
ls ~ | grep file
```

Их вывод приведён на иллюстрации 2-26.

{caption: "Иллюстрация 2-26. Результат обработки вывода утилиты `ls` с помощью `grep`", width: "100%"}
![ls и grep](images/BashShell/ls-grep.png)

Обратите внимание, что имя файла `test\nfile.txt` оказалось обрезано. Команда `ls` сама по себе выводит его в полной форме `'test'$'\n''file.txt'`. Однако, при передаче через конвейер символ `\n` заменяется на перевод строки и имя оказывается разделено. В результате этого `grep` обрабатывает его части по отдельности так, как будто это два разных файла.

Это не единственная проблема. Предположим, что вы копируете файлы, один из которых содержит пробел в имени (например, `test file.txt`). Это приведёт к ошибке выполнения следующей команды:
{line-numbers: false, format: Bash}
```
ls ~ | xargs cp -t ~/tmp
```

В этом случае `xargs` построит следующий вызов утилиты `cp`:
{line-numbers: false, format: Bash}
```
cp -t ~/tmp test file.txt
```

Ошибка в том, что ни одного из файлов `test` и `file.txt` не существует. Из-за механизма word splitting вместо имени одного файла, состоящего из двух слов, мы получили два имени. Эту проблему можно решить с помощью двойных кавычек так:
{line-numbers: false, format: Bash}
```
ls ~ | xargs -I% cp -t ~/tmp "%"
```

Но если в имени файла стоит перевод строки, а не пробел, добавление кавычек не поможет. Как быть в такой ситуации? Ответ прост — не используйте `ls`. С этой задачей прекрасно справится утилита `find`, вызванная с действием `-exec`. Например так:
{line-numbers: false, format: Bash}
```
find . -name "*.txt" -exec cp -t tmp {} \;
```

Если для обработки списка файлов вам нужно составить команду с помощью `xargs`, воспользуйтесь опцией `-print0` утилиты `find`. Например так:
{line-numbers: false, format: Bash}
```
find . -type f -print0 | xargs -0 -I% bsdtar -cf %.tar %
```

Благодаря опции `-print0`, утилита `find` выводит на стандартный поток пути до файлов, разделяя их нуль-терминатором, а не переводом строки. По умолчанию утилита `xargs` ожидает на вход строки с разделителем `\n`. Если мы передадим ей опцию `-0`, она будет ожидать разделитель нуль-терминатор. Таким образом мы согласуем формат вывода одной утилиты и ввода другой.

Если вам необходимо найти файлы по их содержимому и обработать, используйте утилиту `grep` с опцией `-Z`. Например:
{line-numbers: false, format: Bash}
```
grep -RlZ "GNU" . | xargs -0 -I% bsdtar -cf %.tar %
```

Опция `-Z` позволяет разделять файлы в выводе утилиты `grep` нуль-терминатором. Она аналогична опции `-print0` у `find`.

Из рассмотренных нами примеров можно вывести следующие рекомендации:

1. При передаче имён файлов через конвейер всегда помните про пробелы и переводы строк.

2. Всегда избегайте обработки вывода утилиты `ls`. Вместо неё используйте `find` с действием `-exec`.

3. Если без `xargs` не обойтись, используйте её только с опцией `-0` и передавайте на вход файлы, разделённые нуль-терминатором.

{caption: "Упражнение 2-7. Использование конвейеров и перенаправления потоков ввода-вывода", format: text, line-numbers: false}
```
Напишите команду для архивирования ваших фотографий с помощью утилиты bsdtar (или tar для пользователей Linux и macOS). Предположим, что фотографии хранятся в структуре каталогов, которую мы получили в упражнении 2-6:

~/
  photo/
        2019/
             11/
             12/
        2020/
             01/

Фотографии из одного и того же месяца должны попасть в один архив. После выполнения команды должно получиться следующее:

~/
  photo/
        2019/
             11.tar
             12.tar
        2020/
             01.tar
```

### Логические операторы

Конвейеры позволяют сочетать команды и получать так называемые **линейные алгоритмы**. В таких алгоритмах действия выполняются последовательно друг за другом без каких либо условных операторов. Но предположим, что мы реализуем алгоритм, в котором результат выполнения первой команды определяет следующий шаг. Если команда выполнилась успешно, требуется одно действие, а в противном случае — другое. Тогда конвейер нам не подойдёт. Про такие алгоритмы говорят, что они содержат [**ветвление**](https://ru.wikipedia.org/wiki/Ветвление_(программирование)).

Обратимся к примеру. Нам нужно написать команду для копирования каталога. Если она выполняется успешно, то в лог-файл надо записать строку "OK", а в противном случае - "Error".

Используя конвейер, мы могли бы составить такую команду:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup | echo "OK" > result.log
```

Но после её выполнения строка "OK" запишется в файл `result.log` независимо от результата копирования. Даже если каталога `docs` не существует, вы получите сообщение об успешной операции в лог-файле.

Чтобы вывод команды `echo` зависел от результата утилиты `cp`, воспользуемся оператором `&&`:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup && echo "OK" > result.log
```

Теперь вывод в файл произойдёт только в том случае, если утилита `cp` успешно выполнит копирование.

Что такое оператор `&&`? На самом деле это логическое И. Но в данном случае оно выполняется не над выражениями (условиями), а над командами Bash (действиями). Может возникнуть вопрос: какой смысл выполнять логическую операцию над двумя действиями? Давайте разберёмся.

Стандарт POSIX, которому следует Bash, требует, чтобы каждая запущенная программа всегда завершалась с определённым [**кодом возврата**](https://ru.wikipedia.org/wiki/Код_возврата). При её успешном выполнении, этот код равен нулю. В противном случае он может принимать любое значение от 1 до 255. Когда вы применяете логический оператор к команде, на самом деле он вычисляет её код возврата. А чтобы его вычислить, команду необходимо сначала исполнить.

Вернёмся к нашему примеру:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup && echo "OK" > result.log
```

Предположим, что утилита `cp` завершилась успешно. В этом случае она вернёт ноль. В Bash ноль соответствует значению "истина". Поэтому левая часть нашего оператора `&&` будет истинной. Этой информации ещё не достаточно, чтобы вычислить значение всего выражения. Оно может быть истинным или ложным в зависимости от правого операнда. Чтобы узнать его значение, оператор `&&` должен выполнить команду `echo`. Она всегда завершается успешно и возвращает код ноль. Таким образом результат работы оператора `&&` будет "истина".

Возникает вопрос: как мы используем результат оператора `&&` в нашем примере? Ответ простой — никак. Да, логические операторы нужны для вычисления выражений. Но в Bash они часто применяются ради своих побочных эффектов, а именно — порядка вычисления операндов.

Рассмотрим ситуацию, когда утилита `cp` в нашей команде завершилась с ошибкой. Тогда её код возврата будет отличен от нуля. Для Bash это эквивалентно значению "ложь". В этом случае оператор `&&` может вычислить значение всего выражения, зная только его левую часть. Действительно, если хотя бы один операнд логического И ложный, всё выражение будет ложным. Таким образом код возврата команды `echo` не важен. Поэтому она не будет выполнена и записи в файл `result.log` не произойдёт. Вычисление только тех операндов, которые достаточны для вывода значения всего выражения, называется [**коротким замыканием**](https://en.wikipedia.org/wiki/Short-circuit_evaluation) (short-circuit).

I> Код возврата последней выполненной команды всегда сохраняется в переменной окружения Bash с именем `?`. Чтобы вывести её значение на экран, воспользуйтесь командой `echo`:
{line-numbers: false, format: Bash}
```
echo $?
```

Как вы помните, в условии нашей задачи говорится, что в случае ошибки в лог-файл надо вывести строку "Error". Дополним нашу команду оператором логического ИЛИ, который в Bash обозначается как `||`:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup && echo "OK" > result.log || echo "Error" > result.log
```

В результате мы получим нужное нам поведение. Если утилита `cp` завершится с ошибкой, будет выведена строка `Error`. Почему? Чтобы ответить на этот вопрос, нам сначала надо разобраться с приоритетами операций.

Для простоты дальнейшего обсуждения обозначим код возврата утилиты `cp` как `A`. Первая команда `echo` вернёт нам код `B`, а вторая — `C`. Тогда нашу команду можно записать в виде следующего выражения:
{line-numbers: false}
```
A && B || C
```

В Bash операторы `&&` и `||` имеют одинаковый приоритет. Вычисление выражения происходит слева направо. В таком случае говорят, что операторы [**левоассоциативны**](https://ru.wikipedia.org/wiki/Очерёдность_операций). Учитывая это, мы можем переписать наше выражение в следующем виде:
{line-numbers: false}
```
(A && B) || C
```

Действительно, добавление скобок ничего не изменило. По-прежнему сначала будет вычислено выражение `A && B`, а затем операнд `C`, но только при необходимости.

Итак, что произойдёт если `A` равно истине? В этом случае оператору `&&` потребуется вычислить свой правый операнд B. Это приведёт к выводу "OK" в лог-файл. Далее интерпретатор Bash дойдёт до оператора `||`. В этот момент значение его левой части `A && B` уже известно. Оно равно истине. В этом случае для вычисления всего выражения нет необходимости знать правый операнд. Как вы помните для логического ИЛИ, всё выражение истинно, если хотя бы один из операндов истинен. Поэтому вывода "Error" в лог-файл не произойдёт.

Если `A` равно значению ложь, выражение `A && B` также будет ложным. При этом вычисление операнда B не требуется, а значит вывода "OK" в лог-файл не будет. Когда Bash перейдёт к следующему оператору `||`, ему уже известно, что левый операнд ложный. Поэтому для вычисления всего выражения требуется узнать значение его правой части. Это приведёт к исполнению второй команды `echo` и выводу строки "Error" в лог-файл.

Логика работы операторов `&&` и `||` неочевидна и может быть сложна для понимания. Возможно, вам понадобится какое-то время, чтобы её освоить. Постарайтесь разобраться в ней. Ведь практически в каждом современном языке встречается короткое замыкание при расчёте логических выражений. Поэтому понимание его работы пригодится вам в дальнейшем.

Кроме рассмотренных нами логических операторов команды в языке Bash могут разделяться точкой с запятой `;`. Она используется в случае, когда вызовы должны выполнятся друг за другом всегда и без каких либо условий. Рассмотрим пример.

Предположим, что нам нужно скопировать не один каталог, а два. Для этого можно выполнить следующую команду:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup ; cp -R ~/photo ~/photo-backup
```

В результате её выполнения утилита `cp` будет вызвана дважды независимо от результата копирования каталога `docs`. Даже если оно завершится с ошибкой, каталог `photo` всё равно будет скопирован.

Возможно, вы спросите: отличается ли такое поведение от конвейера? В обоих случаях ошибка выполнения первой части команды не повлияет на работу второй и мы получим линейный алгоритм. В нашем примере с копированием каталогов разницы никакой нет, потому что утилита `cp` игнорирует входные данные с потока ввода. Следующая команда реализует тот же самый алгоритм:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup | cp -R ~/photo ~/photo-backup
```

Но в общем случае отличие есть. Разделитель `;` позволяет выполнить две команды независимо друг от друга. Если же вы используете конвейер, возникает зависимость. Стандартный поток вывода первой команды передаётся на вход второй. Это может изменить её поведение.

Сравните следующие две команды:
{line-numbers: true, format: Bash}
```
ls /usr/share/doc/bash | grep "README" * -
ls /usr/share/doc/bash ; grep "README" * -
```

I> Параметр `-` утилиты `grep` добавляет данные со стандартного потока ввода в конец команды.

Иллюстрация 2-27 демонстрирует результаты выполнения в обоих случаях.

{caption: "Иллюстрация 2-27. Результаты выполнения команд с конвейером и разделителем", width: "100%"}
![Конвейер и резделитель](images/BashShell/pipe-vs-connector.png)

Заметьте, что даже поведение команды `ls` отличается. При использовании конвейера её результат не выводится на экран, а перенаправляется на вход утилиты `grep`. Первым параметром `grep` является шаблон `*`. Поэтому сначала она обработает все файлы в текущем каталоге. Слово "README" найдено в одном из них с именем `xz.txt`. Поэтому на экран выводится следующая строка:
{line-numbers: false, format: Bash}
```
xz.txt:    README              This file
```

Далее `grep` обрабатывает вывод `ls`, полученный из потока ввода. В этих данных тоже обнаружено слово "README", о чём сообщает следующий вывод:
{line-numbers: false, format: Bash}
```
(standard input):README
```

Таким образом `grep` обработала и файлы текущего каталога, и вывод `ls`.

В варианте команды с разделителем `;` утилита `ls` выведет свой результат на экран. После этого будет вызвана `grep`. Она обработает все файлы текущего каталога и поток ввода. Но теперь данных на stdin нет. Поэтому `grep` найдёт искомое слово "README" только в файле `xz.txt`.

{caption: "Упражнение 2-8. Использование логических операторов", format: text, line-numbers: false}
```
Напишите команду, реализующую следующий алгоритм:

1. Скопировать файл README с документацией по Bash в домашний каталог пользователя.

2. Архивировать скопированный файл ~/README.

3. Удалить скопированный файл ~/README.

Каждый шаг должен выполняться только если предыдущий завершился успешно. После каждого шага необходимо записывать его результат в лог-файл с именем result.txt.
```
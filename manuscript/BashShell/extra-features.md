## Дополнительные возможности Bash

Мы рассмотрели основные возможности Bash и часто используемые команды для работы с файловой системой. Этого вполне достаточно для ежедневных задач вроде запуска программ и копирования файлов, которые сегодня принято выполнять в графическом интерфейсе. Однако, весь потенциал масштабируемости GNU утилит раскрывается благодаря дополнительным возможностям Bash. К ним относятся:

1. Перенаправление ввода-вывода.
2. Конвейеры.
3. Коннекторы.

Рассмотрим подробнее каждый из этих механизмов.

### Перенаправление ввода-вывода

Все GNU утилиты строятся вокруг текстовых данных. Они получают на вход строки или файлы. Результат их работы также чаще всего выводится на экран в текстовом виде. Имея универсальный формат данных, очень удобно комбинировать утилиты друг с другом. Таким образом из ограниченного набора узкоспециализированных инструментов можно составлять решения для достаточно сложных задач.

Однако, при сочетании GNU утилит возникает проблема. Как передавать выход одной программы на вход другой? У этой задачи есть несколько решений. Если речь идёт об одной строке, можно использовать буфер обмена. Просто выделите мышью вывод команды, затем наберите следующую команду и вставьте содержимое из буфера обмена. Этот метод перестаёт работать, когда надо скопировать несколько строк. При вставке Bash будет интерпретировать первый встретившийся разделитель строки как нажатие Enter и начнёт исполнять команду. Таким образом часть копируемых данных будет потеряна.

Другое решение заключается в использовании файловой системы. Её можно использовать для временного хранения данных. Это намного удобнее буфера обмена. Во-первых, снимается ограничение на количество строк. Во-вторых, не требуются ручные операции копирования в буфер.

Рассмотрим пример. Предположим, что нам для отчёта нужно сохранить список файлов, найденных командой `find`. Для этого воспользуемся командой `1>`:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README 1> readme_list.txt
```

В результате выполнения этой команды на жёстком диске будет создан файл `readme_list.txt`. В него будет записан весь вывод команды `find`. Формат вывода точно такой же, как если бы он печатался на экран. Обратите внимание, что если файл с именем `readme_list.txt` уже существует в текущем каталоге, его содержимое будет удалено и перезаписано выводом `find`.

Что означает команда `1>`? Это [перенаправление стандартного потока вывода](https://ru.wikipedia.org/wiki/Перенаправление_ввода-вывода). В Unix окружении есть три стандартных потока. Они приведены в таблице 2-11.

{caption: "Таблица 2-11. Стандартные потоки POSIX", width: "100%"}
| Номер | Название | Применение |
| --- | --- | --- |
| 0 | Стандартный поток ввода (standard input или stdin). | Данные, которые передаются на вход программы. Обычно они поступают с устройства ввода типа клавиатуры. |
|  | | |
| 1 | Стандартный поток вывода (standard output или stdout). | Данные, которые выводит программа. Обычно они печатаются в окне терминала. |
|  | | |
| 2 | Стандартный поток ошибок (standard error или stderr). | Данные об ошибках, которые выводит программа. Как правило, они выводятся так же в окне терминала. |

Если с потоками ввода и вывода всё ясно, то поток ошибок вызывает вопросы. Зачем он нужен, если есть stdout? На самом деле он даёт возможность разделять сообщения об ошибках от вывода результата работы программы. Представьте, что вы вызываете команду `find` для поиска файлов. К некоторым каталогам файловой системы у вас нет доступа. О каждой попытке несанкционированного доступа будет выведено сообщение об ошибке. Но эти сообщения потеряются в списке найденных файлов. Их будет намного проще прочитать, если вывести отдельно.

Чтобы перенаправить стандартный поток ошибок, воспользуйтесь командой `2>`:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README 2> errors.txt
```

Как вы возможно уже догадались, цифра перед знаком больше означает номер потока.

Для перенаправления стандартного потока ввода, используется команда `0<`:
{line-numbers: false, format: Bash}
```
grep "Bash" 0< README.txt
```

Команды перенаправления стандартных потоков вывода и ввода используются настолько часто, что для них ввели сокращённую форму: `>` и `<` соответственно. Применим её для рассмотренных ранее команд:
{line-numbers: true, format: Bash}
```
find / -path */doc/* -name README > readme_list.txt
grep "Bash" < README.txt
```

Когда вы перенаправляете стандартный поток вывода, может возникнуть необходимость сохранить текущее содержимое файла и дописать новые данные в его конец.

Обратимся к примеру. Представьте, что у вас есть жёсткий диск с большим числом лог-файлов. Они хранятся в каталогах, соответствующих году и месяцу их создания. Нам требуется найти файлы с определённым именем только за 2018 и 2019 годы. Поиск на всём жёстком диске займет много времени. Поэтому логичнее будет запустить две команды `find` только в интересующих нас каталогах. 

Предположим, что нас интересуют только файлы с расширением `log`. Они хранятся в каталоге `/var/log`. Тогда команды поиска будут выглядеть следующим образом:
{line-numbers: true, format: Bash}
```
find /var/log/2019 -name "*.log" > result.txt
find /var/log/2018 -name "*.log" > result.txt
```

Мы знаем, что перенаправление командой `>` приведёт к перезаписи содержимого файла `result.txt`. Чтобы этого не произошло, воспользуемся командой `>>`:
{line-numbers: true, format: Bash}
```
find /var/log/2019 -name "*.log" > result.txt
find /var/log/2018 -name "*.log" >> result.txt
```

В результате первый вызов `find` создаст новый файл или очистит уже существующий и запишет в него свой результат. Второй вызов допишет свои данные в конец `result.txt`. Если указанного файла не существует, команда `>>` его создаст.

Полная форма команды перенаправления стандартного вывода с записью в конец файла выглядит как `1>>`. Точно так же можно перенаправить и поток ошибок: `2>>`. Если вам нужно перенаправить оба потока в один файл, воспользуйтесь командой `&>` или `&>>`:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README &> result_and_errors.txt
```

Если потоки вывода и ошибок надо записать в разные файлы, вы можете указать команды перенаправления одну за другой через пробел:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README > result.txt 2> errors.txt
```

Вы можете перенаправить поток ошибок в поток вывода. Для этого воспользуйтесь командой `2>&1`:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README 2>&1
```

Такое перенаправление называется **дублированием** (duplicating). Оно используется, когда оба потока должны быть записаны в файл или переданы другой команде через конвейер.

Обратите внимание на важный момент. В результате следующей команды поток ошибок всё равно будет выводиться на экран:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README 2>&1 > result_and_errors.txt
```

Почему это происходит, ведь мы перенаправили stderr в stdout? Дело в том, что каждый поток представляет собой указатель, также называемый [**файловым дескриптором**](https://ru.wikipedia.org/wiki/Файловый_дескриптор). В случае стандартных потоков вывода и ошибок эти указатели связаны с окном терминала. Таково поведение по умолчанию. Перенаправляя эти потоки, мы переназначаем их указатели на файлы.

Теперь вернёмся к нашей команде и рассмотрим происходящие в ней перенаправления в порядке их исполнения:

1. `2>&1`
Теперь стандартный поток ошибок указывает на то же, на что и поток вывода (окно терминала).

2. `> result_and_errors.txt`
Теперь поток вывода указывает на файл `result_and_errors.txt`. При этом поток ошибок по-прежнему связан с окном терминала.

Чтобы наша команда перенаправляла оба потока в файл, её надо исправить следующим образом:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README > result_and_errors.txt 2>&1
```

Сначала мы связываем стандартный поток вывода с файлом, а затем перенаправляем в него же поток ошибок.

### Конвейеры

Перенаправлять вывод одной команды на вход другой можно и без создания временных файлов на жёстком диске. Для этого есть специальный механизм взаимодействия процессов под названием [**конвейер**](https://ru.wikipedia.org/wiki/Конвейер_(Unix)) (pipeline). Рассмотрим его использование на примере.

Предположим, что вам надо найти в документации по Bash информацию о лицензии. Вы можете найти её с помощью утилиты `grep`, запущенной в каталоге `/usr/share/doc/bash`. Другой способ заключается в том, чтобы получить справку командой `info` и обработать её вывод в `grep`. Для этого выполним следующее:
{line-numbers: false, format: Bash}
```
info bash | grep -n "GNU"
```

Команда `info` выводит справку по Bash на стандартный поток вывода. Следующий далее символ `|` означает, что вывод команды слева от него передаётся на вход программы справа. Таким образом `grep` получит текст справки и выведет все вхождения строки "GNU". Параметр `-n` добавляет в вывод `grep` номера строк для удобства.

Ещё один пример. Конвейеры часто используются для анализа вывода команды `ls`. Если вам надо получить имена файлов, в которых встречается некоторое слово, вы можете воспользоваться командой `find`. Но вместо этого можно сочетать команды `ls` и `grep`. Результат получится короче и удобнее для чтения:
{line-numbers: false, format: Bash}
```
ls /usr/share/doc/bash | grep html
```

В результате выполнения этой команды на экран будут выведены все файлы из каталога `/usr/share/doc/bash`, в именах которых встречается слово html.

С помощью конвейеров можно объединять более двух команд. К предыдущему примеру можно добавить сортировку найденных HTML файлов по алфавиту утилитой `sort`:
{line-numbers: false, format: Bash}
```
ls /usr/share/doc/bash | grep html | sort
```

Конвейеры можно сочетать с перенаправлением потоков:
{line-numbers: false, format: Bash}
```
ls /usr/share/doc/bash | grep html | sort > result.txt
```

В результате этой команды отсортированный список HTML файлов из каталога `/usr/share/doc/bash` будет записан в `result.txt`.

В случае сочетания конвейеров и перенаправления потоков возникает одна проблема. Что делать, если необходимо одновременно направить вывод команды в файл и на вход другой программы? Синтаксис Bash не имеет встроенного средства, которое бы позволяло такое поведение. На помощь приходит утилита под названием `tee`. Рассмотрим пример:
{line-numbers: false, format: Bash}
```
ls /usr/share/doc/bash | tee result.txt
```

Если вы запустите эту команду, то увидите вывод `ls` на экране. При этом он же будет записан в файл `result.txt`. Параметр `-a` команды `tee` позволит вам дописывать в конец уже существующего файла, а не очищать его.

Утилита `tee` позволяет сохранять в файлы промежуточные результаты работы команды:
{line-numbers: false, format: Bash}
```
ls /usr/share/doc/bash | tee ls.txt | grep html | tee grep.txt | sort > result.txt
```

В результате выполнения этой команды, вывод `ls` будет сохранён в файле `ls.txt`, а `grep` - в `grep.txt`. Конечный результат по-прежнему окажется в `result.txt`. Это может быть полезно для поиска ошибок.

Мы уже знаем, как с помощью параметра `-exec` команды `find` выполнить действие над каждым найденным файлом. Возможно ли сделать подобное с применением конвейеров?

Утилита `find` имеет встроенный небольшой интерпретатор. Он позволяет запускать внешние утилиты для выполнения указанных действий. Благодаря такой возможности, `find` свободно может вызывать программу `cp` и передавать в неё найденные файлы один за другим.

Если мы говорим об интерпретаторе Bash, ситуация меняется. Предположим, что мы запускаем утилиту `ls` и фильтруем её вывод с помощью `grep`. Bash не имеет доступа к промежуточным результатам работы каждой из команд. Он получает конечный результат целиком в стандартном потоке вывода. Если вы хотите скопировать файлы, имена которых отфильтровал `grep`, просто конвейер не подойдёт:
{line-numbers: false, format: Bash}
```
ls /usr/share/doc/bash/* | grep html | cp -t ~
```

Такой вызов завершится ошибкой от утилиты `cp`, потому что она не читает стандартный поток ввода, а ожидает имя копируемого файла в первом параметре. Наша задача заключается в том, чтобы сконструировать строку параметров из данных, полученных на стандартном потоке ввода. Утилита `xargs` делает именно то, что нам нужно:
{line-numbers: false, format: Bash}
```
ls /usr/share/doc/bash/* | grep html | xargs cp -t ~
```

I> Обратите внимание на маску `/usr/share/doc/bash/*`, переданную на вход `ls`. Благодаря ей, утилита выведет абсолютные пути для каждого файла. Они нужны команде `cp`. Альтернативным решением может быть предварительный переход в каталог `/usr/share/doc/bash`. Тогда команду копирования можно упростить:
{line-numbers: true, format: Bash}
```
cd /usr/share/doc/bash
ls | grep html | xargs cp -t ~
```

В этом вызове стандартный поток вывода команды `grep` передаётся на вход `xargs`. Далее `xargs` вызывает команду `cp` с параметром `-t ~`. Он означает копирование в указанный каталог. После этого `xargs` подставляет каждый файл из вывода `grep` в качестве параметра командной строки. Если в вывод `grep` попало только два HTML файла `bash.html` и `bashref.html`, тогда `xargs` подставит их в конец вызова `cp`. Он будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
cp -t /home/ilya.shpigor /usr/share/doc/bash/bash.html /usr/share/doc/bash/bashref.html
```

Такая подстановка происходит в памяти утилиты `xargs` и по умолчанию не выводится на экран. Вы можете включить функцию вывода сформированной команды с помощью параметра `-t`:
{line-numbers: false, format: Bash}
```
ls /usr/share/doc/bash/* | grep html | xargs -t cp -t ~
```

I> Способность представлять в уме то, что будет делать написанная вами программа — это важнейший навык программиста. Конечно, всегда можно запустить и проверить, но умение прокручивать исполнение кода в уме значительно ускоряет проектирование, разработку и поиск ошибок.

Может возникнуть ситуация, когда стандартный поток ввода содержит слишком много данных. У команд типа `rm` и `cp` есть ограничение на число входных параметров. Утилита `xargs` позволяет разделить данные, полученные из потока ввода, на части и вызывать указанную команду для каждой из них. Для такого разделения используется параметр `-l` с указанием числа строк:
{line-numbers: false, format: Bash}
```
ls /usr/share/doc/bash/* | grep html | xargs -l2 cp -t ~
```

В результате для каждых двух файлов из вывода `ls` будет вызываться своя команда `cp`.

По умолчанию утилита `xargs` добавляет параметры, сконвертированные из стандартного потока ввода, в конец указанной команды. Могут быть ситуации, когда требуется указать место их подстановки. В этом случае можно воспользоваться параметром `-I`:
{line-numbers: false, format: Bash}
```
ls /usr/share/doc/bash/* | grep html | xargs -I% cp % ~
```

Параметр `-I%` сообщает утилите `xargs`, что подстановку надо совершить в место символа `%` в следующем далее вызове. При этом команда `cp` будет вызвана для каждой строки, переданной на ввод утилите `xargs`. В нашем случае сформируются следующие команды:
{line-numbers: true, format: Bash}
```
cp /usr/share/doc/bash/bash.html /home/ilya.shpigor
cp /usr/share/doc/bash/bashref.html /home/ilya.shpigor
```

Есть ряд GNU утилит, которые получают входные данные из стандартного потока ввода. Обычно они применяются вместе с конвейерами. Таблица 2-12 приводит наиболее часто используемые из них.

{caption: "Таблица 2-12. GNU утилиты для обработки стандартного потока ввода", width: "100%"}
| Утилита | Описание | Примеры |
| --- | --- | --- |
| `xargs` | Формирование параметров команды по тексту из стандартного потока ввода. | `ls | xargs cp -t ~` |
|  | | |
| `grep` | Поиск по указанному шаблону. | `ls | grep txt` |
| | | `info ls | grep -A 3 -B 3 GNU` |
|  | | |
| `tee` | Перенаправление потока ввода одновременно в поток вывода и в файл. | `ls | tee result.txt` |
|  | | |
| `sort` | Сортировка строк в потоке ввода в прямом и | `ls | sort -r` |
| | обратном (параметр `-r`) порядке. | `ls | sort -r` |
|  | | |
| `wc` | Подсчёт строк (параметр `-l`), слов (`-w`), букв | `ls | wc -l` |
| | (`-m`) и байтов (`-с`) в указанном файле или потоке ввода. | `info ls | wc -m` |
|  | | |
| `head` | Вывести указанное число байтов (параметр | `info ls | head -n 10` |
| | `-c`) или строк (`-n`) файла или текста из начала потока ввода. | `info ls | head -10` |
|  | | |
| `tail` | Вывести указанное число байтов (параметр | `info ls | tail -n 10` |
| | `-c`) или строк (`-n`) файла или текста из конца потока ввода. | `info ls | tail -10` |
|  | | |
| `less` | Утилита для навигации по тексту из стандартного потока ввода. Для выхода из неё нажмите клавишу Q. | `cat /usr/share/doc/bash/README | less` |

{caption: "Упражнение 2-7. Использование конвейеров и перенаправления потоков ввода-вывода", format: text, line-numbers: false}
```
Напишите команду для архивирования ваших фотографий с помощью утилиты bsdtar (или tar для пользователей Linux и macOS). Предположим, что фотографии хранятся в структуре каталогов, которую мы получили в упражнении 2-6:

~/
  photo/
        2019/
             11/
             12/
        2020/
             01/

Фотографии из одного и того же месяца должны попасть в один архив. После выполнения команды должно получиться следующее:

~/
  photo/
        2019/
             11.tar
             12.tar
        2020/
             01.tar
```

### Проблемы обработки списков файлов

Всегда, когда вы обрабатываете списки имён файлов, надо помнить о возможных проблемах. Стандарт POSIX разрешает любые символы в именах файлов, в том числе пробелы и перевод строки. Единственный запрещённый символ — это [**нуль-терминатор**](https://ru.wikipedia.org/wiki/Нуль-терминированная_строка) (NUL). К чему может привести эта особенность?

Рассмотрим уже знакомую нам команду вывода HTML файлов из каталога Bash документации:
{line-numbers: false, format: Bash}
```
ls /usr/share/doc/bash | grep html
```

В данном конкретном случае команда работает корректно потому, что все файлы содержат в своих именах только символы латинского алфавита и точки. Но предположим, что вы решите воспользоваться этой же командой для домашнего каталога:
{line-numbers: false, format: Bash}
```
ls ~ | grep html
```

В этом случае нет никакой гарантии, что команда отработает корректно. Обратимся к конкретному примеру.

Создайте в домашнем каталоге пользователя файл, в имени которого содержится перевод строки. Для этого воспользуйтесь командой `touch`:
{line-numbers: false, format: Bash}
```
touch ~/$'test\nfile.txt'
```

Символ перевода строки обозначается, как `\n`.

Также создаёте для примера файлы `test1.txt` и `file1.txt`:
{line-numbers: false, format: Bash}
```
touch ~/test1.txt ~/file1.txt
```

Теперь выполните команды:
{line-numbers: true, format: Bash}
```
ls ~ | grep test
ls ~ | grep file
```

Их результаты приведены на иллюстрации 2-26.

{caption: "Иллюстрация 2-26. Результаты выполнения команд `ls` и `grep`", width: "100%"}
![ls и grep](images/BashShell/ls-grep.png)

Обратите внимание, что имя файла `test\nfile.txt` оказалось обрезано в процессе его передачи через конвейер. Команда `ls` сама по себе выводит это имя в форме `'test'$'\n''file.txt'`. Проблемы начинаются именно при его передаче.

Это не единственная проблема. Предположим, что вы копируете файлы, один из которых содержит пробел в имени (например, `test file.txt`). В этом случае следующая команда завершится с ошибкой:
{line-numbers: false, format: Bash}
```
ls ~ | xargs cp -t ~/tmp
```

В этом случае `xargs` построит следующую команду:
{line-numbers: false, format: Bash}
```
cp -t ~/tmp test file.txt
```

Ни одного из файлов `test` и `file.txt` не существует. Эту проблему можно решить так:
{line-numbers: false, format: Bash}
```
ls ~ | xargs -I% cp -t ~/tmp "%"
```

Но если в имени файла стоит перевод строки, а не пробел, добавление кавычек не поможет. Сработает только команда `find` с действием `cp`:
{line-numbers: false, format: Bash}
```
find . -name "*.txt" -exec cp -t tmp {} \;
```

Проблемы с обработкой имён файлов возникают не только в случаях использования символов перевода строки и пробелов. Если в именах встречаются символы подстановки `?` и `*`, у обрабатывающей их утилиты `grep` возникнут проблемы.

Из этих примеров можно сформулировать рекомендацию: избегайте использовать конвейеры для обработки имён файлов. Всегда предпочитайте утилиту `find` и действие `-exec` для этой цели.

### Коннекторы

Конвейеры позволяют сочетать команды и получать так называемые **линейные алгоритмы**. В таких алгоритмах действия выполняются последовательно друг за другом без каких либо условных операторов. Но предположим, что мы реализуем алгоритм, в котором результат выполнения первой команды определяет следующий шаг. Если команда выполнилась успешно, требуется одно действие, а в противном случае — другое. Тогда конвейер нам не подойдёт. Про такие алгоритмы говорят, что они содержат **ветвление**.

Обратимся к примеру. Нам нужно написать команду для копирования каталога. Если она выполняется успешно, то в лог-файл надо записать строку "OK", а в противном случае - "Error".

Используя конвейер, мы могли бы составить такую команду:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup | echo "OK" > result.log
```

Но после её выполнения строка "OK" запишется в файл `result.log` независимо от результата копирования. Даже если каталога `docs` не существует, вы получите сообщение об успешной операции в лог-файле.

Чтобы вывод команды `echo` зависел от результата утилиты `cp`, воспользуемся коннектором `&&`:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup && echo "OK" > result.log
```

Теперь вывод в файл произойдёт только в том случае, если утилита `cp` успешно выполнит копирование.

Что такое коннектор `&&`? На самом деле это логическая операция И. Вы можете возразить, что в данном случае речь идёт не о выражениях (условиях), а о командах Bash (действиях). Какой смысл выполнять логическую операцию над двумя действиями? Всё не так просто.

Стандарт POSIX, которому следует Bash, требует, чтобы каждая запущенная программа завершалась с определённым [**кодом возврата**](https://ru.wikipedia.org/wiki/Код_ответа). При успешном её выполнении, этот код равен нулю. В противном случае он может принимать любое значение от 1 до 255. Когда вы применяете логический оператор к команде, на самом деле он вычисляет её код возврата. А чтобы его вычислить, команду необходимо сначала исполнить.

Вернёмся к нашему примеру:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup && echo "OK" > result.log
```

Предположим, что утилита `cp` завершилась успешно. В этом случае она вернёт ноль. В Bash ноль соответствует значению "истина". Поэтому левая часть нашего оператора `&&` будет истинной. Этой информации ещё не достаточно, чтобы вычислить значение всего выражения. Оно может быть истинным или ложным в зависимости от правого операнда. Чтобы узнать его значение, оператор `&&` должен выполнить команду `echo`. Она всегда завершается успешно и возвращает код ноль. Таким образом результат работы оператора `&&` будет "истина".

Возникает вопрос: как мы используем результат оператора `&&` в нашем примере? Ответ простой — никак. Да, коннекторы являются логическими операторами, но обычно цель их использования вовсе не вычисление выражений. Они применяются ради своих побочных эффектов, а именно — порядка вычисления операндов.

Рассмотрим ситуацию, когда утилита `cp` в нашей команде завершилась с ошибкой. Тогда её код возврата будет отличен от нуля. Для Bash это эквивалентно значению "ложь". В этом случае оператор `&&` может вычислить значение всего выражения, зная только его левую часть. Действительно, если хотя бы один операнд логического И ложный, всё выражение будет ложным. Таким образом код возврата команды `echo` не важен. Поэтому она не будет выполнена и записи в файл `result.log` не произойдёт. Этот эффект вычисления только необходимых операндов называется [**коротким замыканием**](https://en.wikipedia.org/wiki/Short-circuit_evaluation) (short-circuit).

I> Код возврата последней выполненной команды всегда сохраняется в переменной окружения Bash с именем `?`. Чтобы вывести её значение на экран, воспользуйтесь командой `echo`:
{line-numbers: false, format: Bash}
```
echo $?
```

Как вы помните, в условии нашей задачи говорится, что в случае ошибки в лог-файл надо вывести строку "Error". Дополним нашу команду оператором ИЛИ, который в Bash обозначается как `||`:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup && echo "OK" > result.log || echo "Error" > result.log
```

В результате мы получим нужное нам поведение. Если утилита `cp` завершится с ошибкой, будет выведена строка `Error`. Почему? Чтобы ответить на этот вопрос, нам сначала надо разобраться с приоритетами операций.

Для простоты дальнейшего обсуждения обозначим код возврата утилиты `cp` как `A`. Первая команда `echo` вернёт нам код `B`, а вторая - `C`. Тогда нашу команду можно записать в виде следующего выражения:
{line-numbers: false}
```
A && B || C
```

В Bash операторы `&&` и `||` имеют одинаковый приоритет. Вычисление выражения происходит слева направо. В таком случае говорят, что операторы [**левоассоциативны**](https://ru.wikipedia.org/wiki/Очерёдность_операций). Учитывая это, мы можем переписать наше выражение в следующем виде:
{line-numbers: false}
```
(A && B) || C
```

Действительно, добавление скобок ничего не изменило. По-прежнему сначала будет вычислено выражение `A && B`, а затем операнд `C`, но только при необходимости.

Итак, что произойдёт если `A` равно истине? В этом случае оператору `&&` потребуется вычислить свой правый операнд B. Это приведёт к выводу "OK" в лог-файл. Далее интерпретатор Bash дойдёт до оператора `||`. В этот момент значение его левой части `A && B` уже известно. Оно равно истине. В этом случае для вычисления всего выражения нет необходимости знать правый операнд. Как вы помните для логического ИЛИ, всё выражение истинно, если хотя бы один из операндов истинен. Поэтому вывода "Error" в лог-файл не произойдёт.

Если `A` равно значению ложь, выражение `A && B` также будет ложным. При этом вычисление операнда B не требуется, а значит вывода "OK" в лог-файл не будет. Когда Bash перейдёт к следующему оператору `||`, ему уже известно, что левый операнд ложный. Поэтому для вычисления всего выражения требуется узнать значение его правой части. Это приведёт к исполнению второй команды `echo` и выводу строки "Error" в лог-файл.

Логика работы операторов `&&` и `||` неочевидна и может быть сложна для понимания. Возможно, вам понадобится какое-то время, чтобы её освоить. Постарайтесь разобраться в ней. Ведь практически в каждом современном языке встречается короткое замыкание при расчёте логических выражений. Поэтому понимание его работы пригодится вам в дальнейшем.

Кроме рассмотренных нами логических операторов в языке Bash есть ещё коннектор `;`. Он используется в случае, когда команды должны выполнятся друг за другом всегда и без каких либо условий. Рассмотрим пример.

Предположим, что нам нужно скопировать не один каталог, а два. Для этого можно выполнить следующую команду:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup ; cp -R ~/photo ~/photo-backup
```

В результате её выполнения утилита `cp` будет вызвана дважды независимо от результата копирования каталога `docs`. Даже если оно завершится с ошибкой, каталог `photo` всё равно будет скопирован.

Возможно, вы спросите: отличается ли поведение коннектора `;` от конвейера? В обоих случаях получается линейный алгоритм, верно? В нашем примере с копированием каталогов разницы никакой нет, потому что утилита `cp` игнорирует входные данные с потока ввода. Следующая команда реализует тот же самый алгоритм:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup | cp -R ~/photo ~/photo-backup
```

Но в общем случае отличие есть. Коннектор `;` позволяет выполнить две команды независимо друг от друга. Если же вы используете конвейер, возникает зависимость. Стандартный поток вывода первой команды передаётся на вход второй. Это может изменить её поведение.

Сравните следующие две команды:
{line-numbers: true, format: Bash}
```
ls /usr/share/doc/bash | grep "README" * -
ls /usr/share/doc/bash ; grep "README" * -
```

I> Параметр `-` утилиты `grep` добавляет данные со стандартного потока ввода в конец команды.

Иллюстрация 2-27 демонстрирует результаты выполнения для обоих случаев.

{caption: "Иллюстрация 2-27. Результаты выполнения команд с конвейером и коннектором", width: "100%"}
![Конвейер и коннектор](images/BashShell/pipe-vs-connector.png)

Заметьте, что даже поведение команды `ls` отличается. При использовании конвейера её результат не выводится на экран, а перенаправляется на вход утилиты `grep`. Первым параметром `grep` является шаблон `*`. Поэтому сначала она обработает все файлы в текущем каталоге. Слово "README" найдено в одном из них с именем `xz.txt`. Поэтому на экран выводится следующая строка:
{line-numbers: false, format: Bash}
```
xz.txt:    README              This file
```

Далее `grep` обрабатывает вывод `ls`, полученный из потока ввода. В этих данных тоже обнаружено слово "README", о чём сообщает следующий вывод:
{line-numbers: false, format: Bash}
```
(standard input):README
```

Таким образом `grep` обработала и файлы текущего каталога, и вывод `ls`.

В варианте команды с коннектором `;` утилита `ls` выведет свой результат на экран. После этого будет вызвана `grep`. Она обработает все файлы текущего каталога и поток ввода. Но теперь данных на stdin нет. Поэтому `grep` найдёт искомое слово "README" только в файле `xz.txt`.

{caption: "Упражнение 2-8. Использование коннекторов", format: text, line-numbers: false}
```
Напишите команду, реализующую следующий алгоритм:

1. Скопировать файл README с документацией по Bash в домашний каталог пользователя.

2. Архивировать скопированный файл ~/README.

3. Удалить скопированный файл ~/README.

Каждый шаг должен выполняться только если предыдущий завершился успешно. После каждого шага необходимо делать запись в лог-файл с именем result.txt.
```
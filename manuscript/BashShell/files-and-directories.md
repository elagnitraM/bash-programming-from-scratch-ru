## Действия над файлами и каталогами

Мы выяснили, как найти нужный нам файл или каталог на диске. Какие же действия мы можем над ними совершить? Скорее всего, вам хорошо знаком этот список по опыту работы с графическим интерфейсом ОС:

1. Создание
2. Удаление
3. Копирование
4. Переименование

В таблице 2-6 приводятся утилиты, позволяющие выполнить эти действия.

{caption: "Таблица 2-6. Утилиты для работы с файлами и каталогами", width: "100%"}
| Утилита | Описание | Примеры |
| --- | --- | --- |
| `mkdir` | Создание каталога с указанным именем и путём. | `mkdir /tmp/docs` |
| | | `mkdir -p tmp/docs/report` |
|  | | |
| `rm` | Удалить указанный файл или каталог по | `rm readme.txt` |
| | абсолютному или относительному пути. | `rm -rf ~/tmp` |
|  | | |
| `cp` | Скопировать файл или каталог. Первым | `cp readme.txt tmp/readme.txt` |
| | параметром передаётся текущий путь, а вторым — целевой. | `cp -r /tmp ~/tmp` |
|  | | |
| `mv` | Переименовать указанный первым параметром | `mv readme.txt documentation.txt.` |
| | файл или каталог. | `mv ~/tmp ~/backup` |

Рассмотрим основные способы использования этих утилит. Теперь вы знаете, как получить краткую справку по опции `--help`, а также более подробную информацию в системе `info`. С их помощью вы сможете уточнить опции и параметры утилит, которые редко используются, но могут оказаться полезными для вашего случая.

### mkdir

Утилита `mkdir` создаёт новый каталог по указанному абсолютному или относительному пути, который передаётся первым параметром. Например, чтобы создать каталог `docs` в домашнем каталоге пользователя выполните команду:
{line-numbers: false, format: Bash}
```
mkdir ~/docs
```

Вы также можете создать `docs` по относительному пути. Для этого сначала перейдите в домашний каталог пользователя, а затем вызовите `mkdir`:
{line-numbers: true, format: Bash}
```
cd ~
mkdir docs
```

У утилиты `mkdir` есть полезная опция `-p`. Она позволяет создать родительские каталоги, если они ещё не существуют. Например, вы хотите создать каталог для отчета за 2019 год. Он должен находится по пути `~/docs/reports/2019`. Предположим, что каталоги `docs` и `reports ` ещё не созданы. В графическом интерфейсе Windows вам сначала нужно создать их, а только потом каталог `2019`. В Bash для этого достаточно одной команды:
{line-numbers: false, format: Bash}
```
mkdir -p ~/docs/reports/2019
```

Обратите внимание, что если каталоги `docs` или `reports` уже существуют, сообщения об ошибке не будет. Утилита `mkdir` создаст только недостающую часть пути.

### rm

Утилита `rm` удаляет файлы и каталоги, указанные по абсолютному или относительному пути.

Пример удаления файла `report.txt`:
{line-numbers: true, format: Bash}
```
rm report.txt
rm ~/docs/reports/2019/report.txt
```

Вы может также удалить несколько файлов, указав их имена через пробел:
{line-numbers: false, format: Bash}
```
rm report.txt ~/docs/reports/2019/report.txt
```

Вместо указания списка файлов можно воспользоваться шаблоном поиска Bash. Например, следующая команда удаляет все TXT файлы начинающиеся со слова "report":
{line-numbers: false, format: Bash}
```
rm ~/docs/reports/2019/report*.txt
```

Если вы попробуете удалить файл с доступом только на чтение, будет выведено предупреждение как на иллюстрации 2-26.

{caption: "Иллюстрация 2-26. Предупреждение при удалении файла с доступом на чтение", width: "100%"}
![Предупреждение `rm`](images/BashShell/rm-warning.png)

Чтобы продолжить удаление, нажмите клавишу y (сокращение от yes), а затем Enter. Если вы хотите проигнорировать подобные предупреждения, воспользуйтесь опцией `-f` или `--force`:
{line-numbers: false, format: Bash}
```
rm -f ~/docs/reports/2019/report*.txt
```

I> Многие опции GNU утилит имеют краткую и полную форму. Краткая форма начинается с тире `-` и состоит из одной буквы. Полная форма начинается с двойного тире `--` и представляет собой слово или несколько слов, разделённых тире. Такой формат рекомендуется [POSIX-соглашением](https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html) и [GNU-расширением](https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html) к нему.

Для удаления каталога вместе с его содержимым воспользуйтесь опцией `-r` или `--recursive`:
{line-numbers: false, format: Bash}
```
rm -r ~/docs
```

### cp и mv

Утилиты копирования и переименования файлов и каталогов очень похожи. В обеих сначала указывается то, над чем совершается действие, а потом путь назначения.

Например, команда для копирования файла `report.txt` в текущем каталоге, выглядит следующим образом:
{line-numbers: false, format: Bash}
```
cp report.txt report-2019.txt
```

После её исполнения будет создан файл `report-2019.txt`. Его содержимое будет таким же как у `report.txt`.

Если старый файл `report.txt` вам больше не нужен, можно заменить вызов утилиты `cp` на `mv`:
{line-numbers: false, format: Bash}
```
mv report.txt report-2019.txt
```

В этом случае создаётся новый файл `report-2019.txt`, а старый `report.txt` удаляется.

Вы можете указывать абсолютные или относительные пути до файлов. Таким образом они будут копироваться или переносится между разными каталогами:
{line-numbers: true, format: Bash}
```
cp ~/report.txt ~/tmp/report-2019.txt
cp report.txt tmp/report-2019.txt

mv ~/report.txt ~/tmp/report-2019.txt
mv report.txt tmp/report-2019.txt
```

Переименование каталогов происходит точно так же, как и файлов:
{line-numbers: false, format: Bash}
```
mv ~/tmp ~/backup
```

В результате этой команды каталог `tmp` будет переименован в `backup`.

Для копирования каталога вместе с его содержимым необходимо использовать опцию `-r`:
{line-numbers: false, format: Bash}
```
cp -r /tmp ~
```

Эта команда копирует системный каталог `/tmp` в домашний каталог пользователя.

Если при копировании или переименовании в целевом каталоге уже есть файл с тем же именем, будет выдано сообщение с подтверждением его перезаписи. Чтобы это сообщение не выводилось, а перезапись происходила автоматически, используйте  опцию `-f`:
{line-numbers: true, format: Bash}
```
cp -f ~/report.txt ~/tmp
mv -f ~/report.txt ~/tmp
```

Если в каталоге `tmp` уже есть файл с именем `report.txt`, в результате этих команд он будет перезаписан.

{caption: "Упражнение 2-6. Использование утилит для работы с файлами и каталогами", format: text, line-numbers: false}
```
Упорядочьте свои фотографии за последние три месяца с помощью изученных GNU утилит. Перед началом работы обязательно сделайте их резервную копию. Разделите все фотографии по годам и месяцам. Структура каталогов должна получиться примерно следующая:

~/
  photo/
        2019/
             11/
             12/
        2020/
             01/
```

### Права доступа

При знакомстве с утилитой `rm` мы столкнулись с понятием [**прав доступа**](https://ru.wikipedia.org/wiki/Права_доступа) к файлу. Удаляя файл или каталог, доступный только для чтения, `rm` выводит предупреждение. Что означают эти права?

Возможно, концепция прав уже знакома вам по опыту использования Проводника Windows. Ограничение доступа к файловой системе — одна из важных функций ОС. Благодаря ей, разные пользователи имеют доступ только к своим файлам и каталогам. Это может быть полезно, если один и тот же компьютер используется разными людьми.

На иллюстрации 2-26 обратите внимание на вывод утилиты `ls`, которая была запущенна с опцией `-l`. Перед вами таблица с подробной информацией о файлах и каталогах. Каждому из них соответствует одна строка таблицы. В первом её столбце указаны права доступа. Например, у файла `report.txt` они следующие: `-r--r--r--`. Рассмотрим, что означает эта запись.

В Unix информация о доступе хранится в [**битовой маске**](https://ru.wikipedia.org/wiki/Битовая_маска). Битовая маска — это обычное число. Если представить его в двоичной системе счисления, то получится последовательность нулей и единиц. Для хранения каждого из них в памяти требуется один бит. Главная особенность битовой маски заключается в способе её интерпретации.

Предположим, что у нас есть объект (например, файл) с набором признаков. Каждый признак либо есть, либо его нет. Если он есть, соответствующий ему бит равен 1, иначе — 0. Например, если мы говорим о доступе к файлу, то признаки могут быть следующие:

1. Разрешение на чтение.
2. Разрешение на запись.
3. Разрешение на исполнении.

Набор этих признаков можно закодировать маской из трёх битов. Допустим, что к файлу есть полный доступ: его содержимое можно читать и изменять, а сам файл удалить. Тогда маска выглядит так:
{line-numbers: false}
```
111
```

Если чтение и исполнение запрещено, то первый и третий биты будут нулями:
{line-numbers: false}
```
010
```

Обратите внимание, что позиция бита в маске определяет то, какой признак он кодирует.

Надеюсь, что вы уловили суть. Теперь вернёмся к правам доступа в Unix. Строка `-r--r--r--` есть не что иное, как битовая маска. В ней нулям соответствует тире, а единицам какая-то буква. То есть строку `-r--r--r--` можно представить в виде маски 0100100100. Если же все биты равны единице, мы получим строку `drwxrwxrwx`.

На самом деле маска прав доступа состоит из четырёх частей. Они приведены в таблице 2-7.

{caption: "Таблица 2-7. Значение позиций букв в строке прав доступа", width: "100%"}

| d | rwx | rwx | rwx |
| --- | --- | --- | --- |
| Признак каталога. | Права владельца файла или каталога. По умолчанию это тот, кто его создал. | Права группы пользователей, привязанной к файлу. По умолчанию это группа, к которой относится владелец. | Права всех остальных пользователей кроме владельца и группы, привязанной к файлу. |

Каждая из этих частей представляет собой отдельную маску. На каждую из них отводится 4 бита. Поэтому строку `-r--r--r--` можно представить в виде числа: 0000 0100 0100 0100.

Что означают буквы в строке прав доступа? Как мы выяснили, это равные единице биты. Позиция каждого из них определяет, какое действие над файлом или каталогом разрешено. Буквы были введены, чтобы упростить чтение маски. Согласитесь, что понять строку `-rw-r--r--` проще и быстрее, чем двоичное число 0000011001000100. Значение каждого символа приведено в таблице 2-8.

{caption: "Таблица 2-8. Значение символов в строке прав доступа", width: "100%"}
| Символ | Значение для файла | Значение для каталога |
| --- | --- | --- |
| d | Если вместо d первым символом стоит тире, это права для файла. | Права доступа соответствуют каталогу.  |
|  | | |
| r | Чтение. | Вывод содержимого каталога. |
|  | | |
| w | Запись. | Создание, переименование или удаление файлов в каталоге. |
|  | | |
| x | Выполнение файла. | Переход в каталог, доступ к его файлам и подкаталогам. |
|  | | |
| — | Отсутствие права. | Отсутствие права. |

Когда к файлу имеют полный доступ все пользователи системы, строка прав выглядит как `-rwxrwxrwx`. Для каталога с таким же доступом первый символ тире заменяется на `d`: `drwxrwxrwx`.

I> Чтобы вывести группы, к которым относится текущий пользователь воспользуйтесь командой `groups`.

Теперь мы легко можем прочитать права доступа к файлам `report.txt` и `report1.txt` на иллюстрации 2-26. Первый из них могут читать все пользователи, но его изменение и исполнение запрещено для всех. Второй файл могут читать все, а изменять только владелец. При этом его исполнение также запрещено для всех.

Таблица 2-9 демонстрирует права доступа к файлу или каталогу, необходимые для выполнения рассмотренных нами команд.

{caption: "Таблица 2-9. Права доступа для команд", width: "100%"}
| Команда | Маска | Права доступа | Комментарий |
| --- | --- | --- | --- |
| `ls` | `r--` | Чтение | Только каталоги. |
|  | | | |
| `cd` | `--x` | Выполнение | Только каталоги. |
|  | | | |
| `mkdir` | `-wx` | Запись и выполнение. | Только каталоги. |
|  | | | |
| `rm` | `-w-` | Запись | Для каталогов надо использовать параметр `-r`. |
|  | | | |
| `cp` | `r--` | Чтение | Целевой каталог должен быть доступен на запись и исполнение. |
|  | | | |
| `mv` | `r--` | Чтение | Целевой каталог должен быть доступен на запись и исполнение. |
|  | | | |
| Исполнение | `r-x` | Чтение и выполнение. | Только для файлов. |

### Запуск файлов

Для запуска файла в Bash достаточно, чтобы он имел права на чтение и исполнение. В отличие от требований, принятых в ОС Windows, его расширение может быть произвольным. Он может называться например `report.txt`, но всё равно быть исполняемым.

I> В Unix нет общепринятого соглашения о расширении исполняемых файлов. Поэтому, чтобы узнать их тип, вам пригодится утилита `file`. Она принимает на вход относительный или абсолютный путь к проверяемому файлу. Примеры вызова утилиты:
{line-numbers: true, format: Bash}
```
file /usr/bin/ls
file ls
```

Мы уже знаем, что все GNU утилиты находятся в каталогах `/bin` и `/usr/bin`. Bash хранит эти пути в переменной `PATH`. Может возникнуть вопрос: куда устанавливаются новые приложения в Unix-окружении?

В Windows на системном диске есть каталоги `Program Files` и `Program Files (x86)`. По умолчанию все приложения устанавливаются туда. Для каждого из них создаётся новый подкаталог (например, `C:\Program Files (x86)\Notepad++`). В процессе установки в него копируются исполняемые файлы, DLL библиотеки, файлы конфигурации и ресурсов. Всё это вместе с системными библиотеками Windows необходимо для запуска и работы приложения. Вместо каталогов `Program Files` пользователь может указать любой другой путь установки (например, `D:\Programs`).

В Unix-окружении есть два общепринятых варианта установки приложения. Первый вариант немного напоминает подход Windows. Установка происходит в системный каталог `/opt`. В нём создаётся подкаталог (например, `/opt/teamviewer`), куда копируются все файлы приложения. Как правило, этот вариант установки используется проприетарными программами, исходный код которых закрыт.

Второй вариант применяется для приложений с открытым исходным кодом. Как было сказано ранее, у приложений есть файлы различного типа, необходимые для его работы. В зависимости от типа каждый файл копируется в соответствующий системный каталог. Список этих каталогов приведён в таблице 2-10.

{caption: "Таблица 2-10. Назначение системных каталогов", width: "70%"}
| Каталог | Назначение |
| --- | --- |
| `/bin` | Исполняемые файлы системных утилит. |
|  | |
| `/etc` | Конфигурационные файлы. |
|  | |
| `/lib` | Библиотеки, необходимые для работы системных утилит. |
|  | |
| `/usr/bin` | Исполняемые файлы приложений пользователя. |
|  | |
| `/usr/lib` | Библиотеки, необходимые для приложений пользователя. |
|  | |
| `/usr/local` | Приложения, скомпилированные пользователем самостоятельно. |
|  | |
| `/usr/share` | Архитектурно-независимые файлы ресурсов приложений пользователя. |
|  | |
| `/var` | Файлы, создаваемые приложениями в процессе работы (например лог-файлы). |

Может показаться, что копирование файлов каждого приложения по нескольким системным каталогом приведёт к хаосу в файловой системе. На самом деле всё в точности наоборот. Благодаря тому, что все приложения следует соглашению о назначении каждого системного пути, оказывается намного проще организовать их взаимодействие. В Windows каждое приложение при установке копирует в свой каталог все необходимые ему библиотеки, кроме системных. Таким образом постепенно в файловой системе накапливаются десятки копий одних и тех же библиотек. В Unix все приложения используют единственный экземпляр нужной им библиотеки. Это возможно потому, что она установлена по предопределённому системному пути и все приложения знают, где её искать. В результате использование пространства жёсткого диска происходит намного эффективнее.

Предположим, что мы установили приложение (например, браузер). Согласно таблице 2-10 его исполняемый файл (например, `firefox`) будет скопирован в каталог `/usr/bin`. Как нам его запустить из Bash? Есть несколько способов:

1. По имени исполняемого файла.
2. По абсолютному пути.
3. По относительному пути.

Рассмотрим каждый способ подробнее.

Первый вариант нам хорошо знаком. Именно таким образом мы вызывали GNU утилиты до сих пор. Например, запуск `find` из каталога `/usr/bin` выглядит следующим образом:
{line-numbers: false, format: Bash}
```
find --help
```

Точно так же мы запустим и браузер:
{line-numbers: false, format: Bash}
```
firefox
```

Это работает, потому что путь `/usr/bin` хранится в переменной `PATH`. Получив команду `firefox`, Bash ищет исполняемый файл с соответствующим именем в каждом из путей в `PATH`.

I> Обратите внимание, что порядок поиска исполняемого файла соответствует порядку путей в переменной `PATH`. Предположим, что файл есть в обоих каталогах `/usr/local/bin` и `/usr/bin`. В то же время `/usr/local/bin` идёт первым в `PATH`. Тогда Bash всегда будет запускать файл из него.

Во втором способе запуска мы просто набираем абсолютный путь к исполняемому файлу:
{line-numbers: false, format: Bash}
```
/usr/bin/firefox
```

Как правило, этот способ применяется для запуска проприетарных приложений, установленных в каталог `/opt`. Этот каталог обычно не указывается в переменной `PATH`. Поэтому Bash не может самостоятельно найти исполняемый файл.

Третий способ запуска файла покажется непривычным для Windows пользователей. Если вы перейдёте в каталог `/usr`, то запустить браузер можно командой:
{line-numbers: false, format: Bash}
```
bin/firefox
```

Это очевидно и не вызывает вопросов. Но предположим, что исполняемый файл `firefox` находится в каталоге `/opt/firefox/bin`. Перейдём в этот каталог командой `cd` и попробуем запустить браузер:
{line-numbers: true, format: Bash}
```
cd /opt/firefox/bin
firefox
```

Такой способ не сработает. Почему? Дело в том, что сейчас мы попытались запустить приложение по имени исполняемого файла. В этом случае Bash будет искать его в путях переменной `PATH`. Но приложение установлено в `/opt`, которого в `PATH` нет. Тогда Bash выдаст ошибку, что файл не найден.

Правильно указывать относительный путь с текущим каталогом:
{line-numbers: false, format: Bash}
```
./firefox
```

Тогда Bash поймёт, что искать исполняемый файл следует в текущем каталоге.

Рассмотрим, как добавить свой путь (например, `/opt/firefox/bin`) в переменную `PATH`. Для этого выполните следующие действия:

1. Перейдите в домашний каталог пользователя:
{line-numbers: false, format: Bash}
```
cd ~
```

2. Выведите соответствующий ему Windows путь (см. пример на иллюстрации 2-7):
{line-numbers: false, format: Bash}
```
pwd -W
```

3. В редакторе Notepad (Блокнот) или любом другом откройте файл `.bash_profile` из этого каталога.

4. В конец файла добавьте следующую строку:
{line-numbers: false, format: Bash}
```
PATH="/opt/firefox/bin:${PATH}"
```

Чтобы изменения вступили в силу, вам нужно перезапустить терминал MSYS2. Теперь если вы наберёте команду `firefox`, Bash найдёт соответствующий исполняемый файл по пути `/opt/firefox/bin` и запустит его.

## Навигация по файловой системе

### Структура каталогов

В верхней части Проводника Windows есть адресная строка. В ней отображается абсолютный путь к открытой в данный момент [**папки**](https://ru.wikipedia.org/wiki/Каталог_(файловая_система)#Термин_«Папка») (альтернативное название каталогов в Windows). Например, на иллюстрации 2-6 текущим путём является `This PC > Local Disk (C:) > msys64`. Это означает, что в данный моменты в окне проводника отображается содержимое папки `msys64`, которая хранится на локальном диске `C`. Диск называется локальным, если он физически подключён к вашему компьютеру. Если мы представим полный путь до папки в виде строки, то получим `C:\msys64`.

{caption: "Иллюстрация 2-6. Окно Проводника Windows"}
![Окно Проводника Windows](images/BashShell/explorer.png)

В окне терминала выводится та же самая информация: какая папка "открыта" в данный момент. Но между путём в Bash и Проводнике есть важное различие. Структуры каталогов в ОС Windows и Unix различаются. В Windows каждому физическому или логическому диску соответствует буква латинского алфавита. По умолчанию системный диск, на который была установлена ОС, обозначается буковой `C`. В Проводнике он обозначается иконкой, поведение которой напоминает обычную папку. По двойному щелчку можно получить доступ к её содержимому, т.е. файлам и папкам, хранящимся на этом диске.

Диск на который была установлена ОС называется **системным**. На нём Windows создаёт [стандартные каталоги](https://en.wikipedia.org/wiki/Directory_structure#Windows_10), необходимые для своей работы: `Windows`, `Program Files`, `Program Files (x86)`, `Users`, `PerfLogs`. Другие логические и физические диски будут обозначаться буквами: `D`, `E`, `F` и т.д. Структуру каталогов на них пользователь выбирает произвольно.

Такая организация файловой системы известна как [File Allocation Table](https://ru.wikipedia.org/wiki/FAT). Изначально она разрабатывалась Microsoft для ОС [MS-DOS](https://ru.wikipedia.org/wiki/MS-DOS) и впоследствии её принципы работы легли в основу стандарта [ECMA-107](http://www.ecma-international.org/publications/standards/Ecma-107.htm). В современных версиях Windows на смену FAT пришла система [NTFS](https://ru.wikipedia.org/wiki/NTFS), в которой организация дисков и каталогов осталась без изменений.

Структура каталогов Unix следует [стандарту POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap10.html#tag_10). Поскольку Bash разрабатывался для POSIX-совместимых ОС, ему требуется соответствующая структура каталогов для корректной работы.

В чём же различие структуры каталогов Windows и Unix? Ключевая особенность Unix в том, что все логические и физические диски монтируются (т.е. подключаются) в [**корневую файловую систему**](https://en.wikipedia.org/wiki/Root_directory). То есть у компьютера есть каталог самого верхнего уровня, который обозначается символом `/` и называется [**корневым**](https://ru.wikipedia.org/wiki/Каталог_(файловая_система)#Корневой_каталог). Он включает в себя файлы и каталоги всех физических и логических дисков, подключённых к системе. Путь по которому находится структура каталогов подключённого диска называется его [**точкой монтирования**](https://ru.wikipedia.org/wiki/Точка_монтирования). Перейдя по этому пути, вы окажетесь в другой файловой системе. Все точки монтирования находятся внутри корневого каталога.

Рассмотрим пример. Предположим, что у нас есть Windows система с 2-мя физическими дисками, обозначенными буквами `C` и `D`. Тогда структура каталогов первого уровня иерархии может выглядеть так, как демонстрирует листинг 2-1.

{caption: "Листинг 2-1. Структура каталогов первого уровня в ОС Windows", line-numbers: false}
```
C:\
    PerfLogs\
    Windows\
    Program Files\
    Program Files (x86)\
    Users\

D:\
    Data\
    Install\
```

В Unix эта же самая иерархия каталогов будет выглядеть согласно листингу 2-2.

{caption: "Листинг 2-2. Структура каталогов в ОС Unix", line-numbers: false}
```
/
    c/
        PerfLogs/
        Windows/
        Program Files/
        Program Files (x86)/
        Users/

    d/
        Data/
        Install/
```

Помните, что как только вы запускаете терминал MSYS2, вы оказываетесь в структуре каталогов Unix. Поэтому, например, путь `C:\Windows` станет недоступным. Вместо него вы должны использовать путь `/c/Windows`.

I> Важная особенность POSIX совместимых систем заключается в [чувствительности к регистру символов](https://ru.wikipedia.org/wiki/Чувствительность_к_регистру_символов). Это означает, что строки `Data` и `data` различаются. В Windows чувствительности к регистру нет. Поэтому вы можете задать в адресной строке Проводника путь `c:\windows`, в результате чего будет открыт системный каталог `Windows`. В Unix и Bash это не сработает. Вам нужно вводить все символы пути в правильном регистре. Также обратите внимание, что в Bash в качестве разделителя между именами каталогов и файлов используется символ [**слэш**](https://ru.wikipedia.org/wiki/Косая_черта) `/`, а не [**обратный слэш**](https://ru.wikipedia.org/wiki/Обратная_косая_черта) `\`, как в Windows.

### Команды навигации по файловой системе

Вернёмся к нашему окну терминала, изображённому на иллюстрации 2-4. Последняя отображаемая в нём строка состоит из единственного символа `$`. Он называется **приглашением командной строки**. Если последним напечатанным символом в терминале было приглашение, значит интерпретатор готов прочитать и исполнить очередную команду от пользователя. В противном случае интерпретатор занят и ваш ввод не будет обработан.

Рассмотрим наиболее часто используемые команды и **утилиты** для навигации по файловой системе. Они приведены в таблице 2-1.

{caption: "Таблица 2-1. Команды и утилиты для навигации по файловой системе", width: "100%"}
| Команда | Описание | Примеры |
| --- | --- | --- |
| `ls` | Вывод на экран содержимого указанного каталога. Если | `ls` |
| | каталог не указан, будет выведено содержимое текущего. | `ls /c/Windows` |
|  | | |
| `pwd` | Вывести на экран пути до текущего каталога. Ключ `-W` | `pwd` |
| | позволяет вывести путь в структуре каталогов Windows | `pwd -W` |
|  | | |
| `cd` | Перейти в указанный каталог по относительному или | `cd tmp` |
| | абсолютному пути. | `cd /c/Windows` |
| | | `cd ..` |
|  | | |
| `mount` | Выполнить подключение файловой системы в корневую. При запуске без параметров выводится список всех подключенных в данный момент систем. | `mount` |
|  | | |
| `find` | Найти указанный файл или каталог. Первым | `find . -name vim` |
| | параметром команды указывается каталог, начиная с которого будет вестись поиск. Если он не указан, используется текущий каталог. | `find /c/Windows -name *vim*` |
|  | | |
| `grep` | Найти файл по его содержимому. | `grep "PATH" *` |
| | | `grep -Rn "PATH" .` |
| | | `grep "PATH" * .*` |

Командный интерпретатор позволяет запускать установленные программы. Но кроме этого он предоставляет [**встроенные команды**](https://ru.wikipedia.org/wiki/Bash#Внутренние_команды). Они не требуют какого-то приложения, а исполняются самим интерпретатором. В таблице 2-1 приведены следующие встроенные команды:

1. `pwd`
2. `cd`

Unix-окружение MSYS предоставляет GNU утилиты. Это вспомогательные узкоспециализированные программы, предназначенная для доступа к функциям ОС. В данном случае с помощью них мы получаем доступ к файловой системе. В таблице 2-1 упоминаются следующие утилиты:

1. `ls`
2. `mount`
3. `find`
4. `grep`

При первом знакомстве с интерпретатором Bash разница между встроенными командами и утилитами не важна. Но в будущем при написании скриптов её следует учитывать.

Не зависимо от того, что вам нужно запустить — внутреннюю команду или утилиту — вы набираете текст после приглашения интерпретатора `$`. Этот текст называется просто командой.

#### pwd

Рассмотрим каждую из команд и утилит таблицы 2-1. Мы только что запустили терминал. Первым делом всегда полезно уточнить текущий каталог. Терминал MSYS2 выводит эту информацию перед приглашением `$`. Предположим, что этого не происходит. Воспользуемся встроенной командой `pwd`. Мы получим результат, приведённый в верхней части иллюстрации 2-7. Он означает, что сейчас мы находимся в домашнем каталоге пользователя `/home/ilya.shpigor`. Если вы укажете **опцию** `-W`, то будет выведен текущий путь в структуре каталогов Windows. Это может быть полезно, если вы создали какие-то файлы в окружении MSYS2 и хотите открыть их в Windows приложении.

{caption: "Иллюстрация 2-7. Вывод команды `pwd`"}
![Вывод pwd](images/BashShell/pwd-command.png)

I> При запуске терминала MSYS2 текущим является домашний каталог пользователя. Перед приглашением командной строки он указан как `~`. Это сокращённое обозначение его абсолютного пути. Вы можете работать с ним также, как и с любым другим абсолютным путём.

Может возникнуть вопрос: что такое опция `-W`, которую мы передали встроенной команде `pwd`? Одна из проблем интерфейса командной строки в том, что пользователь ограничен в средствах взаимодействия с запускаемым приложением. Обычно режим его работы задаётся в момент запуска. Кроме того программе может понадобиться дополнительная информация (например, путь до файла или каталога). Самый простой способ передать эту информацию — поместить её в строку, следующую за именем приложения. Интерпретатор позаботится о том, чтобы программа её получила. Эта строка состоит из параметров.

[**Параметром**](https://ru.wikipedia.org/wiki/Интерфейс_командной_строки#Формат_команды) или аргументом программы называются слово или символ, которые передаются ей на вход. **Опцией** или ключём называется аргумент в стандартизированной форме (начинается с `-` или `--`), который переключает режим работы программы. 

Встроенные команды интерпретатора вызываются так же как и программы. Поэтому они также могут иметь параметры и опции.

Вернёмся к встроенной команде `pwd`. В интерпретаторе Bash есть функция автодополнения, которая значительно ускоряет набор текста. Она вызывается по нажатию клавиши Tab. Если вы набрали текст и по нему Bash может однозначно определить, какая команда имеется ввиду, он допишет её за вас. Если же есть несколько команд, которые начинаются с введённых букв, автодополнение не произойдёт. В этом случае нажмите Tab повторно, чтобы увидеть список всех доступных команд. Иллюстрация 2-8 демонстрирует вывод по двойному нажатию Tab после ввода текста `pw`.

{caption: "Иллюстрация 2-8. Автодополнение для команды `pw`"}
![Автодополнение pw](images/BashShell/pw-autocompletion.png)

#### ls

После уточнения текущего каталога, будет полезно узнать его содержимое. Для этого воспользуемся утилитой `ls`. Её вывод для домашнего каталога `~` будет пустым, как в верхней части иллюстрации 2-9. Попробуем выполнить эту утилиту с опцией `-a`. Вы увидите восемь файлов, начинающихся с точки, как в нижней части иллюстрации 2-9.

{caption: "Иллюстрация 2-9. Вывод утилиты `ls`"}
![Вывод ls](images/BashShell/ls-command.png)

Файлы и каталоги являются скрытыми, если их имена начинаются с точки. Как правило, они создаются приложениями автоматически и хранят их конфигурацию. Опция `-a` утилиты `ls` позволяет вывести скрытые файлы и каталоги.

Если вам надо вывести содержимое одного из подкаталогов, просто укажите его абсолютный или относительный путь первым параметром `ls`. Иллюстрация 2-10 демонстрирует вывод для команды `ls /`.

{caption: "Иллюстрация 2-10. Вывод утилиты `ls`"}
![Вывод ls](images/BashShell/ls-root-command.png)

Обратите внимание, что в полученном нами выводе нет подкаталогов `/c` и `/d`, которые упоминались в листинге 2-2. На самом деле эти каталоги представляют собой точки монтирования соответствующих дисков. То есть в структуре каталогов Windows этих путей нет. Они создаются в окружении Unix, чтобы вы смогли перейти в корневые каталоги дисков `C` и `D`. Утилита `ls` читает содержимое каталога в окружении Windows, поэтому и не отображает точки монтирования.

#### mount

Когда к вашему компьютеру подключено несколько дисков, может быть полезно вывести на экран их точки монтирования. Эту задачу выполняет утилита [`mount`](https://ru.wikipedia.org/wiki/Mount), запущенная без параметров. Иллюстрация 2-11 демонстрирует результат её выполнения в моём случае.

{caption: "Иллюстрация 2-11. Вывод утилиты `mount`"}
![Результат mount](images/BashShell/mount-command.png)

Рассмотрим этот вывод подробнее. Его следует рассматривать как таблицу из четырёх столбцов. В первом из них указывается диск, его раздел или просто каталог, который был смонтирован в корневую [**файловую систему**](https://ru.wikipedia.org/wiki/Файловая_система) (ФС). Второй столбец указывает точку монтирования, то есть путь по которому доступен смонтированный диск. В третьем столбце указывается тип его файловой системы. Четвёртый столбец содержит атрибуты доступа (например, только для чтения или для чтения и записи).

Таблица 2-2 представляет собой вывод утилиты `mount` с иллюстрации 2-11, разделённый на столбцы.

{caption: "Таблица 2-2. Вывод утилиты `mount`", width: "100%"}
| Монтируемый раздел | Точка монтирования | Тип ФС | Атрибуты доступа |
| --- | --- | --- | --- |
| `C:/msys64` | `/` | `ntfs` | `binary,noacl,auto` |
| `C:/msys64/usr/bin` | `/bin` | `ntfs` | `binary,noacl,auto` |
| `C:` | `/c` | `ntfs` | `binary,noacl,posix=0,user,noumount,auto` |
| `Z:` | `/z` | `hgfs` | `binary,noacl,posix=0,user,noumount,auto` |

Таблица 2-2 может вызвать недоумение у Windows-пользователей. Корневым каталогом для Bash является `C:/msys64`. Но поскольку все точки монтирования находятся в нём, то диск `C` также является его подкаталогом с путём `/c`. С точки зрения файловой системы Windows зависимость обратная: `C:/msys64` является подкаталогом диска `C`. На самом деле такое противоречие не вызывает проблем. Как мы уже выяснили, путь `/c` является точкой монтирования. То есть такой каталог в окружении Windows не существует. Его можно рассматривать просто как [**ссылку**](https://ru.wikipedia.org/wiki/Символическая_ссылка) на диск `C` в окружении MSYS2.

Вывод утилиты `mount` занял много места на экране. Чтобы очистить окно терминала от текста, нажмите комбинацию клавиш Ctrl+L. Если запущенная команда зависла или долго не отвечает, её можно прервать нажатием Ctrl+C.

#### cd

После того как мы определились с текущим местоположением, можно перейти в нужный нам каталог. Допустим, что нас интересует документация по интерпретатору Bash. Попробуем её найти в соответствующем каталоге. Наберите команду `cd /usr`. Не забывайте про автодополнение. Оно работает как для самих команд, так и для их параметров. В нашем случае будет достаточно набрать `cd /u` и нажать клавишу Tab. Имя каталога `usr` будет введено автоматически. Результат выполнения команды приведён на иллюстрации 2-12.

{caption: "Иллюстрация 2-12. Результат выполнения команды `cd`"}
![Результат cd](images/BashShell/cd-command.png)

Обратите внимание, что встроенная команда `cd` в случае успешного выполнения ничего не выводит. Единственное, что изменилось — это текущий каталог, который выводится перед приглашением командной строки. Теперь мы находимся в `/usr`. 

Команда`cd` работает как с абсолютными путями, так и относительными. Относительные пути короче и удобнее в наборе. Только что мы перешли в каталог `/usr` по его абсолютному пути. Вопрос — как нам вернуться в корневой каталог? Можно воспользоваться его абсолютным путём `cd /` либо специальным относительным путём `..`, который означает каталог на уровень выше по иерархии. Тогда команда перехода будет выглядеть как `cd ..`.

I> Кроме `..` в Bash есть еще один специальный путь `.`, который означает текущий каталог. То есть если выполните `cd .`, то ничего не произойдёт. Вы останетесь в том же текущем каталоге.

Если вы воспользуетесь утилитой `ls`, то обнаружите несколько подкаталогов, среди которых есть `share`. В нём есть подкаталог `doc/bash`. Перейдите в него командой `cd share/doc/bash`. По `ls` вы обнаружите там файл `README`. Выведите его содержимое на экран утилитой `cat README`. Её результат приведён на иллюстрации 2-13.

I> Авторы некоторых руководств по Bash утверждают, что использовать утилиту `cat` для вывода содержимого файлов неправильно. Её первоначальное назначение — объединять несколько файлов и выводить результат в стандартный поток вывода. Вместо вызова `cat` для одного файла они рекомендуют использовать перенаправление потоков, которое мы рассмотрим далее в этой главе. Согласно этой рекомендации, вывод содержимого файла на экран выглядит следующим образом:
{line-numbers: false, format: Bash}
```
echo "$(< README.txt)"
```

{caption: "Иллюстрация 2-13. Вывод утилиты `cat`", height: "30%"}
![Результат cat](images/BashShell/cat-command.png)

Обратите внимание, что из-за большого размера файла весь вывод утилиты не поместился на экране. Но он остался в истории терминала. Вы можете воспользоваться полосой прокрутки в правой части окна, чтобы прочитать начало файла `README`. Так же для прокрутки [по страницам](https://en.wikipedia.org/wiki/Page_Up_and_Page_Down_keys) можно использовать горячие клавиши Shift+PageUp и Shift+PageDown, а по строкам — Shift+↑ и Shift+↓.

Каждая введённая в терминал команда или вызов утилиты сохраняется в [истории команд](https://ru.wikipedia.org/wiki/History). Вы можете прокручивать её назад и вперёд стрелками вверх и вниз соответственно. Например, вы только что ввели команду `cat README`. Чтобы её повторить, нажмите стрелку вверх и клавишу Enter. Комбинация клавиш Ctrl+R вызывает поиск по истории. Нажмите комбинацию и начните набирать текст. Bash предложит вам последнюю введённую команду, которая начинается так же. Чтобы исполнить её, просто нажмите Enter. Для вывода всей истории на экран воспользуйтесь командой `history`.

I> В терминале MSYS2 работает [буфер обмена](https://ru.wikipedia.org/wiki/Буфер_обмена). Он представляет собой промежуточное хранилище данных. Вы можете поместить в него выбранный текст, а затем вставить его в другое место или приложение. Для копирования текста из терминала в буфер обмена, его достаточно просто выделить мышью, зажав её левую кнопку. Чтобы вставить текст в окно терминала, нажмите среднюю кнопку мыши. В другие приложения вы можете вставить текст, нажав правую кнопку мыши и выбрав пункт "Вставить".

#### find

Утилита `find` — это не только инструмент для поиска по файловой системе, но также средство обработки большого числа файлов и каталогов.

Если вы запустите утилиту `find` без параметров, она выведет всё содержимое текущего каталога и его подкаталогов. Иллюстрация 2-14 демонстрирует результат выполнения `find` для домашнего каталога пользователя `~`.

{caption: "Иллюстрация 2-14. Результат работы утилиты `find`", height: "30%"}
![Результат find](images/BashShell/find-command.png)

Первым параметром `find` можно указать относительный или абсолютный каталог, с которого она начнёт поиск. Например, для корневого каталога команда вызова `find` будет выглядеть так:
{line-numbers: false, format: Bash}
```
find /
```

Если первый параметр опущен, утилита начнёт поиск из текущего каталога.

Остальные параметры представляют собой выражение из одного и более элементов. Оно определяет, какие именно файлы и каталоги попадут в вывод утилиты. Для обработки выражений в `find` встроен собственный небольшой интерпретатор.

Наиболее часто используемые выражения приведены в таблице 2-3.

{caption: "Таблица 2-3. Часто используемые выражения утилиты `find`", width: "100%"}
| Выражение | Значение | Пример |
| --- | --- | --- |
| `-type f` | Искать только файлы. | `find -type f` |
|  | | |
| `-type d` | Искать только каталоги. | `find -type d` |
|  | | |
| `-name шаблон` | [**Шаблон имени**](https://ru.wikipedia.org/wiki/Шаблон_поиска) файла или каталога, | `find -name README` |
| | чувствительный к регистру. | `find -name READ*` |
| | | `find -name READ??` |
|  | | |
| `-iname шаблон` | Шаблон имени файла или каталога, нечувствительный к регистру. | `find -iname readme` |
|  | | |
| `-path шаблон` | Шаблон пути к файлу или каталогу, чувствительный к регистру. | `find -path */doc/bash/*` |
|  | | |
| `-ipath шаблон` | Шаблон пути к файлу или каталогу, нечувствительный к регистру. | `find . -ipath */DOC/BASH/*` |
|  | | |
| `-a` или `-and` | Скомбинировать несколько выражений по условию логического И. Это означает, что в вывод утилиты попадут только файлы и каталоги, удовлетворяющие всем выражениям. | `find -name README -a -path */doc/bash/* ` |
|  | | |
| `-o` или `-or` | Скомбинировать несколько выражений по условию логического ИЛИ. То есть выполнения одного из выражений будет достаточно. | `find -name README -o -path */doc/bash/* ` |
|  | | |
| `!` или `-not` | Логическое отрицание (НЕ) | `find -not -name README` |
| | последующего выражения. То есть в вывод попадут только файлы и каталоги, которые не удовлетворяют выражению. | `find ! -name README` |

Во всех шаблонах утилиты `find` можно использовать [**символы подстановки**](https://ru.wikipedia.org/wiki/Символ_подстановки) (wildcard character). Всего в Bash есть три таких символа: `*`, `?` и `[`. Звёздочка означает любое количество любых символов. Знак вопроса — один любой символ. Например, строка `README` будет соответствовать следующим шаблонам: `*ME`, `READM?`, `*M?`, `R*M?`.

Кроме `*` и `?` можно указывать наборы символов, которые ожидаются в определённой позиции строки. Например, шаблон `[cb]at.txt` будет соответствовать обоим файлам `cat.txt` и `bat.txt`. Его можно применить в утилите `find` следующим образом:
{line-numbers: false, format: Bash}
```
find . -name "[cb]at.txt"
```

{caption: "Упражнение 2-1. Шаблоны поиска", line-numbers: false}
```
Какая из следующих строк соответствует шаблону `*ME.??`:
* 00_README.txt
* README
* README.md
```

{caption: "Упражнение 2-2. Шаблоны поиска", line-numbers: false}
```
Какая из следующих строк соответствует шаблону `*/doc?openssl*`:
* /usr/share/doc/openssl/IPAddressChoice_new.html
* /usr/share/doc_openssl/IPAddressChoice_new.html
* doc/openssl
* /doc/openssl
```

Рассмотрим подробнее использование шаблонов в `find`. Вернёмся к нашему примеру с поиском документации по Bash. Предположим, что мы находимся в корневом каталоге. Начнём с указания пути. В Unix обычно все документы хранятся в каталогах с именем `doc`. Учитывая это, напишем следующую команду для поиска:
{line-numbers: false, format: Bash}
```
find / -path */doc/*
```

В результате её исполнения мы получим список всех файлов документации в системе. Чтобы ограничить его только файлами относящимися к Bash, воспользуемся логическим И:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -path */bash/*
```

Обратите внимание, что мы опустили параметр `-a`. Если не указан никакой параметр, то `find` по умолчанию использует условие логического И. Следующая команда вернёт точно такой же результат (см. иллюстрацию 2-15):
{line-numbers: false, format: Bash}
```
find / -path */doc/* -a -path */bash/*
```

{caption: "Иллюстрация 2-15. Результат работы утилиты `find`", height: "30%"}
![Результат find](images/BashShell/find-path-path.png)

В конце своего вывода утилита `find` сообщает об ошибке. Проблема в том, что некоторые подкаталоги `/` являются точками монтирования Windows дисков (например, `/c` для `C:`). В нашем случае утилита `find` не может получить доступ к их содержимому, если будет вызвана из корневого каталога. Чтобы избежать этой проблемы, начните поиск с точки монтирования диска `C:`:
{line-numbers: false, format: Bash}
```
find /c -path */doc/* -a -path */bash/*
```

Альтернативное решение — исключить точки монтирования из поиска с помощью параметра `-mount`:
{line-numbers: false, format: Bash}
```
find / -mount -path */doc/* -a -path */bash/*
```

В результате мы получили относительно небольшой список документов, среди которых легко найти нужный нам `README`.

Мы могли бы следовать другой стратегии поиска. Предположим, что нам известно имя искомого файла. Тогда имеет смысл указать его вместе с предполагаемым путём:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README
```

Иллюстрация 2-16 демонстрирует результат такого поиска.

{caption: "Иллюстрация 2-16. Результат работы утилиты `find`", height: "30%"}
![Результат find](images/BashShell/find-path-name.png)

Мы снова получили относительно небольшой список, в котором легко найти `README` файл, относящийся к Bash.

Выражения `find` можно группировать. Для этого следует использовать [экранированные](https://ru.wikipedia.org/wiki/Экранирование_символов) скобки. Например, следующая команда ищет файлы `README` с путём `*/doc/*` или файлы LICENSE с произвольным путём.
{line-numbers: false, format: Bash}
```
find / \( -path */doc/* -name README \) -o -name LICENSE
```

Почему скобки, передаваемые в утилиту `find`, должны экранироваться обратным слэшем? Дело в том, что скобки является частью синтаксиса Bash, т.е. используются в конструкциях языка. Встретив их в вызове утилиты, Bash выполнит **подстановку** (или замену) этих символов на что-то другое. С помощью экранирования мы сообщаем интерпретатору, что эти символы должны передаваться в утилиту как есть, без какой-либо замены.

По-настоящему мощным инструментом утилиту `find` делает необязательный последний параметр, который задаёт действие. Это действие будет применено к каждому из найденных файлов и каталогов.

Таблица 2-4 демонстрирует опции для указания действий над найденными файлами.

{caption: "Таблица 2-4. Опции для указания действий над найденными файлами", width: "100%"}
| Опция | Значение | Пример |
| --- | --- | --- |
| `-exec команда {} \;`| Выполнить указанную команду над каждым из найденных файлов или каталогов. | `find -name README -type f -exec cp {} ~ \;` |
|  | | |
| `-exec команда {} +`| Выполнить указанную команду над всеми найденными файлами или каталогами. То есть они все будут переданы на вход этой команды. | ` find -type d -exec cp -t ~ {} +` |
|  | | |
| `-delete`| Удалить каждый из найденных файлов. Обратите внимание, что каталоги будут удаляться только если они пустые. | `find -name README -type f -delete` |

I> Обратите внимание, что действие `-exec` с `{} +` на конце вы можете указывать только для команд, поддерживающих несколько параметров. Большинство GNU утилит их поддерживает. В противном случае команда обработает только первый найденный файл или каталог.

Рассмотрим пример использования действия `-exec`. Достаточно часто встречается случай, когда вам надо найти какие-то файлы и скопировать их другое место. Предположим, что мы ищем все файлы документации по Bash с расширением HTML. Тогда команда поиска будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
find / -path "*/doc/bash/*" -name "*.html"
```

I> При передаче шаблонов в утилиту `find` вы должны заключать их в двойные кавычки `"`. Они выполняют ту же функцию что и обратный слэш, экранирующий скобки. Таким образом мы даём Bash понять, что ему не следует интерпретировать шаблоны самому (то есть выполнять подстановку), а вместо этого просто передавать их вызываемой утилите.

Результат её выполнения представлен на иллюстрации 2-17.

{caption: "Иллюстрация 2-17. Результат работы утилиты `find`", height: "30%"}
![Результат find](images/BashShell/find-html.png)

Добавим к этой команде параметр `-exec`, вызывающий утилиту `cp`.  Эта утилита выполняет копирование файлов и каталогов. Первым её параметром указывается то, что следует скопировать, а вторым — куда копировать. Теперь вызов `find` выглядит следующим образом:
{line-numbers: false, format: Bash}
```
find / -path "*/doc/bash/*" -name "*.html" -exec cp {} ~ \;
```

Эта команда ничего не выведет в терминал (кроме уже знакомой нам ошибки с точками монтирования). Что произошло в ходе её выполнения? Для каждого найденного HTML файла (см. иллюстрацию 2-17) вызывается утилита `cp`. В неё первым параметром вместо скобочек `{}` передаётся соответствующий путь. Поскольку было найдено два HTML файла, произойдёт только два вызова утилиты `cp`:
{line-numbers: true, format: Bash}
```
cp ./usr/share/doc/bash/bash.html ~
cp ./usr/share/doc/bash/bashref.html ~
```

В результате каждого вызова соответствующий HTML файл будет скопирован в домашний каталог пользователя.

Только что мы написали нашу первую программу на языке интерпретатора утилиты `find`. Её алгоритм выглядит следующим образом:

1. Найти файлы с расширением HTML, хранящиеся в корневом каталоге. Их пути должны соответствовать шаблону `*/doc/bash/*`.

2. Скопировать каждый из найденных файлов в каталог пользователя.

Программа состоит всего из двух действий. Но она окажется очень полезной, если вам нужно обработать значительное число файлов. Просто представьте себе, сколько времени у вас бы ушло на поиск файлов на диске `C` по таким же критериям и их копирование через графический интерфейс.

Действия `-exec` можно комбинировать точно так же как и выражения с условиями поиска. Предположим, что нам надо вывести содержимое каждого из найденных HTML файлов и подсчитать количество строк в нём. Для вывода содержимого воспользуемся уже знакомой
нам утилитой `cat`. Для подсчёта строк применим утилиту `wc` с опцией `-l`. На вход она принимает имя файла, который надо обработать. Команда вызова `find` в этом случае будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
find / -path "*/doc/bash/*" -name "*.html" -exec cat {} \; -exec wc -l {} \;
```

В этом примере между действиями `-exec` логический оператор не указан. По умолчанию используется `-a` или логическое И. Это означает, что второе действие будет выполнено только при успешном исполнении первого. Мы можем заменить логический оператор на ИЛИ. Тогда второе действие будет выполняться всегда, независимо от результата первого.

Действия `-exec` можно группировать с помощью экранированных скобок `\(` и `\` точно так же как и условия поиска.

{caption: "Упражнение 2-3. Использование утилиты `find`", line-numbers: false}
```
Напишите команду вызова find для поиска всех TXT файлов в вашем Unix-окружении.
Дополните команду, чтобы вывести общее число строк в этих файлах.
```

#### Логические выражения

Изучая встроенный интерпретатор утилиты `find`, мы столкнулись с [**логическими выражениями**](
https://ru.wikipedia.org/wiki/Логическое_выражение). Это важная концепция современных языков программирования, поэтому рассмотрим её подробнее.

Логическое выражение — это некоторое условие, которое может быть либо истинным, либо ложным. Условия могут сочетаться друг с другом. В общем случае мы говорим о некоторой конструкции языка, результат вычисления которой принимает одно из двух значений: "истина" или "ложь".

Мы уже упоминали алгебру логики, когда обсуждали двоичную систему счисления. Это раздел математики, который изучает [**логические операции**](https://ru.wikipedia.org/wiki/Логическая_операция) над выражениями. Эти операции отличаются от принятых в арифметике сложения, вычитания, умножения и деления. Причина в том, что выражения принимают только два значения. Из-за этого арифметические действия над ними становятся тривиальными и ничего не дают. С другой стороны, если применить к выражениям логические операции, можно составлять условия со строгими правилами вывода результата. Комбинация таких условий позволит получить сложное поведение.

I> Выражения, над которыми выполняется логическая операция, называются **операндами**.

Рассмотрим простой пример. Представьте себе, что мы программируем робота для склада. Его задача заключается в том, чтобы переносить коробки из точки А в точку Б. Мы можем задать ему простой алгоритм работы:

1. Возьми коробку в точке А.

2. Двигайся в точку Б.

3. Положи коробку.

В этом алгоритме нет никаких условий. Он реализует простейшее поведение робота. Но представьте, что произойдёт, если на пути робота стоит погрузчик. В этом случае исполнение приведённого выше алгоритма приведёт к столкновению. Чтобы этого избежать, мы должны добавить условие:

1. Возьми коробку в точке А.

2. Если нет препятствия, двигайся в точку Б. Иначе остановись.

3. Положи коробку.

Второй шаг алгоритма называется [**условным оператором**](https://ru.wikipedia.org/wiki/Ветвление_(программирование)). Он есть во многих современных языках программирования.

Что именно происходит в условном операторе? На самом деле в нём вычисляется значение логического выражения "нет препятствия". Если препятствие есть, выражение будет ложно, и робот остановится. В противном случае он продолжит движение.

Логические операции появляются, когда требуется сочетать несколько выражений. Представьте, что в точке А может не оказаться коробки. Тогда роботу нет смысла двигаться в точку Б. В этом случае мы можем воспользоваться операцией [**логического И**](https://ru.wikipedia.org/wiki/Конъюнкция), известной так же как конъюнкция. Наш алгоритм станет выглядеть следующим образом:

1. Возьми коробку в точке А.

2. Если есть коробка И нет препятствия, двигайся в точку Б. Иначе остановись.

3. Положи коробку.

Интуитивно понятно, что результат логического И в нашем примере будет истинным только тогда, когда оба условия истинны. То есть у робота есть коробка и нет препятствия. В любом другом случае выражение будет ложным, и робот остановится.

Изучая утилиту `find`, мы столкнулись с ещё двумя логическими операциями: [**ИЛИ**](https://ru.wikipedia.org/wiki/Дизъюнкция) (дизъюнкция) и [**НЕ**](https://ru.wikipedia.org/wiki/Отрицание) (отрицание). На самом деле в нашем алгоритме для робота мы уже применили НЕ, когда написали выражение "нет препятствия". Это ничто иное как отрицание: "НЕ есть препятствие". Перепишем наш алгоритм более формально:

1. Возьми коробку в точке А.

2. Если есть коробка И НЕ есть препятствие, двигайся в точку Б. Иначе остановись.

3. Положи коробку.

Мы можем переписать наше выражение, используя операцию ИЛИ. Но в таком случае нам придётся поменять действия робота: истинное выражение приведёт к его остановке, а ложное — к движению в точку Б. В итоге получится следующий алгоритм:

1. Возьми коробку в точке А.

2. Если НЕ есть коробка ИЛИ есть препятствие, остановись. Иначе двигайся в точку Б.

3. Положи коробку.

Очевидно, что логика робота нисколько не изменилась. Он по-прежнему остановится, если у него нет коробки или на пути возникло препятствие.

Как вы уже заметили, [**естественный язык**](https://ru.wikipedia.org/wiki/Естественный_язык) (язык общения людей) плохо подходит для описания логических выражений. Поэтому в алгебре логики применяется формальная математическая запись.

Кроме рассмотренных нами логических И, ИЛИ, НЕ в программировании широко распространены ещё три операции: **эквивалентность**, **не эквивалентность**, **исключающее ИЛИ**. Информация по ним приведена в таблице 2-5.

{caption: "Таблица 2-5. Логические операции в программировании", width: "100%"}
| Операция | Значение выражения |
| --- | --- |
| И (AND) | Истинно только когда оба операнда истинны. |
|  | |
| ИЛИ (OR) | Истинно, когда любой из операндов истинен. Ложно только тогда, когда все операнды ложны. |
|  | |
| НЕ (NOT) | Истинно когда операнд ложен и наоборот. |
|  | |
| Исключающее ИЛИ (XOR) | Истинно когда значения операндов отличаются (истина-ложь или ложь-истина). Ложно когда они совпадают (истина-истина, ложь-ложь). |
|  | |
| Эквивалентность | Истинно только когда значения операндов совпадают. |
|  | |
| Не эквивалентность | Истинно только когда значения операндов отличаются. |

Постарайтесь запомнить эту таблицу. При частом использовании логических операций это будет совсем несложно.

#### grep

Ещё одним мощным инструментом поиска является утилита `grep`. Мы познакомились с программой `find`, которая позволяет искать файлы и каталоги по имени, пути и [**метаданным**](https://ru.wikipedia.org/wiki/Метаданные). К метаданным относятся размер (в случае файла), время создания и последней модификации, права доступа.

Чтобы лучше понять задачи, решаемые утилитой `grep`, рассмотрим пример. Представьте, что на всём жёстком диске вы ищете текстовый файл, в котором встречается фраза "free software" (свободное ПО). Алгоритм такого поиска с помощью утилиты `find` будет следующим:

1. Найти все текстовые файлы на диске с помощью `find`.

2. Открыть каждый файл в текстовом редакторе и проверить наличие фразы "free software".

Это огромная ручная работа, которая займёт много времени. Утилита `grep` создана как раз для решения подобных задач.

Чтобы найти текст в указанном файле, запустите `grep` со следующими параметрами:
{line-numbers: false, format: Bash}
```
grep "free software" /usr/share/doc/bash/README
```

Первым параметром указывается строка для поиска. В нашем случае это "free software". Не забывайте про двойные кавычки. С их помощью мы сообщаем Bash, что вся строка должна передаваться утилите `grep` как первый параметр. В противном случае она будет разбита на слова, каждое из которых будет передано как отдельный параметр. Этот механизм разделения строк на слова в Bash называется [**word splitting**](http://mywiki.wooledge.org/WordSplitting).

После строки для поиска идут относительные или абсолютные пути к интересующим нас файлам, разделённые пробелом. В нашем примере передаётся только путь до `README` файла с документацией на Bash. Результат выполнения команды приведён на иллюстрации 2-18.

{caption: "Иллюстрация 2-18. Результат вызова утилиты `grep`", width: "100%"}
![Результат grep](images/BashShell/grep-command.png)

В вывод утилиты можно добавить номера строк файла, в которых встретилась искомая строка. Для этого добавьте опцию `-n`. Результат такого вызова приведён в нижней части иллюстрации 2-18.

Мы выяснили, как с помощью `grep` искать строки в одном файле. Но как эта утилита поможет нам найти нужный файл из многих? Для этой цели `grep` можно использовать двумя способами.

В первом способе мы применим функцию Bash для разворачивания шаблона имени файла. Предположим, что в домашнем каталоге пользователя находятся два текстовых файла: `bash.txt` и `xz.txt`. Это копии `README` документов соответствующих программ: Bash и xz. Наша задача заключается в проверке, встречается ли фраза "free software" в этих файлах. Для этого выполним следующее:
{line-numbers: true, format: Bash}
```
cd ~
grep "free software" *
```

Сначала мы перешли в домашний каталог пользователя. Затем вызвали утилиту `grep`. В качестве целевого файла мы использовали символ подстановки — звёздочка. Это шаблон поиска, означающий любую строку. Перед вызовом `grep` Bash выполнит подстановку. Вместо шаблона в команду будет вставлен список всех файлов, имена которых ему соответствуют. В результате команда будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
grep "free software" bash.txt xz.txt
```

Попробуйте оба варианта вызова `grep`: с шаблоном `*` и явным указанием списка файлов. Вы получите одинаковый результат.

I> С помощью команды `echo` можно вывести на экран результат разворачивания шаблона Bash:
{line-numbers: false, format: Bash}
```
echo *
```

В данном случае важно не заключать символ звёздочки в двойные кавычки следующим образом:
{line-numbers: false, format: Bash}
```
grep "free software" "*"
```

Если сделать так, то подстановки Bash не будет и шаблон поиска будет передан как есть утилите `grep`. В отличие от `find` она не умеет самостоятельно разворачивать шаблоны. Поэтому будет выведено сообщение об ошибке как на иллюстрации 2-19.

{caption: "Иллюстрация 2-19. Результат передачи шаблона в `grep`", width: "100%"}
![Результат grep](images/BashShell/grep-error.png)

I> Bash не включает скрытые файлы в подстановку шаблона `*`. В нашем случае это означает, что утилита `grep` не получит их на вход. Чтобы искать по скрытым файлам, используйте шаблон `.*`. Можно указывать его и `*`, чтобы искать по всем файлам разом. Например:
{line-numbers: false, format: Bash}
```
grep "free software" * .*
```

Мы рассмотрели первый способ поиска нужного файла с помощью шаблонов Bash. Во втором способе воспользуемся функцией утилиты `grep` для перебора всех файлов в указанном каталоге. Эта функция включается опцией `-r`. При этом последним параметром нужно указать путь к каталогу:
{line-numbers: false, format: Bash}
```
grep -r "free software" .
```

Приведённая команда ищет фразу "free software" во всех файлах текущего каталога. Если вы хотите также проверить файлы подкаталогов, то воспользуйтесь опцией `-R`:
{line-numbers: false, format: Bash}
```
grep -R "free software" .
```

Целевой каталог для поиска можно указывать по относительному и абсолютному путям. Например:
{line-numbers: true, format: Bash}
```
cd /home
grep -R "free software" ilya.shpigor/tmp
grep -R "free software" /home/ilya.shpigor/tmp
```

I> Утилита `grep`, запущенная с опциями `-r` и `-R`, корректно обработает скрытые файлы и каталоги.

Если вас интересуют только имена файлов, в которых встречается указанная строка, воспользуйтесь опцией `-l`:
{line-numbers: false, format: Bash}
```
grep -Rl "free software" .
```

Результат выполнения этой команды приведён на иллюстрации 2-20.

{caption: "Иллюстрация 2-20. Результат вывода только имён файлов"}
![Результат grep](images/BashShell/grep-files.png)

Если вам наоборот нужен список файлов, в которых указанная строка не встречается, воспользуйтесь опцией `-L`. Например так:
{line-numbers: false, format: Bash}
```
grep -RL "free software" .
```

Скорее всего, познакомившись с утилитой `grep`, вам захочется применить её для поиска документов в формате [PDF](https://ru.wikipedia.org/wiki/Portable_Document_Format) и MS Office. К сожалению, это не сработает. Файлы в этих форматах не являются текстовыми. Но эта задача может быть решена установкой дополнительных утилит: `pdftotext`, `pdfgrep`, `antiword`, `catdoc` и `xdoc2txt`. Мы рассмотрим их далее, когда будем обсуждать пакетный менеджер.

Файлы с исходным кодом программ являются текстовыми. Поэтому утилита `grep` отлично подходит для поиска по ним.

{caption: "Упражнение 2-4. Использование команды `grep`", line-numbers: false}
```
Напишите команду вызова утилиты grep для поиска приложений MSYS2, распространяющихся под свободной лицензией. В сообществе открытого ПО самые распространённые лицензии следующие:

1. GNU General Public License
2. MIT license
3. Apache license
4. BSD license
```

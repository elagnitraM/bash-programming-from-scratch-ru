## Функции

Bash относится к [**процедурным языкам программирования**](https://ru.wikipedia.org/wiki/Процедурное_программирование), поэтому в нём есть функции. Мы уже сталкивались с ними, когда знакомились с переменными и командой `declare`. Теперь рассмотрим подробнее, что представляют собой функции.

### Парадигмы программирования

Перед тем как начать знакомство с функциями, разберёмся с терминологией. Она поможет нам понять, зачем вообще нужны подпрограммы, также известные как функции.

Что такое процедурное программирование? Это одна из [**парадигм**](https://ru.wikipedia.org/wiki/Парадигма_программирования) разработки ПО. Под парадигмой понимается набор идей, методов и принципов, которые определяют способ написания программ.

Сегодня широко распространены и наиболее популярны две парадигмы:

1. Императивное программирование, когда разработчик явно указывает машине, как следует изменять её состояние. Другими словами задаётся полный алгоритм вычисления результата.

2. Декларативное программирование, когда разработчик указывает свойства желаемого результата, но не алгоритм его вычисления.

Язык Bash является императивным, то есть следует первой парадигме.

Императивная и декларативная парадигмы определяют общие принципы написания программы. У каждой из них есть производные парадигмы, которые предлагают конкретные приёмы и методики программирования. Так у императивного подхода есть две производные:

1. Процедурное программирование.

2. Объектно-ориентированное программирование.

Обе эти парадигмы предписывают, как следует структурировать исходный код программы. Bash следует первой из них, поэтому рассмотрим её подробнее.

В процедурном программировании язык предоставляет средства для объединения произвольных наборов команд в независимые блоки кода, называемые процедурами или функциями. Эти блоки могут быть вызваны из любого места программы. На вход они принимают параметры точно так же как и обычные скрипты. Поэтому иногда их называют подпрограммами, то есть программами в программе.

Какие проблемы решают функции? Их основная задача — это управление сложностью программы. Чем больше объём исходного кода, тем сложнее его сопровождать и поддерживать. Особенно ситуацию усугубляют повторяющиеся фрагменты кода. Рассмотрим пример.

Представьте, что вы пишете какую-то большую программу. Для обработки ошибок в ней вы решаете выводить текстовые сообщения в стандартный поток ошибок stderr. В программе появляется много мест с вызовом команды `echo` наподобие следующего:
{line-numbers: false, format: Bash}
```
>&2 echo "Произошла ошибка N"
```

В какой-то момент вы решаете, что будет лучше записывать все ошибки в файл. Тогда их станет легче анализировать. Конечно пользователи вашей программы могут сделать запись в файл сами с помощью перенаправления потоков. Но предположим, что не все умеют ими пользоваться. Поэтому ваша программа должна писать сообщения об ошибках в специальный файл, а не в консоль.

Чтобы внести это изменение, вам придётся пройти по всем местам в вашей программе, где происходит обработка ошибок. В каждом из них надо изменить вызов команды `echo`, например, на следующий:
{line-numbers: false, format: Bash}
```
echo "Произошла ошибка N" >> debug.log
```

Если по невнимательности вы пропустите и не измените какой-то вызов `echo`, его вывод не попадёт в лог-файл. Тогда, возможно, вы не сможете понять, почему ваша программа не работает так как надо у пользователя, который прислал вам файл с выводом ошибок.

Этот пример демонстрирует одну из сложностей сопровождения программы. Она заключается во внесении изменений в написанный ранее код. В нашем примере эта сложность возникла из-за нарушения принципа разработки [Don’t repeat yourself](https://ru.wikipedia.org/wiki/Don’t_repeat_yourself) или DRY (не повторяйся). Мы копировали один и тот же код вывода ошибок снова и снова в разные места программы. Так делать нельзя.

Функции решают проблему многократного копирования кода. Чем-то это решение напоминает циклы. Но цикл позволяет многократно исполнять одни и те же команды (тело цикла) только в одном месте программы — там где находится его конструкция. В отличие от этого функция позволяет исполнять одни и те же команды (тело функции) в разных местах программы.

Кроме проблемы дублирования кода функции решают задачу комментирования. Благодаря функции вы можете объединить несколько команд в один блок и дать ему говорящее название. Затем во всех местах программы этот блок будет вызываться по своему названию (как команда). Таким образом вашу программу будет намного проще читать и сопровождать. Вместо десятка строк тела функции, будет стоять её имя, объясняющее читателю, что в ней происходит.

### Функции в командном интерпретаторе

Вы можете использовать функции как при написании скриптов, так и при работе с Bash в режиме командного интерпретатора.

Для начала рассмотрим синтаксис объявления функции. В общем виде его можно записать следующим образом:
{line-numbers: true, format: Bash}
```
ИМЯ_ФУНКЦИИ()
{
    ДЕЙСТВИЕ
}
```

Это же самое объявление можно выполнить одной строкой так:
{line-numbers: false, format: Bash}
```
ИМЯ_ФУНКЦИИ() { ДЕЙСТВИЕ ; }
```

Обратите внимание на обязательную точку с запятой перед закрывающей фигурной скобкой `}`.

Точно так же как в условных конструкциях и циклах, тело функции (ДЕЙСТВИЕ) может быть одной командой или блоком команд.

На имена функций в Bash накладываются те же самые ограничения, что и на имена переменных. В них допустимы только символы латинского алфавита, числа и знак подчёркивания `_`. Имя не должно начинаться с числа.

Рассмотрим пример объявления и использования функции в командном интерпретаторе. Предположим, что вам необходимо прочитать статистику использования оперативной памяти. Для этого можно воспользоваться специальной файловой системой [**proc**](https://ru.wikipedia.org/wiki/Procfs). Она позволяет читать информацию о системе из ядра ОС. Эта информация доступна через файлы, находящихся по системному пути `/proc`.

Статистика использования оперативной памяти доступна в файле `/proc/meminfo`. Её можно прочитать следующей командой:
{line-numbers: false, format: Bash}
```
cat /proc/meminfo
```

В результате вы получите вывод наподобие следующего:
{line-numbers: true, format: Bash}
```
MemTotal:        6811124 kB
MemFree:         3550692 kB
HighTotal:             0 kB
HighFree:              0 kB
LowTotal:        6811124 kB
LowFree:         3550692 kB
SwapTotal:       1769472 kB
SwapFree:        1636168 kB
```

Этот вывод означает, что всего в системе доступно 6811124 Кбайт (6,8 Гбайт) оперативной памяти (первая строка `MemTotal`). Из них свободно только 3550692 Кбайт (3,5 Гбайт) памяти (вторая строка `MemFree`).

Объявим однострочную функцию с коротким именем, чтобы не набирать команду чтения файла `/proc/meminfo` каждый раз. Получится, например, следующее объявление:
{line-numbers: false, format: Bash}
```
mem() { cat /proc/meminfo; }
```

Теперь вы можете вызвать функцию `mem` точно так же как и любую команду интерпретатора и получить статистику использования памяти.

Чтобы удалить ставшую ненужной функцию, воспользуйтесь командой `unset`. Например так:
{line-numbers: false, format: Bash}
```
unset mem
```

Предположим, что вы объявили переменную и функцию с одинаковыми именами (например `mem` в нашем случае). Чтобы удалить именно функцию, а не переменную, надо воспользоваться опцией `-f` команды `unset`. Например:
{line-numbers: false, format: Bash}
```
unset -f mem
```

Вы можете добавлять объявления функций в файл `~/.bashrc` точно так же как и alias. Тогда они будут доступны при каждом запуске командной оболочке.

Мы рассмотрели однострочное объявление функции `mem`. Оно удобнее чем многострочное, если выполнять его в командном интерпретаторе. В файле `~/.bashrc` вам, возможно, будет удобнее объявить функцию в стандартном виде. Например так:
{line-numbers: true, format: Bash}
```
mem()
{
    cat /proc/meminfo
}
```

#### Отличие функций от alias

Может возникнуть вопрос: в чём отличие функции от alias? Если мы объявим следующий alias, получим то же самое поведение, какое дала нам функция `mem`:
{line-numbers: false, format: Bash}
```
alias mem="cat /proc/meminfo"
```

Прежде всего, и функции, и `alias` являются встроенными механизмами интерпретатора Bash. Отчасти их возможности пересекаются, когда вы работаете с Bash в режиме командного интерпретатора. Однако, принцип их работы совершенно различен.

Механизм `alias` представляет собой подстановку текста во введённой вами команде. Это означает, что Bash просто подставляет значение alias вместо части введённой вами команды.

Например, вы делаете следующее объявление alias, чтобы утилита `cat` всегда выводила номера строк по опции `-n`:
{line-numbers: false, format: Bash}
```
alias cat="cat -n"
```

В результате этого, каждый раз когда в команде встречается слово `cat`, Bash вместо него подставит `cat -n`. Например, вы вводите команду:
{line-numbers: false, format: Bash}
```
cat ~/.bashrc
```

После подстановки alias она станет выглядеть так:
{line-numbers: false, format: Bash}
```
cat -n ~/.bashrc
```

Было заменено только слово `cat` на `cat -n`. Следующий далее путь до файла остался без изменений.

Теперь рассмотрим, как работают функции. В отличие от alias тело функции не подставляется вместо её имени во введённую вами команду. Как только Bash встречает имя функции в команде, он вызывает её и начинает исполнять её тело. Рассмотрим пример.

Предположим, что вам с помощью функции надо получить точно такое же поведение, какое даёт рассмотренный выше alias для утилиты `cat`. Если бы функции работали так же как alias, мы могли бы сделать следующее определение:
{line-numbers: false, format: Bash}
```
cat() { cat -n; }
```

Теперь мы могли бы ожидать, что в следующей команде будет просто добавлен флаг `-n`:
{line-numbers: false, format: Bash}
```
cat ~/.bashrc
```

Но этого не произойдёт. Вместо подстановки будет выполнено тело функции, то есть вызвана команда `cat -n` без параметра. Это совершенно не то, что нам нужно.

Чтобы добиться правильного поведения, необходимо передать имя файла в функцию в качестве параметра. Это происходит точно так же, как передача параметров в команду или скрипт. Просто укажите список параметров, разделённых пробелами, после имени функции.

В общем виде передача параметров в вызываемую функцию выглядит так:
{line-numbers: false, format: Bash}
```
ИМЯ_ФУНКЦИИ ПАРАМЕТР1 ПАРАМЕТР2 ПАРАМЕТР3
```

Для доступа к параметрам в теле функции используйте позиционные параметры `$1`, `$2`, `$3` и т.д, а также специальный параметр `$@`.

Перепишем объявление нашей функции. Будем передавать в вызываемую утилиту `cat` все переданные в функцию параметры:
{line-numbers: false, format: Bash}
```
cat() { cat -n $@; }
```

К сожалению, такая функция не будет работать. Дело в том, что при выполнении её тела произойдёт **рекурсия**. Рекурсией называется вызов функции из неё же самой.

Bash перед выполнением команды `cat -n $@` проверяет список объявленных функций. В этом списке он найдёт функцию с именем `cat`, тело которой и выполняется в данный момент. В результате вместо вызова утилиты `cat` произойдёт вызов функции `cat`. Затем этот вызов будет повторяться снова и снова. Возникнет бесконечная рекурсия, которая похожа на бесконечный цикл.

Такое поведение отнюдь не является ошибкой в поведении интерпретатора. Рекурсия — это мощный механизм, который в некоторых случаях позволяет значительно упростить сложные алгоритмы (например обход [**графа**](https://ru.wikipedia.org/wiki/Граф_(математика)) или [**дерева**](https://ru.wikipedia.org/wiki/Дерево_(структура_данных))).

Проблема в том, что в нашей функции `cat` рекурсивный вызов произошел случайно и привел к зацикливанию. Решить эту проблему можно двумя способами:

1. Использовать ключевое слово `command`.

2. Переименовать функцию так, чтобы её имя не совпадало с именем утилиты.

Ключевое слово `command`, введённое перед командой, выключает подстановку alias и вызовы функций, имена которых встречаются в этой команде. С использованием `command` наша функция `cat` будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
cat() { command cat -n "$@"; }
```

Если же вы решили переименовать функцию, то результат может быть таким:
{line-numbers: false, format: Bash}
```
cat_func() { cat -n "$@"; }
```

Всегда помните о проблеме случайной рекурсии и старайтесь не давать своим функциям имена, конфликтующие с именами встроенных команд интерпретатора и стандартных GNU утилит.

Подведём итоги нашего сравнения функций и alias. Если вам нужно просто сократить длинную команду, используйте alias, а не функцию.

Функция будут удобнее alias в следующих случаях:

1. Если для выполнения какой-то операции требуются условные операторы, циклы или блок команд.

2. Если подставляемые параметры находятся в середине команды.

Примером параметров в середине команды может быть вызов утилиты `find`. Представьте, что вы хотите сократить команду поиска всех файлов в указанном каталоге. Для домашнего каталога пользователя эта команда выглядит так:
{line-numbers: false, format: Bash}
```
find ~ -type f
```

Вы не сможете параметризовать путь, используя alias. Например, следующий вариант не заработает, потому что путь должен идти до опции `-type`:
{line-numbers: false, format: Bash}
```
alias="find -type f"
```

Следующая функция легко справляется с этой проблемой благодаря параметру:
{line-numbers: false, format: Bash}
```
find_func() { find $1 -type f; }
```

### Функции в скриптах

В скриптах функции объявляются так же, как и в командном интерпретаторе. Допустимы многострочный и однострочный варианты.

Для примера рассмотрим упомянутую раннее проблему с выводом сообщений об ошибках в большой программе. Функция вывода такого сообщения в консоль могла бы выглядеть следующим образом:
{line-numbers: true, format: Bash}
```
print_error()
{
    >&2 echo "Произошла ошибка: $@"
}
```

В качестве параметра в эту функцию передаётся текст, объясняющий суть ошибки. Например, если программа не находит какой-то файл, она может вывести сообщение об этом следующим образом:
{line-numbers: false, format: Bash}
```
print_error "файл readme.txt не найден"
```

Теперь, предположим, что требования к программе изменились и нужно выводить все сообщения об ошибках в лог-файл. Всё что необходимо сделать для этого — изменить объявление функции `print_error`. Команду `echo` в теле функции мы заменим так:
{line-numbers: true, format: Bash}
```
print_error()
{
    echo "Произошла ошибка: $@" >> debug.log
}
```

После этого все вызовы функции будут выводить сообщения об ошибках в файл `debug.log`. Вам нет необходимости менять что-либо в местах вызова `print_error`.

Иногда может понадобиться, чтобы одна функция вызывала другую. Это допустимо, поскольку в общем случае функция может вызвана из любого места программы.

Для примера представьте, что вам необходимо перевести интерфейс пользователя вашей программы на другой язык, то есть выполнить её [**локализацию**](https://ru.wikipedia.org/wiki/Локализация_программного_обеспечения). Теперь сообщения об ошибках должны выводится на языке, понятном пользователю. Это значит, что вам придётся продублировать текст всех сообщений на всех языках, поддерживаемых вашей программой. Как это можно сделать?

Самый простой и прямолинейный способ заключается в присваивании каждой ошибке уникального кода. Такая практика часто встречается в системном программировании. Если мы применим этот подход в нашей программе, то функция `print_error` в качестве параметра будет принимать код ошибки. Далее, чтобы вывести соответствующее сообщение необходимо конвертировать код в текст на определённом языке. Для этой задачи можно объявить специальную функцию.

Начнём с функции конвертирования кода ошибки в сообщение. Для решения этой задачи можно воспользоваться оператором `case`. Тогда каждый блок `case` будет соответствовать определённому коду ошибки. Объявление такой функции может выглядеть так:
{line-numbers: true, format: Bash}
```
code_to_error()
{
  case $1 in
    1)  
      echo "Не найден файл"
      ;;  
    2)  
      echo "Нет прав для чтения файла"
      ;;  
  esac
}
```

Тогда объявлении функции `print_error` необходимо переписать таким образом:
{line-numbers: true, format: Bash}
```
print_error()
{
  echo "$(code_to_error $1) $2" >> debug.log
}
```

Теперь вызов функции `print_error` для вывода сообщения об ошибке будет выглядеть так:
{line-numbers: false, format: Bash}
```
print_error 1 "readme.txt"
```

Первым параметром мы передаём в функцию код ошибки, а вторым — имя файла, который привёл к проблеме. В результате такого вызова, получим сдедующий вывод:
{line-numbers: false, format: text}
```
Не найден файл readme.txt
```

Теперь сопровождать сообщения об ошибках стало значительно проще. Если вам необходим вывод на другом языке, вы можете сделать две функции: `code_to_error_ru` для сообщений на русском и `code_to_error_en` для сообщений на английском. Выбор между ними может происходить в функции `print_error` в зависимости от значения переменной окружения `LANGUAGE`. Если переменная `LANGUAGE` недоступна в вашей системе, используйте переменную `LANG`.

На самом деле Bash предоставляет встроенный механизм для локализации скриптов. В нём используются PO-файлы с текстами на разных языках. Подробнее об этом механизме читайте в [статье BashFAQ](https://mywiki.wooledge.org/BashFAQ/098?highlight=(Localization)).

{caption: "Упражнение 3-13. Использование функций", format: text, line-numbers: false}
```
Напишите функции print_error, code_to_error_ru и code_to_error_en для вывода сообщений об ошибках на русском и английском языках. Попробуйте два варианта реализации: с оператором case и с массивом.
```

#### Возврат значения из функции

Функции в Bash, в отличие от большинства других процедурных языков, не могут возвращать произвольное значение. Вместо этого они могут вернуть только код возврата, то есть целочисленное значение от 0 до 255.

В общем виде алгоритм выполнения функции выглядит следующим образом:

1. В ходе выполнения программы встречается имя функции. 

2. Происходит переход на тело функции, которое исполняется с первой команды или инструкции.

3. Если последней командой в теле функции является `return`, то функция вернёт переданное в эту команду значение.

4. После выполнения последней команды в теле функции, происходит переход обратно в место её вызова. Если функция вернула значение, оно может быть присвоено переменной.

В других языках ключевое слово `return` позволяет вернуть переменную любого типа: число, строку или массив. Как можно добиться аналогичного поведения в Bash?

В нашем примере функции `print_error` для вывода сообщения об ошибке мы использовали подстановку команд. В этом случае функция `code_to_error` печатала на консоль строку с помощью команды `echo`. Далее в `print_error` происходила подстановка этой напечатанной строки в финальный вызов команды `echo`, который и выводил сообщение в лог-файл.

Второй способ вернуть значение из функции — воспользоваться глобальной в области видимости скрипта переменной. Такая переменная доступная в любой месте скрипта. По умолчанию все переменные, объявленные в скрипте вне тел функций являются глобальными.

Перепишем наши функции `code_to_error` и `print_error` с помощью глобальной переменной. Получится следующий результат:
{line-numbers: true, format: Bash}
```
code_to_error()
{
  case $1 in
    1)
      error_text="Не найден файл"
      ;;
    2)
      error_text="Нет прав для чтения файла"
      ;;
  esac
}

print_error()
{
  code_to_error $1
  echo "$error_text $2" >> debug.log
}
```

Результат работы функции `code_to_error` сохраняется в переменной `error_text`. Затем её значение подставляется в команду `echo` в функции `print_error` для вывода сообщения в лог-файл.

Использование глобальных переменных для возврата значений из функций чревато ошибками. Может возникнуть конфликт имён, который впоследствии будет сложно выявить. Представьте, например, что переменная с именем `error_text` используется в вашей программе для совершенно других целей, не связанных с выводом в лог-файл. Тогда любой вызов функции `code_to_error` перезапишет значение этой переменной. Оно будет утеряно и это может привести к серьёзной ошибке.

Чтобы решить проблему конфликта имён, вы можете использовать соглашение об именовании переменных. Например, все переменные в вашей программе, которые используются функциями для возврата значений, должны иметь в качестве префикса знак подчёркивания `_`. Тогда в нашем примере переменную `error_text` следует переименовать на `_error_text`. Это решит проблему, но лишь отчасти. Что делать, если происходят вложенные вызовы функций (одна функция вызывается из другой) и в них случайно используются переменные с одинаковыми именами для возврата значений?

Третий способ вернуть значение из функции решает проблему конфликта имён. В нём имя глобальной переменной, через которую функция возвращает своё значение, задаётся в качестве параметра функции. Другими словами вызывающая сторона указывает функции, в какой переменной ей следует сохранить свой результат. Для этого решения необходимо использовать встроенную команду `eval`.

Перепишем функции `code_to_error` и `print_error` следующим образом:
{line-numbers: true, format: Bash}
```
code_to_error()
{
  local _result_variable=$2

  case $1 in
    1)
      eval $_result_variable="'Не найден файл'"
      ;;
    2)
      eval $_result_variable="'Нет прав для чтения файла'"
      ;;
  esac
}

print_error()
{
  code_to_error $1 "error_text"
  echo "$error_text $2" >> debug.log
}
```

На первый взгляд этот код мало отличается от предыдущего варианта, когда функция `code_to_error` всегда сохраняла свой результат в глобальной переменной `error_text`. Но на самом деле, этот код даёт дополнительную гибкость. Теперь вызывающая сторона может выбрать произвольное имя для глобальной переменной, в которой будет сохранён результат. Это имя явно указывается в коде вызова. Благодаря этому, вероятность возникновения конфликта имён значительно меньше.

#### Область видимости переменных

Конфликт имён — это серьёзная проблема, которая возникает всякий раз при использовании глобальных переменных и функций. Разные языки программирования предоставляют разные средства для ограничения области видимости переменных. В целом для всех процедурных языков справедлива рекомендация избегать глобальных переменных. К сожалению, в Bash очень сложно следовать этой рекомендации.

Практически всегда при объявлении переменной в Bash она попадает в глобальную область видимости. Однако функции позволяют исправить эту ситуацию.

Ключевое слово `local` ограничивают область видимости переменной телом функции. Рассмотрим наш последний вариант объявления `code_to_error`:
{line-numbers: true, format: Bash}
```
code_to_error()
{
  local _result_variable=$2

  case $1 in
    1)
      eval $_result_variable="'Не найден файл'"
      ;;
    2)
      eval $_result_variable="'Нет прав для чтения файла'"
      ;;
  esac
}
```

Здесь переменная `_result_variable` объявлена как локальная. Это значит, что она будет недоступна в любом месте скрипта кроме тела функции `code_to_error`. Такое ограничение области видимости гарантирует вам, что в функции не будет перезаписано значение одноимённой глобальной переменной.

С другой стороны объявление локальных переменных может стать причиной ошибки. Дело в том, что локальные переменные скрывают глобальные переменные с теми же именами. Рассмотрим пример.

Предположим, что вы пишете функцию для обработки файла. Например, она проверяет, встречается ли в файле какой-то шаблон. Функция может выглядеть следующим образом:
{line-numbers: true, format: Bash}
```
check_license()
{
    local filename="$1"
    grep "General Public License" "$filename"
}
```

Теперь допустим, что начало скрипта выглядит следующим образом:
{line-numbers: true, format: Bash}
```
#!/bin/bash

filename="$1"
```

То есть переданный в скрипт первый параметр сохраняется в переменной `filename`. Что произойдёт в этом случае в функции `check_license`? Она будет работать корректно, потому что произойдёт **сокрытие глобальной переменной**. То есть локальная переменная будет подставлена при любом обращении из функции к имени `filename`. Это означает, что в теле функции нет никакого способа получить доступ к глобальной переменной `filename`.

Если сокрытие переменных происходит случайно, это приведёт к ошибке. Поэтому чтобы избегать даже возможности такой ситуации всегда используйте префикс или постфикс для локальных переменных функций. Это может быть символ подчёркивания `_` или любой другой.

На самом деле глобальная переменная становится недоступна только после объявления локальной переменной с тем же именем. Рассмотрим следующий вариант функции `check_license`:
{line-numbers: true, format: Bash}
```
#!/bin/bash

filename="$1"

check_license()
{
    local filename="$filename"
    grep "General Public License" "$filename"
}
```

В этом случае локальной переменной `filename` будет корректно присвоено значение глобальной переменной с тем же именем. Это произойдёт, потому что подстановка переменных выполняется до операции присваивания. То есть в момент присваивания подставляется значение позиционного параметра `$1`, переданного в скрипт. Если, например, в скрипт было передано имя файла `README`, то присваивание будет выглядеть так:
{line-numbers: false, format: Bash}
```
    local filename="README"
```

В Bash начиная с версии 4.2 индексируемые и ассоциативные массивы, объявленные в функции, по умолчанию попадают в локальную область видимости. Чтобы объявить массив глобальным, необходимо использовать опцию `-g` команды `declare`.

Например, в следующем примере массив `files` будет локальным:
{line-numbers: true, format: Bash}
```
check_license()
{
    declare files=(Documents/*.txt)
    grep "General Public License" "$files"
}
```

В следующем случае массив попадёт в глобальную область видимости скрипта и будет доступен вне тела функции:
{line-numbers: true, format: Bash}
```
check_license()
{
    declare -g files=(Documents/*.txt)
    grep "General Public License" "$files"
}
```

Резюмируем наше знакомство с функциями следующими общими рекомендациями:

1. Тщательно выбираёте имена для функций. Они должны сообщать читателю, что делает соответствующая функция.

2. Все переменные, объявленные в функции должны быть локальными. В именах этих переменных используйте префикс или постфикс, чтобы избежать конфликтов с глобальными переменными.

3. Избегайте использование глобальных переменных в функциях. Предпочитайте передавать глобальную переменную в функцию в качестве параметра, а не использовать её напрямую.

4. Не используйте ключевое слово `function` при объявлении переменных. Например, следующий вариант объявления не рекомендуется:
{line-numbers: true, format: Bash}
```
function check_license()
{
    declare files=(Documents/*.txt)
    grep "General Public License" "$files"
}
```
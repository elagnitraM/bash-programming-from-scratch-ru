## Функции

Bash относится к [**процедурным языкам программирования**](https://ru.wikipedia.org/wiki/Процедурное_программирование), поэтому в нём есть функции. Мы уже сталкивались с ними, когда знакомились с переменными и командой `declare`. Теперь рассмотрим подробнее, что представляют собой функции.

### Парадигмы программирования

Перед тем как начать знакомство с функциями, разберёмся с терминологией. Она поможет нам понять, зачем вообще нужны подпрограммы, также известные как функции.

Что такое процедурное программирование? Это одна из [**парадигм**](https://ru.wikipedia.org/wiki/Парадигма_программирования) разработки ПО. Под парадигмой понимается набор идей, методов и принципов, которые определяют способ написания программ.

Сегодня широко распространены и наиболее популярны две парадигмы:

1. Императивное программирование, когда разработчик явно указывает машине, как следует изменять её состояние. Другими словами задаётся полный алгоритм вычисления результата.

2. Декларативное программирование, когда разработчик указывает свойства желаемого результата, но не алгоритм его вычисления.

Язык Bash является императивным, то есть следует первой парадигме.

Императивная и декларативная парадигмы определяют общие принципы написания программы. У каждой из них есть производные парадигмы, которые предлагают конкретные приёмы и методики программирования. Так у императивного подхода есть две производные:

1. Процедурное программирование.

2. Объектно-ориентированное программирование.

Обе эти парадигмы предписывают, как следует структурировать исходный код программы. Bash следует первой из них, поэтому рассмотрим её подробнее.

В процедурном программировании язык предоставляет средства для объединения произвольных наборов команд в независимые блоки кода, называемые процедурами или функциями. Эти блоки могут быть вызваны из любого места программы. На вход они принимают параметры точно так же как и обычные скрипты. Поэтому иногда их называют подпрограммами, то есть программами в программе.

Какие проблемы решают функции? Их основная задача — это управление сложностью программы. Чем больше объём исходного кода, тем сложнее его сопровождать и поддерживать. Особенно ситуацию усугубляют повторяющиеся фрагменты кода. Рассмотрим пример.

Представьте, что вы пишете какую-то большую программу. Для обработки ошибок в ней вы решаете выводить текстовые сообщения в стандартный поток ошибок stderr. В программе появляется много мест с вызовом команды `echo` наподобие следующего:
{line-numbers: false, format: Bash}
```
>&2 echo "Произошла ошибка N"
```

В какой-то момент вы решаете, что будет лучше записывать все ошибки в файл. Тогда их станет легче анализировать. Конечно пользователи вашей программы могут сделать запись в файл сами с помощью перенаправления потоков. Но предположим, что не все умеют ими пользоваться. Поэтому ваша программа должна писать сообщения об ошибках в специальный файл, а не в консоль.

Чтобы внести это изменение, вам придётся пройти по всем местам в вашей программе, где происходит обработка ошибок. В каждом из них надо изменить вызов команды `echo`, например, на следующий:
{line-numbers: false, format: Bash}
```
echo "Произошла ошибка N" >> debug.log
```

Если по невнимательности вы пропустите какой-то вызов `echo` и не измените, его вывод не попадёт в лог-файл. Тогда, возможно, вы не сможете понять, почему ваша программа не работает так как надо у пользователя, который прислал вам файл с выводом ошибок.

Этот пример демонстрирует одну из сложностей сопровождения программы. Она заключается во внесении изменений в написанный ранее код. В нашем примере эта сложность возникла из-за нарушения принципа разработки [Don’t repeat yourself](https://ru.wikipedia.org/wiki/Don’t_repeat_yourself) или DRY (не повторяйся). Мы копировали один и тот же код вывода ошибок снова и снова в разные места программы. Так делать нельзя.

Функции решают проблему многократного копирования кода. Чем-то это решение напоминает циклы. Но цикл позволяет многократно исполнять одни и те же команды (тело цикла) только в одном месте программы — там где находится его конструкция. В отличие от этого функция позволяет исполнять одни и те же команды (тело функции) в разных местах программы.

Кроме проблемы дублирования кода функции решают задачу комментирования. Благодаря функции вы можете объединить несколько команд в один блок и дать ему говорящее название. Затем во всех местах программы этот блок будет вызываться по своему названию (как команда). Таким образом вашу программу будет намного проще читать и сопровождать. Вместо десятка строк тела функции, будет стоять её имя, объясняющее читателю, что в ней происходит.

### Функции в командном интерпретаторе

Вы можете использовать функции как при написании скриптов, так и при работе с Bash в режиме командного интерпретатора.

Для начала рассмотрим синтаксис объявления функции. В общем виде его можно записать следующим образом:
{line-numbers: true, format: Bash}
```
ИМЯ_ФУНКЦИИ()
{
    ДЕЙСТВИЕ
}
```

Это же самое объявление можно выполнить одной строкой так:
{line-numbers: false, format: Bash}
```
ИМЯ_ФУНКЦИИ() { ДЕЙСТВИЕ ; }
```

Обратите внимание на обязательную точку с запятой перед закрывающей фигурной скобкой `}`.

Точно так же как в условных конструкциях и циклах, тело функции (ДЕЙСТВИЕ) может быть одной командой или блоком команд.

На имена функций в Bash накладываются те же самые ограничения, что и на имена переменных. В них допустимы только символы латинского алфавита, числа и знак подчёркивания `_`. Имя не должно начинаться с числа.

Рассмотрим пример. Предположим, что вам необходимо прочитать статистику использования оперативной памяти. Для этого можно воспользоваться специальной файловой системой [**proc**](https://ru.wikipedia.org/wiki/Procfs). Она позволяет читать информацию о системе из ядра ОС. Эта информация доступна через файлы, находящихся по системному пути `/proc`.

Статистика использования оперативной памяти доступна в файле `/proc/meminfo`. Её можно прочитать следующей командой:
{line-numbers: false, format: Bash}
```
cat /proc/meminfo
```

В результате вы получите вывод наподобие следующего:
{line-numbers: true, format: Bash}
```
MemTotal:        6811124 kB
MemFree:         3550692 kB
HighTotal:             0 kB
HighFree:              0 kB
LowTotal:        6811124 kB
LowFree:         3550692 kB
SwapTotal:       1769472 kB
SwapFree:        1636168 kB
```

Этот вывод означает, что всего в системе доступно 6811124 Кбайт (6,8 Гбайт) оперативной памяти (первая строка `MemTotal`). Из них свободно только 3550692 Кбайт (3,5 Гбайт) памяти (вторая строка `MemFree`).

Объявим однострочную функцию с коротким именем, чтобы не набирать команду чтения файла `/proc/meminfo` каждый раз. Получим следующее объявление:
{line-numbers: false, format: Bash}
```
mem() { cat /proc/meminfo; }
```

Теперь вы можете вызвать функцию `mem` точно так же как и любую команду интерпретатора и получить статистику использования памяти.

Чтобы удалить ставшую ненужной функцию, воспользуйтесь командой `unset`. Например так:
{line-numbers: false, format: Bash}
```
unset mem
```

Предположим, что вы объявили переменную и функцию с одинаковыми именами (например `mem` в нашем случае). Чтобы удалить именно функцию, а не переменную, надо воспользоваться опцией `-f` команды `unset`. Например:
{line-numbers: false, format: Bash}
```
unset -f mem
```

Вы можете добавлять объявления функций в файл `~/.bashrc` точно так же как и alias. Тогда они будут доступны при каждом запуске командной оболочке.

Мы рассмотрели однострочное объявление функции `mem`. Оно удобнее чем многострочное, если выполнять его в командном интерпретаторе. В файле `~/.bashrc` вам, возможно, будет удобнее объявить функцию в стандартном виде. Например так:
{line-numbers: true, format: Bash}
```
mem()
{
    cat /proc/meminfo
}
```

#### Отличие функций от alias

Может возникнуть вопрос: в чём отличие функции от alias? Если мы объявим следующий alias, получим то же самое поведение, какое дала нам функция `mem`:
{line-numbers: false, format: Bash}
```
alias mem="cat /proc/meminfo"
```

Прежде всего, и функции, и `alias` являются встроенными механизмами интерпретатора Bash. Отчасти их возможности пересекаются, когда вы работаете с Bash в режиме командного интерпретатора. Однако, принцип их работы совершенно различен.

Механизм `alias` представляет собой подстановку текста во введённой вами команде. Это означает, что Bash просто подставляет значение alias вместо части введённой вами команды.

Например, вы делаете следующее объявление alias, чтобы утилита `cat` всегда выводила номера строк по опции `-n`:
{line-numbers: false, format: Bash}
```
alias cat="cat -n"
```

В результате этого, каждый раз когда в команде встречается слово `cat`, Bash вместо него подставит `cat -n`. Например, вы вводите команду:
{line-numbers: false, format: Bash}
```
cat ~/.bashrc
```

После подстановки alias она станет выглядеть так:
{line-numbers: false, format: Bash}
```
cat -n ~/.bashrc
```

Было заменено только слово `cat` на `cat -n`. Следующий далее путь до файла остался без изменений.

Теперь рассмотрим, как работают функции. В отличие от alias тело функции не подставляется вместо её имени во введённую вами команду. Как только Bash встречает имя функции в команде, он вызывает её и начинает исполнять её тело. Рассмотрим пример.

Предположим, что вам с помощью функции надо получить точно такое же поведение, какое даёт рассмотренный выше alias для утилиты `cat`. Если бы функции работали так же как alias, мы могли бы сделать следующее определение:
{line-numbers: false, format: Bash}
```
cat() { cat -n; }
```

Теперь мы могли бы ожидать, что в следующей команде будет просто добавлен флаг `-n`:
{line-numbers: false, format: Bash}
```
cat ~/.bashrc
```

Но этого не произойдёт. Вместо подстановки будет выполнено тело функции, то есть вызвана команда `cat -n` без параметра. Это совершенно не то, что нам нужно.

Чтобы добиться правильного поведения, необходимо передать имя файла в функцию в качестве параметра. Это происходит точно так же, как передача параметров в команду или скрипт. Просто укажите список параметров, разделённых пробелами, после имени функции.

В общем виде передача параметров в вызываемую функцию выглядит так:
{line-numbers: false, format: Bash}
```
ИМЯ_ФУНКЦИИ ПАРАМЕТР1 ПАРАМЕТР2 ПАРАМЕТР3
```

Для доступа к параметрам в теле функции используйте позиционные параметры `$1`, `$2`, `$3` и т.д, а также специальный параметр `$@`.

Перепишем объявление нашей функции. Будем передавать в вызываемую утилиту `cat` все переданные в функцию параметры:
{line-numbers: false, format: Bash}
```
cat() { cat -n $@; }
```

К сожалению, такая функция не будет работать. Дело в том, что при выполнении её тела произойдёт **рекурсия**. Рекурсия в данном случае означает вызов функции из неё же самой.

Bash перед выполнением команды `cat -n $@` проверяет список объявленных функций. В этом списке он найдёт функцию с именем `cat`, тело которой и выполняется в данный момент. В результате вместо вызова утилиты `cat` произойдёт вызов функции `cat`. Затем этот вызов будет повторяться снова и снова. Возникнет бесконечная рекурсия, которая похожа на бесконечный цикл.

Такое поведение отнюдь не является ошибкой в поведении интерпретатора. Рекурсия — это мощный механизм, который в некоторых случаях позволяет значительно упростить сложные алгоритмы (например обход [графа](https://ru.wikipedia.org/wiki/Граф_(математика)) или [дерева](https://ru.wikipedia.org/wiki/Дерево_(структура_данных))).

Проблема в том, что в нашей функции `cat` рекурсивный вызов произошел случайно и привел к зацикливанию. Решить эту проблему можно двумя способами:

1. Использовать ключевое слово `command`.

2. Переименовать функцию так, чтобы её имя не совпадало с именем утилиты.

Ключевое слово `command`, введённое перед командой, выключает подстановку alias и вызов функций, имена которых встречаются в этой команде. С использованием `command` наша функция `cat` будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
cat() { command cat -n "$@"; }
```

Если же вы решили переименовать функцию, то результат может быть таким:
{line-numbers: false, format: Bash}
```
cat_func() { cat -n "$@"; }
```

Всегда помните о проблеме случайной рекурсии и старайтесь не давать своим функциям имена, конфликтующие с именами встроенных команд интерпретатора и стандартных GNU утилит.

Подведём итоги нашего сравнения функций и alias. Если вам нужно просто сократить длинную команду, используйте alias, а не функцию.

Функция будут удобнее alias в следующих случаях:

1. Если для выполнения какой-то операции требуются условные операторы, циклы или блок команд.

2. Если подставляемые параметры находятся в середине команды.

Примером параметров в середине команды служит вызов утилиты `find`. Представьте, что вы хотите сократить команду поиска всех файлов в указанном каталоге. Для домашнего каталога пользователя команда выглядит так:
{line-numbers: false, format: Bash}
```
find ~ -type f
```

Вы не сможете параметризовать путь, используя alias. Например, следующий вариант не заработает, потому что путь должен идти до опции `-type`:
{line-numbers: false, format: Bash}
```
alias="find -type f"
```

Следующая функция легко справляется с этой проблемой благодаря параметру:
{line-numbers: false, format: Bash}
```
find_func() { find $1 -type f; }
```

### Функции в скриптах

В скриптах функции объявляются так же, как и в командном интерпретаторе. Допустимы многострочный и однострочный варианты.

Для примера рассмотрим упомянутую раннее проблему с выводом сообщений об ошибках в большой программе. Функция вывода такого сообщения в консоль могла бы выглядеть следующим образом:
{line-numbers: true, format: Bash}
```
print_error()
{
    >&2 echo "Произошла ошибка: $@"
}
```

В качестве параметра в эту функцию передаётся текст, объясняющий суть ошибки. Например, если программа не находит какой-то файл, она может вывести сообщение об этом следующим образом:
{line-numbers: false, format: Bash}
```
print_error "файл readme.txt не найден"
```

Теперь, предположим, что требования к программе изменились и нужно выводить все сообщения об ошибках в лог-файл. Всё что необходимо сделать для этого — изменить объявление функции `print_error`. Одну строчку в теле функции мы заменим так:
{line-numbers: true, format: Bash}
```
print_error()
{
    echo "Произошла ошибка: $@" >> debug.log
}
```

После этого все вызовы функции будут выводить сообщения об ошибках в файл `debug.log`. Вам нет необходимости менять что-либо в местах вызова `print_error`.

Иногда может понадобиться, чтобы одна функция вызывала другую. Это допустимо, поскольку в общем случае функция может вызвана из любого места программы.

Для примера представьте, что вам необходимо перевести интерфейс пользователя вашей программы на другой язык, то есть выполнить её [**локализацию**](https://ru.wikipedia.org/wiki/Локализация_программного_обеспечения). Теперь сообщения об ошибках должны выводится на языке, понятном пользователю. Это значит, что вам придётся продублировать текст всех сообщений на всех языках, поддерживаемых вашей программой. Как это можно сделать?

Самый простой и прямолинейный способ заключается в присваивании каждой ошибке уникального кода. Такая практика часто встречается в системном программировании. Если мы применим этот подход в нашей программе, то функция `print_error` в качестве параметра будет принимать код ошибки. Далее, чтобы вывести соответствующее сообщение необходимо конвертировать код в текст на определённом языке. Для этой задачи можно объявить специальную функцию.

Начнём с функции конвертирования кода ошибки в сообщение. Для решения этой задачи можно воспользоваться оператором `case`. Тогда каждый блок `case` будет соответствовать определённому коду ошибки. Объявление такой функции может выглядеть так:
{line-numbers: true, format: Bash}
```
code_to_error()
{
  case $1 in
    1)  
      echo "Не найден файл"
      ;;  
    2)  
      echo "Нет прав для чтения файла"
      ;;  
  esac
}
```

Тогда объявлении функции `print_error` необходимо переписать таким образом:
{line-numbers: true, format: Bash}
```
print_error()
{
  echo "$(code_to_error $1) $2" >> debug.log
}
```

Теперь вызов функции `print_error` для вывода сообщения об ошибке будет выглядеть так:
{line-numbers: false, format: Bash}
```
print_error 1 "readme.txt"
```

Первым параметром мы передаём в функцию код ошибки, а вторым — имя файла, который привёл к проблеме. В результате такого вызова, получим сдедующий вывод:
{line-numbers: false, format: text}
```
Не найден файл readme.txt
```

Теперь сопровождать сообщения об ошибках стало значительно проще. Если вам необходим вывод на другом языке, вы можете сделать две функции: `code_to_error_ru` для сообщений на русском и `code_to_error_en` для сообщений на английском. Выбор между ними может происходить в функции `print_error` в зависимости от значения переменной окружения `LANGUAGE`. Если переменная `LANGUAGE` недоступна в вашей системе, используйте переменную `LANG`.

На самом деле Bash предоставляет встроенный механизм для локализации скриптов. В нём используются PO-файлы с текстами на разных языках. Подробнее об этом механизме читайте в [статье BashFAQ](https://mywiki.wooledge.org/BashFAQ/098?highlight=(Localization)).

// TODO: Упражнение: реализовать скрипт с выводом сообщений на русском и английском. Сделать вариант скрипта с оператором case и вариант с массивом. В решении дать пример ассоциативного массива.

#### Возврат значения из функции

// TODO
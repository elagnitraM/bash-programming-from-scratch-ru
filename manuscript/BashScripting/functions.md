## Функции

Bash относится к [**процедурным языкам программирования**](https://ru.wikipedia.org/wiki/Процедурное_программирование). Процедурные языки позволяют разделить программу на логические части — **подпрограммы**. Подпрограмма — это самостоятельный блок кода, который решает конкретную задачу. Подпрограммы вызываются из основной программы.

В современных языках подпрограммы называются **функциями**. Мы уже сталкивались с ними, когда знакомились с командой declare. Теперь рассмотрим подробнее, как функции устроены и для чего нужны.

### Парадигмы программирования

Для начала разберёмся с терминологией. Она поможет понять, зачем вообще нужны функции.

Что такое процедурное программирование? Это одна из [**парадигм**](https://ru.wikipedia.org/wiki/Парадигма_программирования) разработки ПО. Парадигма — это набор идей, методов и принципов, которые определяют способ написания программ.

Современные языки следуют одной из двух доминирующих сегодня парадигм:

1. Императивное программирование. Разработчик явно указывает машине, как ей изменять своё состояние. Другими словами он задаёт полный алгоритм вычисления результата.

2. Декларативное программирование. Разработчик указывает свойства желаемого результата, но не алгоритм его вычисления.

Bash следует первой парадигме. Это императивный язык.

Императивная и декларативная парадигмы определяют общие принципы написания программы. В рамках одной парадигмы есть различные методологии (подходы). Методология предлагает конкретные приёмы программирования. Так у императивной парадигмы есть две основных методологии:

1. Процедурное программирование.

2. Объектно-ориентированное программирование.

Эти методологии предлагают по-разному структурировать исходный код программы. Bash следует первой методологии. 

Рассмотрим процедурное программирование подробнее. Процедурный язык предоставляет средства для объединения наборов команд в независимые блоки кода. Эти блоки кода называются процедурами или функциями. Функцию можно вызвать из любого места программы. На вход она принимает параметры. Этот механизм похож на передачу параметров командной строки в скрипт. Поэтому функцию иногда называют программой в программе или подпрограммой.

Основная задача функций — управление сложностью программ. Чем больше объём исходного кода, тем сложнее его сопровождать и поддерживать в рабочем состоянии. Ситуацию усугубляют повторяющиеся фрагменты кода. Они разбросаны по всей программе и могут содержать ошибки. После исправления ошибки в одном таком фрагменте, надо найти и исправить все остальные. Если фрагмент вынести в функцию, то достаточно исправить ошибку только в ней.

Рассмотрим пример повторяющегося фрагмента кода. Представьте, что вы пишете большую программу. Чтобы обработать ошибки, программа выводит в поток ошибок текстовые сообщения. Тогда в исходном коде появится много мест с вызовом команды echo. Например, таких:
{line-numbers: false, format: Bash}
```
>&2 echo "Произошла ошибка N"
```

В какой-то момент вы решаете, что лучше записывать все ошибки в файл. Тогда анализировать их станет легче. Пользователи вашей программы могут перенаправить поток ошибок в лог-файл сами. Но, предположим, что не все умеют пользоваться перенаправлением. Поэтому программа должна сама писать сообщения в лог-файл.

Внесём изменение в программу. Для этого нужно пройти по всем местам обработки ошибок. Каждый вызов команды echo надо заменить на следующий:
{line-numbers: false, format: Bash}
```
echo "Произошла ошибка N" >> debug.log
```

Если по невнимательности пропустить и не исправить какой-то вызов echo, его вывод не попадёт в лог-файл. Этот вывод может оказаться важным. Без него вы не поймёте, почему программа не работает у пользователя.

Мы рассмотрели одну из сложностей сопровождения программ. Она часто встречается при изменении кода, написанного ранее. В нашем примере проблема возникла из-за нарушения принципа разработки "не повторяйся" ([**don’t repeat yourself**](https://ru.wikipedia.org/wiki/Don’t_repeat_yourself) или DRY). Один и тот же код вывода ошибок копировался снова и снова в разные места программы. Так делать нельзя.

Функции решают проблему дублирования кода. Чем-то это решение напоминает циклы. Отличие в том, что цикл многократно исполняет набор команд в одном месте программы. В отличие от цикла функция позволяет исполнять одни и те же команды в разных местах программы.

Функция улучшит читаемость кода программы. Она объединяет набор команд в единый блок. Если дать блоку говорящее имя, станет очевидна решаемая им задача. В программе функция вызывается по своему имени. Благодаря этому, программу станет легче читать. Вместо десятка строк тела функции, будет стоять её имя. Оно объяснит читателю, что происходит в функции.

### Функции в командном интерпретаторе

Функции доступны в обоих режимах Bash: командный интерпретатор и исполнение скриптов. Начнём с командного интерпретатора.

В общем виде функция объявляется так:
{line-numbers: true, format: Bash}
```
ИМЯ_ФУНКЦИИ()
{
    ДЕЙСТВИЕ
}
```

В одну строку функцию можно объявить так:
{line-numbers: false, format: Bash}
```
ИМЯ_ФУНКЦИИ() { ДЕЙСТВИЕ ; }
```

Обратите внимание на обязательную точку с запятой перед закрывающей фигурной скобкой }.

Тело функции ДЕЙСТВИЕ может быть одной командой или блоком команд.

На имена функций в Bash накладываются те же ограничения, что и на имена переменных. В них допустимы только символы латинского алфавита, числа и знак подчёркивания _. Имя не должно начинаться с числа.

Рассмотрим, как объявлять и использовать функции в командном интерпретаторе. Предположим, вам нужна статистика использования оперативной памяти. Эта информация доступна через файловую систему [**proc**](https://ru.wikipedia.org/wiki/Procfs) или procfs. Через proc можно узнать список работающих процессов, состояние ОС и оборудования компьютера. Эта информация доступна через файлы, находящихся по системному пути `/proc`.

Статистика использования оперативной памяти доступна в файле `/proc/meminfo`. Прочитаем его с помощью утилиты cat:
{line-numbers: false, format: Bash}
```
cat /proc/meminfo
```

Вывод команды зависит от вашей системы. Для окружения MSYS2 он даст меньше информации, для Linux-системы — больше. 

Для MSYS2 содержимое файла `meminfo` будет примерно таким:
{line-numbers: true, format: Bash}
```
MemTotal:        6811124 kB
MemFree:         3550692 kB
HighTotal:             0 kB
HighFree:              0 kB
LowTotal:        6811124 kB
LowFree:         3550692 kB
SwapTotal:       1769472 kB
SwapFree:        1636168 kB
```

Таблица 3-22 объясняет значение каждого поля.

{caption: "Таблица 3-22. Поля в файле `meminfo`", width: "100%"}
| Поле | Значение |
| --- | --- |
| MemTotal | Объём доступной в системе RAM. |
| MemFree | Объём не используемой в данный момент RAM. Считается как LowFree + HighFree. |
| HighTotal | Объём доступной памяти в области RAM выше 860 мегабайтов. |
| HighFree | Объём не используемой памяти в области RAM выше 860 мегабайтов. |
| LowTotal | Объём доступной памяти в области RAM ниже 860 мегабайтов. |
| LowFree | Объём не используемой памяти в области RAM ниже 860 мегабайтов. |
| SwapTotal | Объём доступной памяти в [**области подкачки**](https://ru.wikipedia.org/wiki/Подкачка_страниц) на жёстком диске. |
| SwapFree | Объём не используемой памяти в области подкачки. |

Подробнее значения полей файла `meminfo` рассматриваются в [статье](http://markelov.blogspot.com/2009/01/linux-procmeminfo.html).

Чтобы не набирать команду чтения файла `meminfo` каждый раз, объявим функцию с коротким именем. Например, так:
{line-numbers: false, format: Bash}
```
mem() { cat /proc/meminfo; }
```

Это однострочное объявление функции с именем `mem`. Её можно вызвать так же, как любую Bash-команду. Например:
{line-numbers: false, format: Bash}
```
mem
```

Функция выведет статистику использования памяти.

Команда unset удаляет объявленную ранее функцию. Удалим нашу функцию `mem` следующей командой:
{line-numbers: false, format: Bash}
```
unset mem
```

Предположим, что переменная и функция объявлены с одинаковыми именами. Чтобы удалить именно функцию, используйте опцию `-f` команды unset. Например, так:
{line-numbers: false, format: Bash}
```
unset -f mem
```

Объявление функции можно добавить в файл `~/.bashrc`. Тогда функция будет доступна при каждом запуске командной оболочки.

В командной строке мы объявили функцию `mem` в однострочном формате. Его удобнее и быстрее набирать. В файле `~/.bashrc` важна наглядность. Там функцию `mem` лучше объявить в стандартном виде. Например, так:
{line-numbers: true, format: Bash}
```
mem()
{
    cat /proc/meminfo
}
```

#### Отличие функций от псевдонимов

Мы объявили функцию `mem` для вывода статистики использования оперативной памяти. То же поведение даст следующий псевдоним:
{line-numbers: false, format: Bash}
```
alias mem="cat /proc/meminfo"
```

Если функции и псевдонимы работают одинаково, что выбрать?

Функции и псевдонимы похожи в одном — это встроенные механизмы Bash. С точки зрения пользователя они сокращают ввод длинных команд. Но принцип работы этих механизмов принципиально различается.

Псевдоним заменяет один текст на другой во введённой пользователем команде. Другими словами Bash находит в команде текст, который совпадает с именем alias. Затем заменяет этот текст на значение псевдонима и исполняет получившуюся команду.

Предположим, вы определили псевдоним для утилиты cat. Он добавляет опцию `-n` в вызов утилиты. Благодаря опции, в вывод добавляются номера строк. Псевдоним выглядит так:
{line-numbers: false, format: Bash}
```
alias cat="cat -n"
```

Теперь каждый раз когда в команде встречается слово "cat", Bash подставит вместо него "cat -n". Например, вы вводите команду:
{line-numbers: false, format: Bash}
```
cat ~/.bashrc
```

После подстановки псевдонима она выглядит так:
{line-numbers: false, format: Bash}
```
cat -n ~/.bashrc
```

Подстановка заменила только слово "cat" на "cat -n". Следующий далее путь до файла не изменился.

Теперь рассмотрим, как работают функции. В отличие от псевдонима тело функции не подставляется в команду. Когда Bash встречает имя функции в команде, он исполняет её тело.

Пример. Попробуем с помощью функции получить то же поведение, как у псевдонима для утилиты cat. Если бы функции работали как alias, такое определение решило бы задачу:
{line-numbers: false, format: Bash}
```
cat() { cat -n; }
```

Тогда в следующей команде Bash просто добавит опцию `-n`.
{line-numbers: false, format: Bash}
```
cat ~/.bashrc
```

Но это не сработает. Bash не подставляет тело функции в команду. Bash его исполняет и подставляет в команду результат.

В нашем случае утилита cat будет вызвана с опцией `-n`, но без параметра `~/.bashrc`. Это совершенно не то что нужно.

Чтобы решить задачу, передадим имя файла в функцию в качестве параметра. Это работает так же, как передача параметра в команду или скрипт. После вызова функции укажите список параметров, разделённых пробелами.

В общем виде вызов функции и передача в неё параметров выглядит так:
{line-numbers: false, format: Bash}
```
ИМЯ_ФУНКЦИИ ПАРАМЕТР1 ПАРАМЕТР2 ПАРАМЕТР3
```

Чтобы прочитать параметры в теле функции, используйте переменные `$1`, `$2`, `$3` и т.д. Прочитать сразу все параметры можно через переменную `$@`.

Исправим объявление функции `cat`. Все её входные параметры передадим в утилиту cat:
{line-numbers: false, format: Bash}
```
cat() { cat -n $@; }
```

Такая функция тоже не заработает. Дело в том, что при её выполнении произойдёт **рекурсия**. Рекурсией называется вызов функции из неё же самой.

Перед выполнением команды "cat -n $@" Bash проверит список объявленных функций. В списке будет функция с именем `cat`. Её тело выполняется в данный момент, но это не важно. Поэтому вместо вызова утилиты Bash вызовет функцию `cat`. Этот вызов повторится снова и снова. Возникнет бесконечная рекурсия, которая похожа на бесконечный цикл.

Рекурсия — вовсе не ошибка в поведении интерпретатора. Это мощный механизм, который значительно упрощает сложные алгоритмы (например, обход [**графа**](https://ru.wikipedia.org/wiki/Граф_(математика)) или [**дерева**](https://ru.wikipedia.org/wiki/Дерево_(структура_данных))).

Ошибка в нашем объявлении функции `cat`. Рекурсивный вызов произошел случайно и привел к зацикливанию. Решить эту проблему можно двумя способами:

1. Использовать встроенную команду command.

2. Переименовать функцию так, чтобы её имя отличалось от имени утилиты.

Рассмотрим первое решение. В качестве параметров command получает команду. Если в команде встречаются имена псевдонимов и функций, Bash не станет их обрабатывать. Тело псевдонима не подставится. Функция не вызовется.

Применим команду command в объявлении функции `cat`. Получим следующее:
{line-numbers: false, format: Bash}
```
cat() { command cat -n "$@"; }
```

Второе решение — просто переименовать функцию. Такой вариант сработает:
{line-numbers: false, format: Bash}
```
cat_func() { cat -n "$@"; }
```

Всегда помните о проблеме случайной рекурсии. Не давайте функциям имена, совпадающие с именами команд интерпретатора и GNU-утилит.

Подведём итоги сравнения функций и псевдонимов в командном интерпретаторе. Если нужно просто сократить длинную команду, используйте alias.

Функция нужна только в следующих случаях:

1. Для выполнения действия нужны условные операторы, циклы или блок команд.

2. Параметры команды находятся не в конце.

Рассмотрим пример второго случая — команду, которую нельзя заменить псевдонимом. Сократим вызов утилиты find для поиска файлов в указанном каталоге. Поиск в домашнем каталоге выглядит так:
{line-numbers: false, format: Bash}
```
find ~ -type f
```

С помощью псевдонима для этой команды параметризовать путь не получится. Следующий вариант не заработает: 
{line-numbers: false, format: Bash}
```
alias="find -type f"
```

Проблема в том, что путь должен идти до опции `-type`.

Заменим псевдоним на функцию. В её теле можно выбрать позицию для подстановки параметра в вызов find. Например, так:
{line-numbers: false, format: Bash}
```
find_func() { find $1 -type f; }
```

### Функции в скриптах

В скриптах функции объявляются точно так же, как в командном интерпретаторе. Допускаются оба варианта объявления: стандартный и однострочный.

Для примера вернёмся к проблеме обработки ошибок в большой программе. Объявим следующую функцию для вывода сообщений об ошибках:
{line-numbers: true, format: Bash}
```
print_error()
{
    >&2 echo "Произошла ошибка: $@"
}
```

Текст, объясняющий причину ошибки, передаётся в функцию через параметр. Допустим, наша программа читает файл на диске. Но файл оказался недоступен. Тогда сообщить о проблеме можно так:
{line-numbers: false, format: Bash}
```
print_error "файл readme.txt не найден"
```

Предположим, что требования к программе изменились. Теперь сообщения об ошибках нужно выводить в лог-файл. Для этого достаточно исправить объявление функции `print_error`. Команда echo изменится на следующую:
{line-numbers: true, format: Bash}
```
print_error()
{
    echo "Произошла ошибка: $@" >> debug.log
}
```

После изменения функции все сообщения об ошибках выводятся в файл `debug.log`. Менять что-либо в местах вызова функции не нужно.

Встречаются ситуация, когда одна функция должна вызвать другую. Это допустимо в Bash. В общем случае функцию можно вызвать из любого места программы.

Рассмотрим пример. Предположим, интерфейс программы надо перевести на другой язык. Такая процедура называется [**локализацией**](https://ru.wikipedia.org/wiki/Локализация_программного_обеспечения). Сообщения об ошибках лучше выводить на понятном пользователю языке. Для этого продублируем текст всех сообщений на всех языках, поддерживаемых программой. Как это сделать?

Самое простое решение — присвоить каждой ошибке уникальный код. Такая практика часто встречается в системном программировании. Применим этот подход в нашей программе. Тогда функция `print_error` в качестве параметра будет принимать код ошибки.

Код ошибки можно выводить прямо в лог-файл. Но тогда пользователю понадобится информация о значениях кодов. Удобнее выводить текст сообщения, как и раньше. Для этого код ошибки надо конвертировать в текст на нужном языке. Для этой задачи объявим специальную функцию.

Напишем функцию для конвертирования кода ошибки в сообщение. Для конвертирования применим конструкцию case. Каждый блок case соответствует определённому коду ошибки. Объявление функции выглядит так:
{line-numbers: true, format: Bash}
```
code_to_error()
{
  case $1 in
    1)
      echo "Не найден файл"
      ;;
    2)
      echo "Нет прав для чтения файла"
      ;;
  esac
}
```

Теперь перепишем объявление функции `print_error` так:
{line-numbers: true, format: Bash}
```
print_error()
{
  echo "$(code_to_error $1) $2" >> debug.log
}
```

Вызов функции `print_error` выглядит, например, так:
{line-numbers: false, format: Bash}
```
print_error 1 "readme.txt"
```

В результате вызова в лог-файл запишется строка:
{line-numbers: false, format: text}
```
Не найден файл readme.txt
```

Первым параметром в функцию передаётся код ошибки. Вторым параметром — имя файла, который привёл к проблеме.

Сопровождать механизм вывода сообщений об ошибках в нашей программе стало проще. Предположим, надо добавить вывод ошибок на другом языке. Для этого достаточно объявить две функции:

* `code_to_error_ru` для сообщений на русском.

* `code_to_error_en` для сообщений на английском.

Чтобы выбрать правильную функцию, можно проверить значение переменной `LANGUAGE` в функции `print_error`.

I> Если переменная `LANGUAGE` недоступна в вашей системе, используйте переменную `LANG`.

Наше решение с конвертированием кода ошибок — это учебный пример. Для локализации скриптов у Bash есть специальный механизм. В нём используются PO-файлы с текстами на разных языках. Подробнее об этом механизме читайте в [статье BashFAQ](https://mywiki.wooledge.org/BashFAQ/098?highlight=(Localization)).

{caption: "Упражнение 3-13. Использование функций", format: text, line-numbers: false}
```
Для вывода сообщений об ошибках на русском и английском языках напишите следующие функции:

* print_error
* code_to_error_ru
* code_to_error_en

Реализуйте функции code_to_error двумя способами:

* с конструкцией case.
* с ассоциативным массивом.
```

#### Возврат значения из функции

Большинство процедурных языков программирования имеют встроенные средства для того, чтобы возвращать произвольные значения из функций. К сожалению, у Bash нет такой возможности. Он предоставляет ключевое слово `return`, как и другие языки. Однако, с его помощью возможно передать только код возврата, то есть целочисленное значение от 0 до 255.

В общем виде алгоритм вызова и выполнения функции выглядит следующим образом:

1. В ходе выполнения программы встречается команда, в которой указано имя функции. 

2. Происходит переход на тело функции, которое исполняется с его первой команды.

3. Если в теле функции встречается команда `return`, выполнение функции прекращается. Управление передаётся в место её вызова. Код возврата, переданный в качестве параметра в команду `return`, будет записан в специальный параметр `$?`.

4. Если в теле функции нет `return`, то оно выполняется до своей последней команды. После этого происходит переход обратно в место вызова функции.

В других процедурных языках программирования ключевое слово `return` позволяет вернуть переменную любого типа: число, строку или массив. Как можно добиться аналогичного поведения в Bash?

В нашем примере функции `print_error` для вывода сообщения об ошибке мы использовали первый вариант решения этой проблемы. Он заключается в подстановке команд. В результате этой подстановки вызов команды будет заменён на её вывод. Поэтому, чтобы вернуть значение из функции, его достаточно вывести на консоль с помощью `echo`. Именно такой вывод и происходит в функции `code_to_error`. Далее в `print_error` выполняется подстановка этого вывода в финальный вызов команды `echo`, который уже пишет сообщение в лог-файл.

Второй способ вернуть значение из функции — воспользоваться переменной из глобальной области видимости скрипта, которая доступна в любом его месте. По умолчанию все переменные, объявленные в скрипте являются глобальными. У этого правила есть одно исключение, которое мы рассмотрим далее.

Перепишем функции `code_to_error` и `print_error` так, чтобы передача результата первой происходила через глобальную переменную. Получится следующее:
{line-numbers: true, format: Bash}
```
code_to_error()
{
  case $1 in
    1)
      error_text="Не найден файл"
      ;;
    2)
      error_text="Нет прав для чтения файла"
      ;;
  esac
}

print_error()
{
  code_to_error $1
  echo "$error_text $2" >> debug.log
}
```

Результат работы функции `code_to_error` сохраняется в глобальной переменной `error_text`. Затем её значение подставляется в команду `echo` в функции `print_error` для вывода сообщения в лог-файл.

Использование глобальных переменных для возврата значений из функций чревато ошибками. Возможен случайный конфликт имён, который достаточно сложно обнаружить. Представьте, например, что переменная с именем `error_text` используется в вашей программе для совершенно других целей, не связанных с выводом в лог-файл. Тогда любой вызов функции `code_to_error` перезапишет значение этой переменной. Оно будет утеряно и это наверняка приведёт к ошибке.

Чтобы решить проблему конфликта имён, вы можете использовать **соглашение об именовании переменных**. Такое соглашение является одним из пунктов [**стандарта оформления кода**](https://ru.wikipedia.org/wiki/Стандарт_оформления_кода) (coding style). Любой крупный программный проект должен иметь такой стандарт.

Примером соглашения об именовании переменных может быть следующее правило: все переменные в программе, которые используются функциями для возврата значений, должны иметь в качестве префикса знак подчёркивания `_`. Если следовать этой договорённости, переменную `error_text` в нашем примере следует переименовать на `_error_text`. Это решит проблему, но лишь отчасти. Что делать, если происходят вложенные вызовы функций (одна функция вызывается из другой) и в них случайно используются переменные с одинаковыми именами для возврата значений?

Третий способ вернуть значение из функции отчасти решает проблему конфликта имён. В нём вызывающая сторона задаёт имя глобальной переменной для возврата значения функцией. Механизм очень простой: функция в одном из своих параметров получает имя переменной, а затем с помощью команды `eval` присваивает этой переменной свой результат. Применим этот подход для функций `code_to_error` и `print_error` следующим образом:
{line-numbers: true, format: Bash}
```
code_to_error()
{
  local _result_variable=$2

  case $1 in
    1)
      eval $_result_variable="'Не найден файл'"
      ;;
    2)
      eval $_result_variable="'Нет прав для чтения файла'"
      ;;
  esac
}

print_error()
{
  code_to_error $1 "error_text"
  echo "$error_text $2" >> debug.log
}
```

На первый взгляд этот код мало отличается от предыдущего варианта, когда функция `code_to_error` всегда сохраняла свой результат в глобальной переменной `error_text`. Но на самом деле, этот код даёт дополнительную гибкость. Теперь вызывающая сторона может выбрать произвольное имя для глобальной переменной, в которой будет сохранён результат. Это имя явно указывается в коде вызова. Благодаря этому, вероятность возникновения конфликта имён значительно меньше и разрешить его становится намного проще.

#### Область видимости переменных

Конфликт имён является серьёзной проблемой, которая возникает всякий раз при одновременном использовании и глобальных переменных, и функций. Универсальное решение этой проблемы, которое предлагают все процедурные языки программирования, — это ограничение области видимости переменных.

Для всех процедурных языков справедлива рекомендация вообще избегать использование глобальных переменных. К сожалению, ей сложно следовать в Bash. Дело в том, что почти всегда при объявлении переменной в Bash она попадает в глобальную область видимости. Однако, функции позволяют исправить эту ситуацию.

Ключевое слово `local` ограничивает область видимости переменной телом функции. Рассмотрим наш последний вариант объявления `code_to_error`:
{line-numbers: true, format: Bash}
```
code_to_error()
{
  local _result_variable=$2

  case $1 in
    1)
      eval $_result_variable="'Не найден файл'"
      ;;
    2)
      eval $_result_variable="'Нет прав для чтения файла'"
      ;;
  esac
}
```

Здесь переменная `_result_variable` объявлена как локальная. Это значит, что она будет доступна для чтения и изменения только в теле `code_to_error` и любых вызываемых ею функциях. То есть область видимости локальной переменной ограничена временем исполнения функции, в которой она объявлена. Такая область видимости называется [**динамической**](https://ru.wikipedia.org/wiki/Область_видимости#Лексические_vs._динамические_области_видимости) и встречается достаточно редко в современных языках. В них чаще применяется **лексическая** область видимости, при которой переменная доступна только в теле функции, но не за его пределами (например, в вызываемых функциях).

Ограничение области видимости с помощью локальных переменных гарантирует вам, что не произойдёт случайной перезаписи одноимённой глобальной переменной.

{caption: "Упражнение 3-14. Область видимости переменных", format: text, line-numbers: false}
```
Какой текст выведет на консоль скрипт из листинга 3-37 после выполнения?
```

{caption: "Листинг 3-37. Скрипт для тестирования области видимости переменной", line-numbers: true, format: Bash}
![`quiz-variable-scope.sh`](code/BashScripting/quiz-variable-scope.sh)

С другой стороны объявление локальных переменных может стать причиной другой ошибки. Дело в том, что локальные переменные при объявлении скрывают глобальные переменные с теми же именами. Рассмотрим пример.

Предположим, что вы пишете функцию для обработки файла. Например, она с помощью утилиты grep проверяет, встречается ли в файле какой-то шаблон. Функция может выглядеть следующим образом:
{line-numbers: true, format: Bash}
```
check_license()
{
    local filename="$1"
    grep "General Public License" "$filename"
}
```

Теперь допустим, что в начале скрипта объявлена глобальная переменная с именем `filename`:
{line-numbers: true, format: Bash}
```
#!/bin/bash

filename="$1"
```

Что произойдёт в этом случае в функции `check_license`? Она будет работать корректно, потому что произойдёт **сокрытие глобальной переменной**. То есть локальная переменная будет подставлена при любом обращении к имени `filename` из функции. Это означает, что в теле функции нет никакого способа получить доступ к глобальной переменной `filename`.

Если сокрытие переменных происходит случайно по недосмотру, это может привести к ошибке. Поэтому, чтобы исключить даже возможность такой ситуации, всегда используйте префикс или постфикс для локальных переменных функций. Это может быть символ подчёркивания `_` или любой другой.

На самом деле глобальная переменная становится недоступна в теле функции только после объявления локальной переменной с тем же именем. Рассмотрим следующий вариант функции `check_license`:
{line-numbers: true, format: Bash}
```
#!/bin/bash

filename="$1"

check_license()
{
    local filename="$filename"
    grep "General Public License" "$filename"
}
```

В этом случае в функции `check_license` локальной переменной `filename` будет корректно присвоено значение глобальной переменной с тем же именем. Это произойдёт, потому что подстановка переменных выполняется до операции присваивания. То есть в момент присваивания подставляется значение позиционного параметра `$1`, переданного в скрипт. Если, например, в скрипт было передано имя файла `README`, то присваивание будет выглядеть так:
{line-numbers: false, format: Bash}
```
    local filename="README"
```

В Bash начиная с версии 4.2 индексируемые и ассоциативные массивы, объявленные в функции, по умолчанию попадают в локальную область видимости. Чтобы объявить массив глобальным, необходимо использовать опцию `-g` команды `declare`.

Например, в следующем примере массив `files` будет локальным:
{line-numbers: true, format: Bash}
```
check_license()
{
    declare files=(Documents/*.txt)
    grep "General Public License" "$files"
}
```

А в этом случае массив попадёт в глобальную область видимости скрипта и будет доступен вне тела функции:
{line-numbers: true, format: Bash}
```
check_license()
{
    declare -g files=(Documents/*.txt)
    grep "General Public License" "$files"
}
```

Закончим наше знакомство с функциями следующими общими рекомендациями по их применению:

1. Тщательно выбирайте имена для функций. Они должны сообщать читателю вашего кода, что делает соответствующая функция.

2. Все переменные, объявленные в функции, должны быть локальными. В именах этих переменных используйте префикс или постфикс, чтобы избежать конфликтов с глобальными переменными.

3. Избегайте использование глобальных переменных в функциях. Предпочитайте передавать глобальную переменную в функцию в качестве параметра, а не использовать её напрямую.

4. Не используйте ключевое слово `function` при объявлении переменных. Оно специфично для Bash и отсутствует в POSIX-стандарте. Например, следующий вариант объявления не рекомендуется:
{line-numbers: true, format: Bash}
```
function check_license()
{
    declare files=(Documents/*.txt)
    grep "General Public License" "$files"
}
```

Последний пункт может вызвать вопросы. Единственная польза от ключевого слова `function` заключается в разрешении конфликтов между именами функций и псевдонимами. Например, следующий вариант объявления функции не заработает без `function`:
{line-numbers: true, format: Bash}
```
alias check_license="grep 'General Public License'"

function check_license()
{
    declare files=(Documents/*.txt)
    grep "General Public License" "$files"
}
```

Теперь вы можете вызвать функцию, используя слэш `\` перед её именем:
{line-numbers: false, format: Bash}
```
\check_license
```

Если не использовать слэш, будет подставлен псевдоним, а не функция:
{line-numbers: false, format: Bash}
```
check_license
```

Конфликты между псевдонимами и функциями редко возникают, если вы пишете скрипт. Запуск каждого скрипта происходит в новом процессе Bash, в котором отсутствуют все пользовательские alias из файла `.bashrc`. Если же вы объявляете функцию в режиме командного интерпретатора, конфликт её имени с псевдонимом может произойти по ошибке.
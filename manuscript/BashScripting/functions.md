## Функции

Bash относится к [**процедурным языкам программирования**](https://ru.wikipedia.org/wiki/Процедурное_программирование), поэтому в нём есть функции. Мы уже сталкивались с ними, когда знакомились с переменными и командой `declare`. Теперь рассмотрим подробнее, что представляют собой функции.

### Парадигмы программирования

Перед тем как начать знакомство с функциями, разберёмся с терминологией. Она поможет нам понять, зачем вообще нужны подпрограммы, также известные как функции.

Что такое процедурное программирование? Это одна из [**парадигм**](https://ru.wikipedia.org/wiki/Парадигма_программирования) разработки ПО. Под парадигмой понимается набор идей, методов и принципов, которые определяют способ написания программ.

Сегодня широко распространены и наиболее популярны две парадигмы:

1. Императивное программирование, когда разработчик явно указывает машине, как следует изменять её состояние. Другими словами задаётся полный алгоритм вычисления результата.

2. Декларативное программирование, когда разработчик указывает свойства желаемого результата, но не алгоритм его вычисления.

Язык Bash является императивным, то есть следует первой парадигме.

Императивная и декларативная парадигмы определяют общие принципы написания программы. У каждой из них есть производные парадигмы, которые предлагают конкретные приёмы и методики программирования. Так у императивного подхода есть две производные:

1. Процедурное программирование.

2. Объектно-ориентированное программирование.

Обе эти парадигмы предписывают, как следует структурировать исходный код программы. Bash следует первой из них, поэтому рассмотрим её подробнее.

В процедурном программировании язык предоставляет средства для объединения произвольных наборов команд в независимые блоки кода, называемые процедурами или функциями. Эти блоки могут быть вызваны из любого места программы. На вход они принимают параметры точно так же как и обычные скрипты. Поэтому иногда их называют подпрограммами, то есть программами в программе.

Какие проблемы решают функции? Их основная задача — это управление сложностью программы. Чем больше объём исходного кода, тем сложнее его сопровождать и поддерживать. Особенно ситуацию усугубляют повторяющиеся фрагменты кода. Рассмотрим пример.

Представьте, что вы пишете какую-то большую программу. Для обработки ошибок в ней вы решаете выводить текстовые сообщения в стандартный поток ошибок stderr. В программе появляется много мест с вызовом команды `echo` наподобие следующего:
{line-numbers: false, format: Bash}
```
>&2 echo "Произошла ошибка N"
```

В какой-то момент вы решаете, что будет лучше записывать все ошибки в файл. Тогда их станет легче анализировать. Конечно пользователи вашей программы могут сделать запись в файл сами с помощью перенаправления потоков. Но предположим, что не все умеют ими пользоваться. Поэтому ваша программа должна писать сообщения об ошибках в специальный файл, а не в консоль.

Чтобы внести это изменение, вам придётся пройти по всем местам в вашей программе, где происходит обработка ошибок. В каждом из них надо изменить вызов команды `echo`, например, на следующий:
{line-numbers: false, format: Bash}
```
echo "Произошла ошибка N" >> debug.log
```

Если по невнимательности вы пропустите какой-то вызов `echo` и не измените, его вывод не попадёт в лог-файл. Тогда, возможно, вы не сможете понять, почему ваша программа не работает так как надо у пользователя, который прислал вам файл с выводом ошибок.

Этот пример демонстрирует одну из сложностей сопровождения программы. Она заключается во внесении изменений в написанный ранее код. В нашем примере эта сложность возникла из-за нарушения принципа разработки [Don’t repeat yourself](https://ru.wikipedia.org/wiki/Don’t_repeat_yourself) или DRY (не повторяйся). Мы копировали один и тот же код вывода ошибок снова и снова в разные места программы. Так делать нельзя.

Функции решают проблему многократного копирования кода. Чем-то это решение напоминает циклы. Но цикл позволяет многократно исполнять одни и те же команды (тело цикла) только в одном месте программы — там где находится его конструкция. В отличие от этого функция позволяет исполнять одни и те же команды (тело функции) в разных местах программы.

Кроме проблемы дублирования кода функции решают задачу комментирования. Благодаря функции вы можете объединить несколько команд в один блок и дать ему говорящее название. Затем во всех местах программы этот блок будет вызываться по своему названию (как команда). Таким образом вашу программу будет намного проще читать и сопровождать. Вместо десятка строк тела функции, будет стоять её имя, объясняющее читателю, что в ней происходит.

### Функции в командном интерпретаторе

Вы можете использовать функции как при написании скриптов, так и при работе с Bash в режиме командного интерпретатора.

Для начала рассмотрим синтаксис объявления фунции. В общем виде его можно записать следующим образом:
{line-numbers: true, format: Bash}
```
ИМЯ_ФУНКЦИИ()
{
    ДЕЙСТВИЕ
}
```

Это же самое объявление, записанное одной строкой, выглядит так:
{line-numbers: false, format: Bash}
```
ИМЯ_ФУНКЦИИ() { ДЕЙСТВИЕ ; }
```

Обратите внимание на обязательную точку с запятой перед закрывающей фигурной скобкой `}`.

Точно так же как в условных конструкциях и циклах ДЕЙСТВИЕ в функции может быть одной командой или блоком команд.

### Функции в скриптах

// TODO
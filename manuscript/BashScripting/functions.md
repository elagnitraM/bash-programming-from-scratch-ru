## Функции

Как и во многих [**процедурных языках программирования**](https://ru.wikipedia.org/wiki/Процедурное_программирование) в Bash есть функции. Мы уже сталкивались с ними, когда рассматривали переменные и команду `declare`.

### Парадигмы программирования

Перед тем как начать знакомство с функциями, разберёмся с терминологией. Она поможет нам понять, зачем вообще нужны подпрограммы, также известные как функции.

Что такое процедурное программирование? Это одна из [**парадигм**](https://ru.wikipedia.org/wiki/Парадигма_программирования) разработки ПО. Под парадигмой понимается набор идей, методов и принципов, которые определяют способ написания программ.

Сегодня широко распространены две основные парадигмы:

1. Императивное программирование, когда программист явно указывает машине, как следует изменять её состояние. Другими словами задаётся алгоритм вычисления.

2. Декларативное программирование, когда программист указывает свойства желаемого результата, но не алгоритм его вычисления.

Язык Bash является императивным, то есть следует первой парадигме.

Императивная и декларативная парадигмы определяют общие принципы написания программы. У каждой из них есть производные парадигмы, которые предлагают конкретные приёмы и методики программирования. Так у императивного подхода есть две производные:

1. Процедурное программирование.

2. Объектно-ориентированное.

Обе эти парадигмы предписывают, как следует структурировать исходный код программы. Bash следует первой из них, поэтому рассмотрим только её.

В процедурном программировании язык предоставляет средства для объединения произвольных наборов команд в независимые блоки кода, называемые процедурами или функциями. Это блоки могут быть вызваны из любого места программы. На вход они принимают параметры точно так же как и обычные скрипты. Поэтому иногда их называют подпрограммами, то есть программами в программме.

Какие проблемы решаются функциями? Их основная задача — это управление сложностью программы. Чем больше объём исходного кода, тем сложнее его сопровождать и поддерживать. Особенно ситуацию усугубляют повторяющиеся фрагменты. Рассмотрим пример.

Представьте, что вы пишете какую-то большую программу. Для обработки ошибок в ней вы решаете выводить текстовые сообщения в стандартный поток ошибок stderr. В программе появляется много мест с вызовом команды наподобие следующей:
{line-numbers: false, format: Bash}
```
>&2 echo "Произошла ошибка N"
```

В какой-то момент вы решаете, что будет лучше записывать все ошибки в файл. Тогда их легче будет анализировать. Пользователи вашей программы могут сделать запись в файл сами с помощью перенаправления потоков. Но предположим, что не все умеют ими пользоваться. Поэтому будет лучше если ваша программа всегда будет писать ошибки в специальный файл.

Чтобы внести это изменение, вам придётся пройти по всем местам в вашей программе, где происходит обработка ошибок. В каждом из них надо будет изменить вызов команды `echo`, например, на следующий:
{line-numbers: false, format: Bash}
```
echo "Произошла ошибка N" >> debug.log
```

Если по невнимательности вы пропустите какой-то вызов `echo`, и оставите его неисправленным, его вывод не попадёт в лог файл. Тогда вы не сможете понять, почему ваша программа не работает как надо у какого-то пользователя, который вам прислал файл с выводом ошибок.

Этот пример демонстрирует одну из сложностей сопровождения программы. Она заключается во внесении изменений в написанный ранее код. В нашем примере эта сложность возникла из-за нарушения принципа разработки [Don’t repeat yourself](https://ru.wikipedia.org/wiki/Don’t_repeat_yourself) или DRY (не повторяйся). Мы копировали один и тот же код вывода ошибок снова и снова в разные места программы. Так делать нельзя.

Функции решают проблему многократного копирования кода. Чем-то это решение напоминает циклы. Но цикл позволяет многократно исполнять одни и те же команды (тело цикла) только в одном месте программы — там где находится его конструкция. В отличие от этого функция позволяет исполнять одни и те же команды (тело функции) в разных местах программы.

Кроме проблемы дублирования кода функции решают задачу комментирования. Благодаря функции вы можете взять блок команд и дать ему говорящее название. Затем во всех местах программы этот блок будет вызываться по этому названию (как команда). Таким образом вашу программу будет намного проще читать и сопровождать. Вместо десятка строк тела функции, будет стоять её имя, объясняющее читателю что в ней происходит.

### Функции в командном интерпретаторе

// TODO

### Функции в скриптах

// TODO
## Функции

Bash относится к [**процедурным языкам программирования**](https://ru.wikipedia.org/wiki/Процедурное_программирование), поэтому в нём есть функции. Мы уже сталкивались с ними, когда знакомились с переменными и командой `declare`. Теперь рассмотрим подробнее, что представляют собой функции.

### Парадигмы программирования

Перед тем как начать знакомство с функциями, разберёмся с терминологией. Она поможет нам понять, зачем вообще нужны подпрограммы, также известные как функции.

Что такое процедурное программирование? Это одна из [**парадигм**](https://ru.wikipedia.org/wiki/Парадигма_программирования) разработки ПО. Под парадигмой понимается набор идей, методов и принципов, которые определяют способ написания программ.

Сегодня широко распространены и наиболее популярны две парадигмы:

1. Императивное программирование, когда разработчик явно указывает машине, как следует изменять её состояние. Другими словами задаётся полный алгоритм вычисления результата.

2. Декларативное программирование, когда разработчик указывает свойства желаемого результата, но не алгоритм его вычисления.

Язык Bash является императивным, то есть следует первой парадигме.

Императивная и декларативная парадигмы определяют общие принципы написания программы. У каждой из них есть производные парадигмы, которые предлагают конкретные приёмы и методики программирования. Так у императивного подхода есть две производные:

1. Процедурное программирование.

2. Объектно-ориентированное программирование.

Обе эти парадигмы предписывают, как следует структурировать исходный код программы. Bash следует первой из них, поэтому рассмотрим её подробнее.

В процедурном программировании язык предоставляет средства для объединения произвольных наборов команд в независимые блоки кода, называемые процедурами или функциями. Эти блоки могут быть вызваны из любого места программы. На вход они принимают параметры точно так же как и обычные скрипты. Поэтому иногда их называют подпрограммами, то есть программами в программе.

Какие проблемы решают функции? Их основная задача — это управление сложностью программы. Чем больше объём исходного кода, тем сложнее его сопровождать и поддерживать. Особенно ситуацию усугубляют повторяющиеся фрагменты кода. Рассмотрим пример.

Представьте, что вы пишете какую-то большую программу. Для обработки ошибок в ней вы решаете выводить текстовые сообщения в стандартный поток ошибок stderr. В программе появляется много мест с вызовом команды `echo` наподобие следующего:
{line-numbers: false, format: Bash}
```
>&2 echo "Произошла ошибка N"
```

В какой-то момент вы решаете, что будет лучше записывать все ошибки в файл. Тогда их станет легче анализировать. Конечно пользователи вашей программы могут сделать запись в файл сами с помощью перенаправления потоков. Но предположим, что не все умеют ими пользоваться. Поэтому ваша программа должна писать сообщения об ошибках в специальный файл, а не в консоль.

Чтобы внести это изменение, вам придётся пройти по всем местам в вашей программе, где происходит обработка ошибок. В каждом из них надо изменить вызов команды `echo`, например, на следующий:
{line-numbers: false, format: Bash}
```
echo "Произошла ошибка N" >> debug.log
```

Если по невнимательности вы пропустите какой-то вызов `echo` и не измените, его вывод не попадёт в лог-файл. Тогда, возможно, вы не сможете понять, почему ваша программа не работает так как надо у пользователя, который прислал вам файл с выводом ошибок.

Этот пример демонстрирует одну из сложностей сопровождения программы. Она заключается во внесении изменений в написанный ранее код. В нашем примере эта сложность возникла из-за нарушения принципа разработки [Don’t repeat yourself](https://ru.wikipedia.org/wiki/Don’t_repeat_yourself) или DRY (не повторяйся). Мы копировали один и тот же код вывода ошибок снова и снова в разные места программы. Так делать нельзя.

Функции решают проблему многократного копирования кода. Чем-то это решение напоминает циклы. Но цикл позволяет многократно исполнять одни и те же команды (тело цикла) только в одном месте программы — там где находится его конструкция. В отличие от этого функция позволяет исполнять одни и те же команды (тело функции) в разных местах программы.

Кроме проблемы дублирования кода функции решают задачу комментирования. Благодаря функции вы можете объединить несколько команд в один блок и дать ему говорящее название. Затем во всех местах программы этот блок будет вызываться по своему названию (как команда). Таким образом вашу программу будет намного проще читать и сопровождать. Вместо десятка строк тела функции, будет стоять её имя, объясняющее читателю, что в ней происходит.

### Функции в командном интерпретаторе

Вы можете использовать функции как при написании скриптов, так и при работе с Bash в режиме командного интерпретатора.

Для начала рассмотрим синтаксис объявления фунции. В общем виде его можно записать следующим образом:
{line-numbers: true, format: Bash}
```
ИМЯ_ФУНКЦИИ()
{
    ДЕЙСТВИЕ
}
```

Это же самое объявление, записанное одной строкой, выглядит так:
{line-numbers: false, format: Bash}
```
ИМЯ_ФУНКЦИИ() { ДЕЙСТВИЕ ; }
```

Обратите внимание на обязательную точку с запятой перед закрывающей фигурной скобкой `}`.

Точно так же как в условных конструкциях и циклах ДЕЙСТВИЕ в функции может быть одной командой или блоком команд.

Рассмотрим пример. Предположим, что вам необходимо прочитать статистику использования оперативной памяти. Для этого можно воспользоваться специальной файловой системой [**proc**](https://ru.wikipedia.org/wiki/Procfs). Она позволяет читать информацию о системе из ядра ОС. Эта инфомрация доступна в виде файлов, находящихся по пути `/proc`.

Статистика использовния оперативной памяти доступна в файле `/proc/meminfo`. Её можно прочитать следующей командой:
{line-numbers: false, format: Bash}
```
cat /proc/meminfo
```

В результате вы увидите вывод наподобие следующего:
{line-numbers: true, format: Bash}
```
MemTotal:        6811124 kB
MemFree:         3550692 kB
HighTotal:             0 kB
HighFree:              0 kB
LowTotal:        6811124 kB
LowFree:         3550692 kB
SwapTotal:       1769472 kB
SwapFree:        1636168 kB
```

Этот вывод означает, что всего доступно 6811124 Кбайт (6,8 Гбайт) оперативной памяти (первая стрчока `MemTotal`). Из них свободно 3550692 Кбайт (3,5 Гбайт) памяти (вторая стрчока `MemFree`).

Определим однострочную функцию с коротким именем, чтобы не набирать эту команду каждый раз. Это определение выглядит следующим образом: 
{line-numbers: false, format: Bash}
```
mem() { cat /proc/meminfo; }
```

Теперь вы можете вызвать функцию `mem` точно так же как и любую команду интерпретатора и увидеть статистику использования памяти.

Чтобы удалить ставшую ненужной функцию, воспользуйтесь командой `unset`. Например так:
{line-numbers: false, format: Bash}
```
unset mem
```

Предположим, что вы объявили переменную и функцию с одинаковыми именами (например `mem` в нашем случае). Чтобы удалить именно функцию, а не переменную, надо воспользоваться опцией `-f` команды `unset`. Например:
{line-numbers: false, format: Bash}
```
unset -f mem
```

#### Различие функций и alias

Может возникнуть вопрос: в чём отличие функции от `alias`? Ведь то же самое поведение можно получить, если просто определить следующий alias:
{line-numbers: false, format: Bash}
```
alias mem="cat /proc/meminfo"
```

И функции, и `alias` являются механизмами интерпретатора Bash. Отчасти их возможности пересекаются, когда вы работаете с Bash в режиме командного интерпретатора. Однако, принцип их работы совершенно различен.

Механизм `alias` представляет собой подстановку текста в ведённой вами команде. Это значит, что Bash просто подставляет значение alias вместо части введённой вами команды.

Например, вы сделали следующее объявление alias, чтобы утилита `cat` всегда выводила номера строк по опции `-n`:
{line-numbers: false, format: Bash}
```
alias cat="cat -n"
```

Это значит, что каждый раз когда в команде встречается слово `cat`, Bash вместо него подставит `cat -n`. Вы вводите команду:
{line-numbers: false, format: Bash}
```
cat ~/.bashrc
```

После подстановки alias она выглядит так:
{line-numbers: false, format: Bash}
```
cat -n ~/.bashrc
```

Было заменено только слово `cat`. Следующий далее путь до файла остался без изменений.

Теперь рассмотрим, как работают функции. В отличие от alias тело функции не подставляется вместо её имени в ведённую вами команду. Как только Bash встречает имя функции в команде, он вызывает её и начинает исполнять её тело. Рассмотрим пример.

Предположим, что вам надо получить такое же поведение с выводом номеров строк в утилите `cat`. Если бы функции работали так же как alias, мы могли бы сделать следующее определение:
{line-numbers: false, format: Bash}
```
cat() { cat -n; }
```

Теперь мы могли бы ожидать, что в следующей команде будет просто добавлен флаг `-n`:
{line-numbers: false, format: Bash}
```
cat ~/.bashrc
```

Но этого не произойдёт. Вместо подстановки будет выполнено тело функции, то есть вызвана команда `cat -n` без параметра.

Чтобы добиться правильно поведения, вам необходимо передать имя файла в функцию в качестве параметра. Это происходит точно так же, как передача параметров в команду или скрипт. Просто укажите список параметров, разделённых пробелами, после имени функции.

В общем виде передача параметров выглядит так:
{line-numbers: false, format: Bash}
```
ИМЯ_ФУНКЦИИ ПАРАМЕТР1 ПАРАМЕТР2 ПАРАМЕТР3
```

Для доступа к параметрам в теле функции используйте позиционные параметры `$1`, `$2`, `$3` и т.д, а также специальный параметр `$@`.

Перепишем определение нашей функции. Будем передавать в вызов утилиты `cat` все переданные в функцию параметры:
{line-numbers: false, format: Bash}
```
cat() { cat -n $@; }
```

К сожалению, такая функция не будет работать. Дело в том, что при выполнении её тела произойдёт **рекурсия**. Рекурсия в данном случае означает вызов функции из неё же самой.

Bash перед выполнением команды `cat -n $@` проверяет список определённых функций. В этом списке он встречает функцию с именем `cat`, тело которой и выполняется в данный момент. В результате вместо вызова утилиты `cat` произойдёт вызов одноимённой функции.

Такое поведение отнюдь не является ошибкой в поведении интерпретатора. Рекурсия — это мощный механизм, который в некоторых случаях позволяет значительно упростить сложные алгоритмы (например обход [графа](https://ru.wikipedia.org/wiki/Граф_(математика)) или [дерева](https://ru.wikipedia.org/wiki/Дерево_(структура_данных))).

Проблема в том, что в нашей функции `cat` рекурсивный вызов произошел случайно и привел к ошибке. Решить эту проблему можно двумя способами:

1. Использовать ключевое слово `command`.

2. Переименовать функцию так, чтобы её имя не совпадало с именем утилиты.

Ключевое слово `command`, введённое перед командой, выключает подстановку alias и вызов функций, имена которых встречаются в этой команде. С использованием `command` наша функция `cat` будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
cat() { command cat -n "$@"; }
```

Если же вы решили переименовать функцию, то результат может быть таким:
{line-numbers: false, format: Bash}
```
cat_func() { cat -n "$@"; }
```

Всегда помните о проблеме случайной рекурсии и старайтесь не давать своим функциям имена, конфликтующие с именами встроенных команд интерпретатора и стандартных GNU утилит.

Подведём итоги нашего сравнения функций и alias. Если вам нужно просто сократить длинную команду — используйте alias, а не функцию.

Функция будут удобнее alias в следующих случаях:

1. Если для выполнения какой-то операции требуются условные операторы, циклы или блок команд.

2. Если подставляемые параметры находятся в середине команды.

Примером параметров в середине команды служит вызов утилиты `find`. Представьте, что вы хотите сократить команду поиса всех файлов в указанном каталоге. Для домашнего каталога пользователя команда выглядит так:
{line-numbers: false, format: Bash}
```
find ~ -type f
```

Вы не сможете параметризовать путь, используя alias. Например, следующий вариант не заработает, потому что путь должен идти до опции `-type`:
{line-numbers: false, format: Bash}
```
alias="find -type f"
```

Функция легко справится с этой проблемой:
{line-numbers: false, format: Bash}
```
find_func() { find $1 -type f; }
```

### Функции в скриптах

// TODO
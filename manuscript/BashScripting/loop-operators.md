## Операторы цикла

Условные операторы нужны для управления [**порядком выполнения**](https://ru.wikipedia.org/wiki/Порядок_выполнения) программы. Под этим термином понимают последовательность, в которой выполняются операторы, команды и инструкции запущенной программы.

Условные операторы позволяют выбирать ветвь исполнения в зависимости от значений логических выражений. В некоторых случаях этого оказывается недостаточно и требуются дополнительные средства управления. Поэтому практически все высокоуровневые языки программирования имеют [**операторы цикла**](https://ru.wikipedia.org/wiki/Цикл_(программирование)).

Оператор цикла нужен для многократного повторения одного и того же блока команд. Выход из такой конструкции происходит по условию, которое обычно представляет собой логическое выражение.

### Повторение команд

Для чего может понадобиться многократно выполнять один и тот же блок команд? Чтобы ответить на этот вопрос, рассмотрим несколько примеров.

Команда `find` нам уже хорошо знакома. Она ищет файлы и каталоги на жёстком диске. Её опция `-exec` позволяет указать действие, которое будет выполнено над каждым найденным объектом. Например, следующая команда удаляет все PDF документы пользователя:
{line-numbers: false, format: Bash}
```
find ~/Documents -name "*.pdf" -exec rm {} \;
```

В этом случае утилита `rm` вызывается многократно. В качестве параметра ей передаётся очередной результат поиска `find`. Можно сказать, что утилита `find` неявно (внутри себя) выполняет оператор цикла. Условием выхода из него будет окончание списка найденных файлов.

Ещё одним примером многократного выполнения одних и тех же действий является утилита `du`. Как вы помните, она оценивает объём использованного дискового пространства. В качестве параметра можно указать путь, начиная с которого будет происходить оценка. Например так:
{line-numbers: false, format: Bash}
```
du ~/Documents
```

В результате выполнения этой команды утилита рекурсивно обойдёт все подкаталоги, находящиеся по пути `~/Documents`. Размер каждого найденного в них файла будет добавлен к конечному результату. Это означает, что операция сложения будет повторяться снова и снова.

Можно предположить, что утилита `du` выполняет цикл при переборе всех файлов каждого найденного ею каталога. Для каждого файла читается его размер, который прибавляется к конечному результату.

Повторение одних и тех же операций часто встречается в математических расчётах. Каноничным примером считается вычисление [**факториала**](https://ru.wikipedia.org/wiki/Факториал). Факториалом какого-либо числа N называется произведение последовательных натуральных чисел от 1 до N включительно. Например, факториал числа 4 рассчитывается следующим образом:
{line-numbers: false, format: Bash}
```
4! = 1 * 2 * 3 * 4 = 24
```

Факториал может быть легко рассчитан с помощью оператора цикла. Для этого цикл должен последовательно перебирать целые числа от 1 до N. Каждое из них должно умножаться на конечный результат. В этом случае операция умножения повторяется.

Последний наш пример с повторением действий связан с событиями в системе. Представьте, что вы пишете программу, которая загружает на компьютер файлы из интернета. В начале своей работы программа устанавливает соединение с сервером. Если ответ от сервера не получен сразу, у программы есть два варианта действий. Первый — завершить выполнение с кодом возврата, отличным от нуля. Второй — ожидать ответа. Второй вариант практически всегда окажется предпочтительнее. Есть много причин, по которым ответ от сервера может прийти с задержкой. Например, перегрузка сети или самого сервера. Двух-трёхсекундного ожидания может оказаться достаточно, чтобы ответ пришёл и наша программа продолжила выполнение.

Самый простой способ реализовать ожидание какого-либо события в программе, это использовать оператор цикла. В нём проверяется условие наступления события. В нашем примере — это получение ответа от сервера. До тех пор, пока событие не наступило, цикл продолжается. При этом в его блоке команд могут отсутствовать какие-либо действия (пустой цикл). Альтернативный вариант — вызывать в цикле команду остановки выполнения программы на заданный промежуток времени. Такая техника называется **активным ожиданием** событий или [**busy-waiting**](https://en.wikipedia.org/wiki/Busy_waiting).

Мы рассмотрели следующие задачи, требующие повторения одних и тех же действий:

1. Однообразная обработка нескольких сущностей. Например, результатов поиска команды `find`.

2. Накопление конечного результата из промежуточных данных. Например, сбор статистики утилитой `du`.

3. Математические расчёты. Например, вычисление факториала.

4. Ожидание наступления какого-либо события. Например, получение ответа от сервера по сети.

Этот список далеко не полный. Он включает только наиболее часто встречающиеся в программировании задачи, для решения которых требуются операторы цикла.

### Оператор while

В Bash есть два оператора цикла (`while` и `for`), у каждого из которых есть две формы. Начнём наше изучение с самого простого из них — оператора `while`. Его синтаксис напоминает условную конструкцию `if`. В общем виде его можно записать следующим образом:
{line-numbers: true}
```
while УСЛОВИЕ
do
    ДЕЙСТВИЕ
done
```

Запись оператора в одну строку будет выглядеть так:
{line-numbers: false}
```
while УСЛОВИЕ; do ДЕЙСТВИЕ; done
```

УСЛОВИЕ и ДЕЙСТВИЕ в конструкции `while` могут быть одной командой или блоком команд, как и в конструкции `if`. Сначала проверяется УСЛОВИЕ. Если оно завершилось успешно с кодом возврата ноль, выполняется ДЕЙСТВИЕ. После этого опять проверяется УСЛОВИЕ и, если его код возврата по-прежнему ноль, снова выполняется ДЕЙСТВИЕ. Цикл прервётся тогда, когда УСЛОВИЕ вернёт результат, отличный от нуля.

Цикл `while` применяется в случаях, когда количество итераций заранее неизвестно. Типичный пример такой ситуации — это ожидание наступления какого-либо события. Рассмотрим пример.

Напишем скрипт, для проверки доступности какого-либо сервера в интернете. Чтобы выполнить такую проверку, нам необходимо отправить серверу запрос и получить от него ответ. Как только ответ будет получен, скрипт может вывести сообщение на экран и завершить свою работу.

Для обращения к серверу воспользуемся утилитой [`ping`](https://ru.wikipedia.org/wiki/Ping). Она посылает [ICMP](https://ru.wikipedia.org/wiki/ICMP) echo-запросы на удалённый сетевой [хост](https://ru.wikipedia.org/wiki/Хост) и получает от него echo-ответы. В качестве параметра утилита принимает [URL](https://ru.wikipedia.org/wiki/URL) или [IP-адрес](https://ru.wikipedia.org/wiki/IP-адрес) целевого хоста.

Вы можете вызвать утилиту `ping` из командной строки следующим образом:
{line-numbers: false, format: Bash}
```
ping google.com
```

Таким образом вы обратитесь к одному из серверов поисковой системы Google. После запуска команды вы увидите примерно следующий вывод:
{line-numbers: true, format: Bash}
```
PING google.com (172.217.21.238) 56(84) bytes of data.
64 bytes from fra16s13-in-f14.1e100.net (172.217.21.238): icmp_seq=1 ttl=51 time=17.8 ms
64 bytes from fra16s13-in-f14.1e100.net (172.217.21.238): icmp_seq=2 ttl=51 time=18.5 ms
```

Это подробная информация о каждом отправленном echo-запросе и полученном на него echo-ответе. Сейчас утилита работает в бесконечном цикле. Чтобы её остановить, нажмите комбинацию клавиш Ctrl+C.

Для проверки доступности сервера будет достаточно отправить только один echo-запрос. Для этого воспользуемся опцией `-c` утилиты `ping`. Эта опция позволяет указать число отправляемых пакетов. С ней вызов `ping` будет выглядеть так:
{line-numbers: false, format: Bash}
```
ping -c 1 google.com
```

Если сервер `google.com` доступен, утилита вернёт код возврата ноль. В противном случае он будет ненулевым.

Добавим к нашему вызову `ping` опцию `-W`, чтобы задать таймаут ожидания ответа от сервера. Одной секунды будет достаточно. Получится следующий вызов:
{line-numbers: false, format: Bash}
```
ping -c 1 -W 1 google.com
```

Теперь запишем конструкцию `while`, в которой вызов утилиты `ping` будет выполнять роль условия. Получим следующее:
{line-numbers: true, format: Bash}
```
while ! ping -c 1 -W 1 google.com &> /dev/null
do
    sleep 1
done
```

Нам не интересен вывод утилиты, поэтому перенаправляем его в файл `/dev/null`. В условии цикла мы инвертировали результат вызова `ping`. Это значит, что пока утилита возвращает отличный от нуля код (то есть сервер недоступен), будет выполняться тело цикла. В качестве действия вызывается утилита `sleep`. Она останавливает выполнение скрипта на указанное количество секунд. В нашем примере остановка длится одну секунду.

I> Вы можете указать суффикс для параметра утилиты `sleep`. Секундам соответствует суффикс `s` (например, `5s`), минутам — `m`, часам — `h` и дням — `d`.

Листинг 3-18 демонстрирует полный скрипт для ожидания ответа от сервера. Когда ответ получен, на консоль выводится сообщение.

{caption: "Листинг 3-18. Скрипт для ожидания ответа от сервера", line-numbers: true, format: Bash}
![`while-ping.sh`](code/BashScripting/while-ping.sh)

У конструкции `while` есть альтернативная форма `until`. Её единственное отличие заключается в том, что ДЕЙСТВИЕ выполняется до тех пор, пока УСЛОВИЕ ложно, т.е. возвращает отличный от нуля код. Другими словами `until` позволяет инвертировать условие цикла `while`.

В общем виде конструкцию `until` можно записать так:
{line-numbers: true}
```
until УСЛОВИЕ
do
    ДЕЙСТВИЕ
done
```

Запись оператора в одну строку аналогична циклу `while`:
{line-numbers: false}
```
until УСЛОВИЕ; do ДЕЙСТВИЕ; done
```

Перепишем наш скрипт для ожидания ответа от сервера с помощью конструкции `until`. Для этого удалим логическое отрицание результата вызова утилиты `ping`. Получится скрипт, приведённый в листинге 3-19.

{caption: "Листинг 3-19. Скрипт для ожидания ответа от сервера", line-numbers: true, format: Bash}
![`until-ping.sh`](code/BashScripting/until-ping.sh)

Его поведение полностью совпадает со скриптом из листинга 3-18.

Выбирайте форму `while` или `until` в зависимости от условия цикла. Всегда старайтесь составлять условия так, чтобы по возможности избегать отрицаний. Они усложняют чтение кода и способствуют ошибкам.

#### Бесконечный цикл

Конструкция `while` часто применяется в [**бесконечных циклах**](https://ru.wikipedia.org/wiki/Бесконечный_цикл). Такие циклы обычно выполняются до тех пор, пока работает программа или скрипт. Они используются в системном ПО, которое не должно завершаться до отключения питания (например, ОС или прошивки микроконтроллеров), а также в компьютерных играх. Бесконечные циклы могут быть полезны в Bash для вывода разного рода статистики.

Чтобы цикл `while` стал бесконечным, его условие должно всегда быть истинным. Самый простой способ этого добиться — использовать встроенную команду интерпретатора `true`. Например, следующим образом:
{line-numbers: true, format: Bash}
```
while true
do
    sleep 1
done
```

Команда `true` всегда возвращает истину, то есть её код возврата всегда ноль. У неё есть симметричная команда `false`, которая всегда возвращает единицу.

I> Во многих языках программирования `true` и `false` являются [**литералами**](https://ru.wikipedia.org/wiki/Литерал_(информатика)), то есть зарезервированными словами, обозначающими значение истина и ложь. Но в Bash это встроенные команды интерпретатора.

Вместо `true` вы также можете использовать двоеточие `:`. Тогда бесконечный `while` цикл будет выглядеть так:
{line-numbers: true, format: Bash}
```
while :
do
    sleep 1
done
```

Команда двоеточие является синонимом `true`. Она нужна для [совместимости](https://stackoverflow.com/questions/3224878/what-is-the-purpose-of-the-colon-gnu-bash-builtin) с Bourne shell, в котором `true` и `false` отсутствуют. Все три команды (`:`, `true`, `false`) включены в POSIX-стандарт.

Рассмотрим пример использования бесконечного цикла. Предположим, что вам нужно периодически выводить статистику об использовании дискового пространства в вашей системе. Для вывода этой информации можно воспользоваться утилитой `df`. При вызове её без параметров, вы получите следующий результат:
{line-numbers: true, format: Bash}
```
$ df
Filesystem     1K-blocks      Used Available Use% Mounted on
C:/msys64       41940988  24666880  17274108  59% /
Z:             195059116 110151748  84907368  57% /z
```

Занятое (Used) и свободное (Available) дисковое пространство указано в байтах. Для удобства можно использовать опцию утилиты `-h`. Тогда байты будут переведены в килобайты, мегабайты, гигабайты и терабайты. Также вы можете добавить опцию `-T`, чтобы вывести тип файловой системы для каждого диска. В результате получится вывод в таком формате:
{line-numbers: true, format: Bash}
```
$ df -hT
Filesystem     Type  Size  Used Avail Use% Mounted on
C:/msys64      ntfs   40G   24G   17G  59% /
Z:             hgfs  187G  106G   81G  57% /z
```

Если вам нужна информация обо всех точках монтирования, укажите опцию `-a`.

Будем вызывать утилиту `df` в бесконечном цикле каждые две секунды. Таким образом вы получите простейший скрипт для наблюдения за файловой системой. Он приведён в листинге 3-20.

{caption: "Листинг 3-20. Скрипт для наблюдения за файловой системой", line-numbers: true, format: Bash}
![`while-df.sh`](code/BashScripting/while-df.sh)

В начале цикла вызывается утилита `clear`. Она очищает окно терминала от текста. Благодаря этому, в терминале останется только вывод нашего скрипта без какой-либо лишней информации.

Задача циклического выполнения команд с заданным интервалом встречается настолько часто, что для неё была разработана специальная утилита `watch` из пакета `procps`. Чтобы установить этот пакет под MSYS2, выполните следующую команду:
{line-numbers: false, format: Bash}
```
pacman -S procps
```

Теперь вы можете получить поведение скрипта из листинга 3-20 всего одной командой:
{line-numbers: false, format: Bash}
```
watch -n 2 "df -hT"
```

Опция `-n` задаёт интервал между вызовами команды, которая идёт следующим параметром. Ещё одна полезная опция `watch` — это `-d`. Она позволяет подсветить разницу в выводе команды, выполненной на текущей итерации и на прошлой. Благодаря этому, вам будет легче отследить произошедшие изменения.

#### Чтение стандартного потока ввода

Цикл `while` часто используется для обработки стандартного потока ввода. Рассмотрим эту возможность на примере. Напишем скрипт, который будет читать ассоциативный массив из текстового файла.

Листинг 3-10 демонстрирует скрипт для работы с контактами. Они хранятся в коде скрипта, что неудобно для редактирования и сопровождения. Было бы лучше поместить контакты в обычный текстовый файл и читать его при старте скрипта. Таким образом мы разделим данные и код. Возможный формат файла с контактами приведён в листинге 3-21.

{caption: "Листинг 3-21. Текстовый файл `contacts.txt` со списком контактов", line-numbers: true, format: text}
![`contacts.txt`](code/BashScripting/contacts.txt)

Теперь напишем скрипт для чтения этого файла и записи его содержимого в ассоциативный массив. Очевидно, что для решения этой задачи нам понадобится цикл. Перед началом его выполнения мы не знаем, сколько потребуется итераций. Это верный признак того, что вам нужно использовать цикл `while`.

Почему число итераций цикла неизвестно? Мы собираемся выполнять обработку файла контактов построчно. Каждая строка хранит одну запись. Прочитав её, мы добавим соответствующий элемент в ассоциативный массив и перейдём к следующей записи. Получается, что число итераций цикла соответствует числу строк в файле. Но число строк станет нам известно только после окончания его обработки. Можно было бы прочитать файл целиком, подсчитать число строк в нём и сделать массив с фиксированным числом итераций. Но это было бы неоправданным усложнением кода, потому что у такого подхода нет никаких преимуществ.

Для чтения строк файла мы можем применить встроенную команду интерпретатора `read`. Она читает строку из стандартного потока ввода и сохраняет её в переменную, имя которой передаётся в качестве параметра. Например, следующим образом:
{line-numbers: false, format: Bash}
```
read var
```

В этом случае после запуска команды на исполнение вы должны ввести строку, которая будет сохранена в переменной `var`. Если вызвать `read` без параметров, строка будет сохранена в зарезервированной переменной `REPLY`.

Команда `read` позволяет экранировать некоторые введённые символы с помощью обратного слэша `\`. Чтобы отключить эту функцию, используйте опцию `-r`. В противном случае вы рискуете потерять некоторые символы из ввода.

Если команде `read` передать несколько имён переменных, следующих через пробел, то вводимый пользователем текст будет поделён на строки. В качестве разделителей между ними будут использоваться символы из зарезервированной переменной `IFS`. По умолчанию это пробел, знаки табуляции и перевода строки.

Рассмотрим пример. Предположим, что вам надо сохранить вводимые пользователем строки в двух переменных с именами `path` и `file`. Команда `read` в этом случае будет выглядеть так:
{line-numbers: false, format: Bash}
```
read -r path file
```

Пользователь вводит следующий текст:
{line-numbers: false, format: text}
```
~/Documents report.txt
```

В этом случае путь `~/Documents` попадёт в переменную `path`, а имя файла `report.txt` в `file`.

Если путь содержит пробелы (например, `~/My Documents`), то произойдёт ошибка. Предположим, ввод пользователя выглядит так:
{line-numbers: false, format: text}
```
~/My Documents report.txt
```

В этом случае в переменную `path` попадёт строка `~/My`, а в `file` всё остальное: `Documents report.txt`. Всегда учитывайте эту особенность работы утилиты `read`. Эту проблему можно решить, если переопределить зарезервированную переменную `IFS`. Например так:
{line-numbers: false, format: text}
```
IFS="," read -r path file
```

Тогда следующий ввод пользователя даст корректный результат.
{line-numbers: true, format: text}
```
~/My Documents,report.txt
```

В этом примере мы использовали в качестве разделителя запятую `,`. Поскольку она не встречается ни в пути, ни в имени файла, ввод пользователя обработается корректно. Строка `~/My Documents` попадёт в переменную `path`, а `report.txt` в `file`.

Команда `read` читает данные со стандартного потока ввода. Это значит, что вы можете перенаправить ей на вход содержимое файла. Например, прочитать первую строчку файла `contacts.txt` из листинга 3-21 можно следующей командой:
{line-numbers: false, format: Bash}
```
read -r contact < contacts.txt
```

После выполнения этой команды в переменную `contact` будет записана строка `Alice=alice@gmail.com`. 

Вы можете сохранить имя и контактные данные в разные переменные. Для этого в качестве разделителя определите знак равно `=`. Получится следующий вызов:
{line-numbers: false, format: Bash}
```
IFS="=" read -r name contact < contacts.txt
```

Теперь имя `Alice` попало в переменную `name`, а адрес электронной почты в `contact`.

Чтобы пройти по всему списку контактов в файле `contacts.txt`, мы могли бы написать следующий цикл `while`:
{line-numbers: true, format: Bash}
```
while IFS="=" read -r name contact < "contacts.txt"
do
  echo "$name = $contact"
done
```

Однако, это не сработает. Произойдёт зацикливание, потому что команда `read` всегда будет читать только первую строчку файла и возвращать нулевой код возврата. Нулевой код приведёт к повторному выполнению цикла снова и снова.

Чтобы цикл `while` последовательно прошёл по всем строкам из стандартного ввода, его нужно записать в следующей форме:
{line-numbers: true, format: Bash}
```
while УСЛОВИЕ
do
  ДЕЙСТВИЕ
done < ФАЙЛ
```

Если вам необходимо обработать ввод пользователя с клавиатуры, в качестве файла укажите `/dev/tty`. В этом случае чтобы закончить ввод, необходимо нажать сочетание клавиш Ctrl+D.

Таким образом правильный вариант цикла `while` для чтения файла `contacts.txt` выглядит так:
{line-numbers: true, format: Bash}
```
while IFS="=" read -r name contact
do
  echo "$name = $contact"
done < "contacts.txt"
```

После выполнения этого цикла будет распечатано всё содержимое файла.

Последний шаг, который нам остался, заключается в инициализации ассоциативного массива с помощью прочитанных переменных `name` и `contact`. Конечный вариант скрипта для чтения и работы с контактами приведён в листинге 3.22

{caption: "Листинг 3-22. Скрипт для работы с файлом контактов", line-numbers: true, format: Bash}
![`while-contacts.sh`](code/BashScripting/while-contacts.sh)

Поведение этого скрипта полностью повторяет скрипт из листинга 3-10.

### Оператор for

Оператор цикла `for` используется в случаях, когда заранее известно количество итераций. У него есть две формы. Первая позволяет последовательно обработать каждое слово в некоторой строке. Вторая форма в качестве условия выхода из цикла использует арфиметические выражения.

Начнём с первой формы `for` как более простой. В общем виде её можно записать так:
{line-numbers: true}
```
for СЛОВО in СТРОКА
do
    ДЕЙСТВИЕ
done
```

В однострочном виде эта же конструкция выглядит так:
{line-numbers: false}
```
for СЛОВО in СТРОКА; do ДЕЙСТВИЕ; done
```

### Управление циклом

// TODO: continue, break
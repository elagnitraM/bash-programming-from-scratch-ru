## Операторы цикла

Условные операторы управляют [**порядком выполнения**](https://ru.wikipedia.org/wiki/Порядок_выполнения) программы. Порядок выполнения — это последовательность исполнения операторов, команд и инструкций программы.

Условный оператор выбирает ветвь исполнения в зависимости от логического выражения. Иногда этого недостаточно. Нужны дополнительные средства для управления порядком выполнения. [**Операторы цикла**](https://ru.wikipedia.org/wiki/Цикл_(программирование)) решают задачи, с которыми не справляются условные операторы.

Оператор цикла многократно повторяет один и тот же блок команд. Однократное выполнение этого блока называется **итерацией цикла**. На каждой итерации проверяется условие цикла. В зависимости от результата, цикл продолжается или прекращается.

### Повторение команд

Зачем в программе повторять один и тот же блок команд? Чтобы ответить на этот вопрос, рассмотрим несколько примеров.

Утилита find нам уже знакома. Она ищет файлы и каталоги на жёстком диске. Если в вызов утилиты добавить опцию `-exec`, можно указать действие. Оно выполнится над каждым найденным объектом.

Например, следующая команда удалит все PDF документы пользователя в каталоге `~/Documents`:
{line-numbers: false, format: Bash}
```
find ~/Documents -name "*.pdf" -exec rm {} \;
```

В этом случае find несколько раз вызовет утилиту rm. На каждом вызове ей передаётся очередной результат поиска find. Получается, что утилита find выполняет оператор цикла. Цикл завершится после обработки всех найденных файлов.

Утилита du — это ещё один пример повторения действий. Утилита оценивает объём использованного дискового пространства на дисках. У du есть необязательный параметр. Это путь, с которого начинается оценка.

Вот пример вызова утилиты:
{line-numbers: false, format: Bash}
```
du ~/Documents
```

Для выполнения этой команды утилита рекурсивно обойдёт все подкаталоги `~/Documents`. Размер каждого найденного файла добавится к конечному результату. Это означает, что инкремент результата оценки повторяется снова и снова.

Утилита du выполняет цикл для прохода по всем файлам в каждом найденном ею каталоге. Размер каждого файла читается и прибавляется к конечному результату.

Повторение операций часто встречается в математических расчётах. Каноничный пример — это вычисление [**факториала**](https://ru.wikipedia.org/wiki/Факториал). Факториалом числа N называется произведение последовательных натуральных чисел от 1 до N включительно.

Например, факториал числа 4 вычисляется так:
{line-numbers: false, format: Bash}
```
4! = 1 * 2 * 3 * 4 = 24
```

Факториал легко вычислить с помощью оператора цикла. Для этого цикл должен последовательно перебрать целые числа от 1 до N. Каждое число умножается на конечный результат. В этом случае повторяется операция умножения.

В качестве последнего примера повторения действий рассмотрим события в компьютерной системе.

Представьте, что вы пишете программу. Она загружает на компьютер файлы из интернета. Для начала программа устанавливает соединение с сервером. Если сервер не отвечает, у программы есть два варианта действий. Первый — завершить выполнение с ненулевым кодом возврата. Второй — ожидать ответа. Второй вариант предпочтительнее. Есть много причин, по которым ответ от сервера задерживается. Например, перегружена сеть или сам сервер. Двух-трёхсекундного ожидания будет достаточно, чтобы получить ответ. Тогда наша программа продолжит работу.

Возникает вопрос: как в программе ожидать наступление события? Самый простой способ — использовать оператор цикла. Условием выхода из него будет наступление ожидаемого события. В нашем примере цикл завершится при получении ответа от сервера. Цикл продолжается пока событие не наступило. При этом его блок команд пустой. Такая техника называется **активным ожиданием** событий или [**busy-waiting**](https://en.wikipedia.org/wiki/Busy_waiting).

Вместо пустого блока команд в цикле ожидания можно останавливать программу на короткое время. Тогда ОС сможет работать над другой задачей, пока ваша программа остановлена.

Мы рассмотрели несколько примеров, когда программа повторяет одни и те же действия. Запишем задачи, решаемые в каждом примере:

1. Однообразная обработка нескольких сущностей. Например, результатов поиска утилиты find.

2. Накопление конечного результата из промежуточных данных. Например, сбор статистики утилитой du.

3. Математические расчёты. Например, вычисление факториала.

4. Ожидание наступления какого-либо события. Например, получение ответа от сервера по сети.

Список далеко не полный. Это наиболее часто встречающиеся в программировании задачи, для решения которых требуются оператор цикла.

### Оператор while

В Bash есть два оператора цикла: while и for. Сначала познакомимся с оператором while. Он проще чем for.

Синтаксис while напоминает условный оператор if. В общем виде он выглядит так:
{line-numbers: true, format: Bash}
```
while УСЛОВИЕ
do
    ДЕЙСТВИЕ
done
```

Оператор можно записать в одну строку:
{line-numbers: false, format: Bash}
```
while УСЛОВИЕ; do ДЕЙСТВИЕ; done
```

В конструкции while УСЛОВИЕМ и ДЕЙСТВИЕМ может быть одна команда или блок команд. Точно так же как в операторе if. ДЕЙСТВИЕ называется **телом цикла** (loop body).

Выполнение while начинается с проверки УСЛОВИЯ. Если команда УСЛОВИЯ вернула нулевой код, оно считается истинным. В этом случае выполняется ДЕЙСТВИЕ. Дальше опять проверяется УСЛОВИЕ. Если оно по-прежнему истинно, снова выполняется ДЕЙСТВИЕ. Цикл прервётся тогда, когда УСЛОВИЕ станет ложным.

Используйте цикл while, когда количество итераций заранее неизвестно. Например, при активном ожидании какого-то события.

Для примера напишем скрипт. Он проверит доступность сервера в интернете. Для такой проверки отправим серверу запрос. Как только сервер пришлёт ответ, наш скрипт выведет сообщение и завершится.

Чтобы отправить серверу запрос, вызовем утилиту [ping](https://ru.wikipedia.org/wiki/Ping). Утилита использует [ICMP](https://ru.wikipedia.org/wiki/ICMP) **протокол**. Протокол — это соглашение о формате сообщений между компьютерами в сети. ICMP протокол описывает формат сообщений для обслуживания сети. Они нужны, например, чтобы проверить доступность какого-то компьютера.

В качестве входного параметра утилита ping принимает [URL](https://ru.wikipedia.org/wiki/URL) или [IP-адрес](https://ru.wikipedia.org/wiki/IP-адрес) целевого **хоста**. Хостом называется любой подключённый к сети компьютер или устройство.

Команда для вызова утилиты ping выглядит так:
{line-numbers: false, format: Bash}
```
ping google.com
```

В качестве целевого хоста мы указали сервер Google. Утилита будет отправлять ему ICMP-сообщения. Сервер будет отвечать на каждое из них. Вывод утилиты выглядит так:
{line-numbers: true, format: Bash}
```
PING google.com (172.217.21.238) 56(84) bytes of data.
64 bytes from fra16s13-in-f14.1e100.net (172.217.21.238): icmp_seq=1 ttl=51 time=17.8 ms
64 bytes from fra16s13-in-f14.1e100.net (172.217.21.238): icmp_seq=2 ttl=51 time=18.5 ms
```

Это информация о каждом отправленном ICMP-сообщении и ответе на него. Сейчас утилита работает в бесконечном цикле. Чтобы её остановить, нажмите комбинацию клавиш Ctrl+C.

Чтобы проверить доступность сервера, достаточно отправить ему одно ICMP-сообщение. Укажем это с помощью опции `-c` утилиты ping. Команда станет выглядеть так:
{line-numbers: false, format: Bash}
```
ping -c 1 google.com
```

Если сервер `google.com` доступен, утилита вернёт код ноль. В противном случае код будет ненулевым.

Утилита ping ожидает ответ от сервера, пока её не прервёт пользователь. С помощью опции `-W` ограничим время ожидания одной секундой. Получится такая команда:
{line-numbers: false, format: Bash}
```
ping -c 1 -W 1 google.com
```

У нас готово условие для конструкции while. Запишем конструкцию целиком:
{line-numbers: true, format: Bash}
```
while ! ping -c 1 -W 1 google.com &> /dev/null
do
    sleep 1
done
```

Нас не интересует вывод утилиты ping. Поэтому перенаправим его в файл `/dev/null`.

В условии цикла результат вызова ping инвертирован. Поэтому тело цикла выполняется до тех пор, пока утилита возвращает отличный от нуля код. Другими словами цикл выполняется, пока сервер недоступен.

В теле цикла вызывается утилита sleep.
Она останавливает выполнение скрипта на указанное количество секунд. В нашем примере остановка длится одну секунду.

I> Для параметра утилиты sleep можно указать суффикс. Секундам соответствует суффикс s (например, 5s), минутам — m, часам — h и дням — d.

Листинг 3-18 демонстрирует полный скрипт для проверки доступности сервера.

{caption: "Листинг 3-18. Скрипт для проверки доступности сервера", line-numbers: true, format: Bash}
![`while-ping.sh`](code/BashScripting/while-ping.sh)

У конструкции while есть альтернативная форма until. В ней ДЕЙСТВИЕ выполняется до тех пор, пока УСЛОВИЕ ложно. То есть цикл выполняется, пока УСЛОВИЕ возвращает отличный от нуля код. С помощью формы until можно инвертировать условие while.

В общем виде конструкция until выглядит так:
{line-numbers: true}
```
until УСЛОВИЕ
do
    ДЕЙСТВИЕ
done
```

Запись unitl в одну строку похожа на while:
{line-numbers: false}
```
until УСЛОВИЕ; do ДЕЙСТВИЕ; done
```

Заменим конструкцию while на until в листинге 3-18. Для этого удалим отрицание результата утилиты ping. Получится скрипт, приведённый в листинге 3-19.

{caption: "Листинг 3-19. Скрипт для проверки доступности сервера", line-numbers: true, format: Bash}
![`until-ping.sh`](code/BashScripting/until-ping.sh)

Поведение скриптов в листингах 3-18 и 3-19 полностью совпадает.

Выбирайте форму while или until в зависимости от условия цикла. Старайтесь составлять условия без отрицаний. Отрицания усложняют чтение кода.

#### Бесконечный цикл

Конструкция while часто применяется в [**бесконечных циклах**](https://ru.wikipedia.org/wiki/Бесконечный_цикл). Такие циклы выполняются всё время, пока работает программа.

Бесконечные циклы встречаются в системном ПО, которое работает до отключения питания компьютера. Например, в ОС или прошивках микроконтроллеров. Такие циклы также применяются в компьютерных играх и программах-мониторах для сбора статистики.

Цикл while станет бесконечным, если его условие всегда истинно. Самый простой способ задать такое условие — вызвать встроенную команду интерпретатора true. Например, так:
{line-numbers: true, format: Bash}
```
while true
do
    sleep 1
done
```

Команда true всегда возвращает истину. То есть её код возврата ноль. У true есть симметричная команда false. Она всегда возвращает единицу, то есть ложь.

I> В большинстве языков программирования true и false являются [**литералами**](https://ru.wikipedia.org/wiki/Литерал_(информатика)). Литералы — это зарезервированными слова. В случае true и false они обозначают значения истина и ложь.

Команду true в условии while можно заменить на двоеточие. Тогда получим следующее:
{line-numbers: true, format: Bash}
```
while :
do
    sleep 1
done
```

Команда двоеточие — это синонимом true. Она нужна для [совместимости](https://stackoverflow.com/questions/3224878/what-is-the-purpose-of-the-colon-gnu-bash-builtin) с Bourne shell. В нём команды true и false отсутствуют. В POSIX-стандарт включены все три команды: двоеточие, true и false.

Рассмотрим пример бесконечного цикла. Напишем скрипт для вывода статистики об использовании дискового пространства. Для этого воспользуемся утилитой df. При вызове без параметров она выведет следующее:
{line-numbers: true, format: Bash}
```
$ df
Filesystem     1K-blocks      Used Available Use% Mounted on
C:/msys64       41940988  24666880  17274108  59% /
Z:             195059116 110151748  84907368  57% /z
```

Занятое (Used) и свободное (Available) дисковое пространство указано в байтах. Добавим в вызов утилиты опцию `-h`. Тогда вместо байтов получим килобайты, мегабайты, гигабайты и терабайты. Также добавим опцию `-T`. Она покажет тип файловой системы для каждого диска. Вывод утилиты станет таким:
{line-numbers: true, format: Bash}
```
$ df -hT
Filesystem     Type  Size  Used Avail Use% Mounted on
C:/msys64      ntfs   40G   24G   17G  59% /
Z:             hgfs  187G  106G   81G  57% /z
```

Чтобы вывести информацию обо всех точках монтирования, добавьте опцию `-a`.

Напишем бесконечный цикл, в теле которого вызывается утилита df. Получится простейший скрипт для наблюдения за файловой системой. Скрипт приведён в листинге 3-20.

{caption: "Листинг 3-20. Скрипт для наблюдения за файловой системой", line-numbers: true, format: Bash}
![`while-df.sh`](code/BashScripting/while-df.sh)

В начале цикла вызывается утилита clear. Она очищает окно терминала от текста. Благодаря этому, в окне останется вывод нашего скрипта без лишней информации.

При работе с Bash часто возникает задача циклического выполнения команды. Для этого есть специальная утилита watch. Она входит в состав пакета procps. Чтобы установить этот пакет в окружение MSYS2, выполните следующую команду:
{line-numbers: false, format: Bash}
```
pacman -S procps
```

Теперь скрипт из листинга 3-20 можно заменить одной командой:
{line-numbers: false, format: Bash}
```
watch -n 2 "df -hT"
```

Опция `-n` утилиты watch задаёт интервал между вызовами команды. Команда для исполнения указывается после всех опций.

Опция watch `-d` подсвечивает разницу в выводе команды, выполненной на текущей итерации и на прошлой. Благодаря этому, легче отследить произошедшие изменения.

#### Чтение стандартного потока ввода

Цикл while хорошо подходит для обработки потока ввода. Рассмотрим пример такой задачи. Напишем скрипт, который прочитает ассоциативный массив из текстового файла.

Листинг 3-10 демонстрирует скрипт для работы с контактами. Они хранятся в коде скрипта. Из-за этого контакты неудобно редактировать. Пользователь должен знать синтаксис Bash. Иначе он допустит ошибку при инициализации элемента массива, и скрипт перестанет работать.

Проблему редактирования можно решить. Поместим контакты в отдельный текстовый файл. При старте скрипт будет загружать из него все контакты. Так мы разделим данные и код.

Листинг 3-21 демонстрирует один из вариантов формата файла с контактами.

{caption: "Листинг 3-21. Файл с контактами `contacts.txt`", line-numbers: true, format: text}
![`contacts.txt`](code/BashScripting/contacts.txt)

Напишем скрипт для чтения этого файла. Удобнее читать контакты сразу в ассоциативный массив. Тогда механизм поиска контакта по имени останется таким же эффективным, как и раньше.

Для чтения файла нам понадобится цикл. Перед его выполнением мы не знаем, сколько итераций понадобиться. Значит, нам нужен цикл while.

Почему число итераций цикла неизвестно? Файл контактов надо читать построчно. Каждая его строка хранит одну запись. Скрипт читает запись, добавляет её в ассоциативный массив и переходит к следующей строке файла. Получается, что число итераций цикла равно числу строк. Но размер файла нам неизвестен, пока мы не прочитаем его полностью. Поэтому число итераций также неизвестно.

Для чтения строк файла применим встроенную команду интерпретатора read. Она читает строку из стандартного потока ввода. Затем сохраняет строку в переменную. Имя переменной передаётся в команду как параметр. Например:
{line-numbers: false, format: Bash}
```
read var
```

После запуска этой команды пользователь должен ввести строку. Она сохранится в переменной `var`. Если вызвать read без параметров, введённая строка сохранится в зарезервированной переменной `REPLY`.

Команда read читает введённую пользователем строку. При этом read удаляет из строки символы обратного слэша \. Они экранируют специальные символы. Поэтому read считает слэши ненужными. Чтобы отключить эту функцию, используйте опцию `-r`. В противном случае некоторые символы из ввода могут потеряться.

Команде read можно передать на вход несколько имён переменных. В этом случае введённый пользователем текст разделится на части. Разделителями будут символы из зарезервированной переменной `IFS`. По умолчанию это пробел, знак табуляции и перевод строки.

Рассмотрим пример. Предположим, что вводимые пользователем строки сохраняются в двух переменных с именами `path` и `file`. Вызов read в этом случае выглядит так:
{line-numbers: false, format: Bash}
```
read -r path file
```

Дальше пользователь вводит следующий текст:
{line-numbers: false, format: text}
```
~/Documents report.txt
```

Тогда путь `~/Documents` попадёт в переменную `path`, а имя файла `report.txt` в `file`.

Если путь содержит пробелы, произойдёт ошибка. Предположим, пользователь ввёл следующее:
{line-numbers: false, format: text}
```
~/My Documents report.txt
```

Тогда в переменную `path` попадёт строка `~/My`. В `file` запишется всё остальное: `Documents report.txt`. Не забывайте про такое поведение утилиты read.

Проблему разделения строки можно решить. Для этого переопределим зарезервированную переменную `IFS`. В качестве разделителя укажем только запятую:
{line-numbers: false, format: text}
```
IFS=$',' read -r path file
```

В этом примере мы применили специфичный для Bash [вид кавычек](http://mywiki.wooledge.org/Quotes) `$'...'`. В них не выполняются никакие подстановки. Но некоторые управляющие последовательности разрешены: `\n` (новая строка), `\\` (экранированный обратный слэш), `\t` (табуляция) и `\xnn` (байты в шестнадцатеричной системе).

Теперь следующий ввод пользователя обработается корректно:
{line-numbers: true, format: text}
```
~/My Documents,report.txt
```

Путь и имя файла разделены запятой. При этом она не встречается ни в пути, ни в имени. Поэтому ввод пользователя обработается корректно. Строка `~/My Documents` попадёт в переменную `path`, а `report.txt` — в `file`.

Команда read читает данные со стандартного потока ввода. Это значит, что ей на вход можно перенаправить содержимое файла.

Для примера прочитаем первую строку файла `contacts.txt` из листинга 3-21. Это сделает следующая команда:
{line-numbers: false, format: Bash}
```
read -r contact < contacts.txt
```

После выполнения этой команды в переменную `contact` запишется строка "Alice=alice@gmail.com". 

Имя и контактные данные можно записать в разные переменные. Для этого в качестве разделителя укажем знак равно =. Получим такую команду read:
{line-numbers: false, format: Bash}
```
IFS=$'=' read -r name contact < contacts.txt
```

Теперь имя `Alice` запишется в переменную `name`, а адрес электронной почты в `contact`.

Чтобы прочитать весь файл `contacts.txt`, напишем такой цикл while:
{line-numbers: true, format: Bash}
```
while IFS=$'=' read -r name contact < "contacts.txt"
do
  echo "$name = $contact"
done
```

К сожалению, это не сработает. Произойдёт **зацикливание**. Зацикливанием называется бесконечное повторение тела цикла из-за ошибки. Причина проблемы в том, что read всегда читает только первую строку файла и возвращает нулевой код возврата. Нулевой код в условии цикла приведёт к повторному выполнению его тела снова и снова.

Чтобы цикл while последовательно прошёл по всем строкам из потока ввода, его надо записать в следующей форме:
{line-numbers: true, format: Bash}
```
while УСЛОВИЕ
do
  ДЕЙСТВИЕ
done < ФАЙЛ
```

Чтобы обработать ввод пользователя с клавиатуры, в качестве файла укажите `/dev/tty`. Тогда цикл будет обрабатывать ввод до тех пор, пока пользователь не нажмёт сочетание клавиш Ctrl+D.

Правильный вариант цикла while для чтения файла `contacts.txt` выглядит так:
{line-numbers: true, format: Bash}
```
while IFS=$'=' read -r name contact
do
  echo "$name = $contact"
done < "contacts.txt"
```

Этот цикл выведет на экран всё содержимое файла контактов.

Нам остался последний шаг. На каждой итерации цикла будем добавлять в массив элемент, соответствующий значениям переменных `name` и `contact`.

Конечный вариант скрипта для работы с файлом контактов приведён в листинге 3.22

{caption: "Листинг 3-22. Скрипт для работы с файлом контактов", line-numbers: true, format: Bash}
![`while-contacts.sh`](code/BashScripting/while-contacts.sh)

Мы получили такое же поведение, как у скрипта из листинга 3-10.

### Оператор for

Оператор цикла `for` используется в случаях, когда количество итераций заранее известно. У него есть две формы. Первая позволяет последовательно обработать каждое слово в некоторой строке. Вторая форма в качестве условия выхода из цикла использует арифметическое выражение.

### Первая форма for

Начнём с первой формы `for` как более простой. В общем виде её можно записать так:
{line-numbers: true, format: Bash}
```
for ПЕРЕМЕННАЯ in СТРОКА
do
    ДЕЙСТВИЕ
done
```

В однострочном виде эта же конструкция выглядит так:
{line-numbers: false, format: Bash}
```
for ПЕРЕМЕННАЯ in СТРОКА; do ДЕЙСТВИЕ; done
```

ДЕЙСТВИЕ в конструкции `for` может быть одной командой или блоком команд, как и в операторе `while`.

Перед первой итерации цикла Bash выполняет все подстановки в конструкции `for`. Что это значит? Предположим, что вместо СТРОКИ вы указали команду. Тогда перед выполнением цикла она будет выполнена и будет подставлен её вывод. Если же вы указали шаблон — он будет развёрнут. Дальше СТРОКА разделяется на слова. В качестве разделителей используются символы, указанные в зарезервированной переменной `IFS`. Затем происходит выполнение первой итерации цикла. При этом каждое слово, прочитанное из СТРОКИ, будет доступно в теле цикла как значение ПЕРЕМЕННОЙ.

Рассмотрим простой пример использования `for`. Напишем скрипт, который обрабатывает каждое слово в строке, переданной ему в первом позиционном параметре. Листинг 3-23 демонстрирует код скрипта.

{caption: "Листинг 3-23. Скрипт для обработки слов в строке", line-numbers: true, format: Bash}
![`for-string.sh`](code/BashScripting/for-string.sh)

Обратите внимание, что заключать позиционный параметр `$1` в кавычки не следует. Если это сделать, разделения строки на слова (word splitting) не произойдёт и цикл выполнит только одну итерацию. В ней переменная `word` будет равна всей строке.

Передаваемую в скрипт строку напротив следует заключить в кавычки, чтобы она целиком попала в позиционный параметр `$1`. Например так:
{line-numbers: false, format: Bash}
```
./for-string.sh "this is a string"
```

Чтобы скрипт корректно обрабатывал переданную ему строку без кавычек, замените позиционный параметр `$1` на `$@` следующим образом:
{line-numbers: false, format: Bash}
```
for word in $@
```

Теперь оба варианта передачи строки будут работать корректно:
{line-numbers: true, format: Bash}
```
./for-string.sh this is a string
./for-string.sh "this is a string"
```

У конструкции `if` есть краткая форма для прохождения по всем переданным в скрипт позиционным параметрам. В этом случае мы записали условие цикла так:
{line-numbers: false, format: Bash}
```
for word in $@
```

Но того же самого результата можно добиться следующим образом:
{line-numbers: false, format: Bash}
```
for word
do
  echo "$word"
done
```

Немного усложним задачу. Предположим, что пользователь передаёт в скрипт список путей (например, к файлам), которые разделены запятыми. В путях могут встречаться пробелы. Чтобы правильно обработать такую строку, нам нужно переопределить разделитель в специальной переменной `IFS`. В результате получим скрипт, приведённый в листинге 3-24.

{caption: "Листинг 3-24. Скрипт для обработки списка путей", line-numbers: true, format: Bash}
![`for-path.sh`](code/BashScripting/for-path.sh)

В этом скрипте мы присвоили переменной `IFS` единственный символ — запятую `,`. Поэтому цикл `for` при обработке строки из параметра `$1` будет ориентироваться именно на запятые и игнорировать пробелы. Таким образом на каждой итерации в переменную `path` будет записываться один путь.

Вызов скрипта может выглядеть, например, следующим образом:
{line-numbers: false, format: Bash}
```
./for-path.sh "~/My Documents/file1.pdf,~/My Documents/report2.txt"
```

Опять же обратите внимание на обязательные кавычки для передачи строки в скрипт. В этом случае замена позиционного параметра `$1` на `$@` не поможет избавиться от них. Word splitting произойдёт до нашего переобъявления переменной `IFS`. Поэтому строка будет поделена пробелами.

Цикл `for` часто используется для прохода по всем элементам индексируемого массива. Например, как в листинге 3-25.

{caption: "Листинг 3-25. Скрипт для обработки всех элементов массива", line-numbers: true, format: Bash}
![`for-array.sh`](code/BashScripting/for-array.sh)

Если вам нужны не все элементы, а только определённые, вы можете обратиться к ним по индексам. Цикл `for` позволяет пройти по словам в строке. Мы можем использовать строку чисел, разделённых пробелами. Например, следующим образом:
{line-numbers: true, format: Bash}
```
array=(Alice Bob Eve Mallory)

for i in 0 1 2
do
    echo "${array[i]}"
done
```

Такой цикл пройдёт только по элементам с индексами 0, 1 и 2. Вместо того чтобы указывать их явно, вы можете использовать подстановку фигурных скобок. Например:
{line-numbers: true, format: Bash}
```
array=(Alice Bob Eve Mallory)

for i in {0..2}
do
    echo "${array[i]}"
done
```

Будьте осторожны при обработке массивов с пропусками подобным образом. Обратите внимание, что вариант прохода по массиву из листинга 3-25 корректно обрабатывает пропуски. Это происходит потому, что он работает не с индексами, а с самим элементами.

### Обработка списка файлов

Цикл `for` также часто применяется для обработки списка файлов. При таком его использовании есть несколько подводных камней, которые будет лучше рассмотреть на примерах.

Предположим, что вам нужно написать скрипт, который бы выводил типы всех файлов в текущем каталоге. Для вывода типа файла воспользуемся уже знакомой нам утилитой `file`. Единственное, что нам нужно сделать, это правильно написать условие цикла `for`.

Одна из самых частых ошибок начинающих программистов при написании циклов `for` это пренебрежение шаблонами. Многие в качестве СТРОКИ используют подстановку вывода утилит `ls` или `find`. Например так:
{line-numbers: true, format: Bash}
```
for filename in $(ls)
for filename in $(find . - type f)
```

Это неправильный подход. Он приводит к следующим проблемам:

1. Word splitting приведёт к тому, что содержащие пробелы имена файлов и каталогов, будут обработаны по частям за несколько итераций. 

2. Если имя файла содержит символ звёздочка `*`, перед очередной итерацией цикла будет выполнена подстановка шаблонов. Её результат будет записан в переменную `filename`. Таким образом правильное значение будет утеряно.

3. В зависимости от региональных настроек и кодировок, утилита `ls` может некорректно обрабатывать имена файлов. Это приведёт к тому, что некоторые символы в них будут заменены на знаки вопроса `?`.

Правильно всегда использовать шаблоны (globbing) в цикле `for`, если вам нужно перебрать имена файлов. В нашем случае условие цикла должно выглядеть так:
{line-numbers: false, format: Bash}
```
for filename in *
```

Полная версия скрипта приведена в листинге 3-26

{caption: "Листинг 3-26. Скрипт для вывода типов файлов", line-numbers: true, format: Bash}
![`for-file.sh`](code/BashScripting/for-file.sh)

Не забывайте про двойные кавычки при подстановке переменной `filename`. Это позволит избежать word splitting в именах файлов с пробелами.

Если вам нужно обработать список файлов из конкретного каталога, вы по-прежнему можете использовать подстановку шаблонов. Например так:
{line-numbers: false, format: Bash}
```
for filename in /usr/share/doc/bash/*
```

Если вам нужны только файлы с определённым расширением, вы опять же можете воспользоваться шаблоном. Например:
{line-numbers: false, format: Bash}
```
for filename in ~/Documents/*.pdf
```

В Bash начиная с версии 4 появилась возможность рекурсивного обхода всех каталогов при подстановке шаблона. Например:
{line-numbers: true, format: Bash}
```
shopt -s globstar

for filename in **
```

Для использования этой возможности, необходимо включить дополнительную опцию интерпретатора `globstar` с помощью встроенной команды `shopt`.

В результате подстановки `**` в конструкции `for` мы получим список всех подкаталогов и файлов в них, начиная с текущего каталога. Эту возможность можно совмещать с обычными шаблонами. Вот пример для прохода по всем файлам с расширением PDF из домашнего каталога пользователя:
{line-numbers: true, format: Bash}
```
shopt -s globstar

for filename in ~/**/*.pdf
```

Скрипт из листинга 3-26 мы могли бы заменить следующей командой `find`:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -exec file {} \;
```

Очевидно, что такое решение более предпочтительно, чем использование цикла `for`. Оно компактнее и быстрее, поскольку содержит меньше операций.

Когда же использование цикла `for` оправдано для работы с файлами и каталогами? Утилита `find` хорошо справляется в том случае, когда для обработки найденных ею объектов достаточно одной команды без дополнительных условных операторов. В противном случае вызов `find` становится громоздким и неудобным для чтения. Тогда его стоит заменить на цикл `for`.

Скрипт из листинга 3-26 можно переписать с использованием оператора `while`. Для этого ему на вход следует передать вывод утилиты `find`. При вызове `find` обязательно надо использовать опцию `-print0`. Листинг 3-27 демонстрирует такой вариант скрипта.

{caption: "Листинг 3-27. Скрипт для вывода типов файлов", line-numbers: true, format: Bash}
![`while-file.sh`](code/BashScripting/while-file.sh)

Рассмотрим этот скрипт подробнее. Прежде всего может возникнуть вопрос, почему мы переобъявили зарезервированную переменную `IFS` и присвоили ей пустое значение? Если этого не сделать, то вывод команды `find` будет разделён пробелами, знаками табуляции и перевода строки. Таким образом имена файлов и каталогов, содержащие эти символы, будут обработаны неправильно.

Второй вопрос вызывает опция `-d` команды `read`. Что она означает? С её помощью можно переопределить символ, по которому `read` будет разделять полученный текст. Таким образом в переменную `filename` будет записана часть исходной строки до очередного разделителя.

В нашем примере разделитель для команды `read` пустой. Это значит, что он равен NUL-символу. Вы также можете указать его явно. Например так:
{line-numbers: false, format: Bash}
```
while IFS= read -r -d $'\0' filename
```

С опцией `-d` команда `read` теперь сможет обработать вывод утилиты `find`, в которой в качестве разделителя тоже используется NUL-символ (благодаря опции `-print0`).

Обратите внимание, что вы не можете указать NUL-символ в качестве разделителя через зарезервированную переменную `IFS`. Другими словами следующий вариант не заработает:
{line-numbers: false, format: Bash}
```
while IFS=$'\0' read -r filename
```

Причина этого в [особенности интерпретации](https://mywiki.wooledge.org/IFS) значения переменной `IFS`. Если значение пустое, Bash вообще не выполняет word splitting.

Последний вопрос по скрипту из листинга 3-27 связан с подстановкой процесса. Почему мы не использовали подстановку команды? Например так:
{line-numbers: true, format: Bash}
```
while IFS= read -r -d '' filename
do
  file "$filename"
done < $(find . -maxdepth 1 -print0)
```

Проблема в том, что вы не можете перенаправлять результат выполнения команды таким образом. Оператор `<` связывает стандартный поток ввода с указанным файловым дескриптором. Но в случае подстановки команды никакого дескриптора нет. Bash просто вызывает утилиту `find` и подставляет её вывод. Если же использовать подстановку процессов, вывод `find` будет сохранён во временном файле, у которого будет дескриптор. Поэтому перенаправление отработает корректно.

У подстановки процессов есть одна проблема. Она специфична для Bash и не включена в POSIX-стандарт. Если вам важно следовать стандарту, используйте конвейер. Листинг 3-28 демонстрирует это решение.

{caption: "Листинг 3-28. Скрипт для вывода типов файлов", line-numbers: true, format: Bash}
![`while-file-pipe.sh`](code/BashScripting/while-file-pipe.sh)

Если вам требуется пройти по файлам, полученным в результате поиска со сложным условием, всегда предпочитайте комбинацию утилиты `find` с циклом `while`, а не `for`. Тогда с помощью команды `read` вы сможете разделить результаты поиска NUL-символом. Это позволит избежать ошибок с именами файлов и каталогов, использующих пробелы и другие специальные символы.

### Вторая форма for

Во второй форме `for` в качестве условия цикла используется арифметическое выражение. В каких случаях это окажется полезным? Чтобы ответить на этот вопрос, рассмотрим пример.

Предположим, вы пишете скрипт для расчёта факториала. Если число, для которого он рассчитывается заранее известно, вы можете использовать первую форму оператора `for`. Например так, как демонстрирует листинг 3-29.

{caption: "Листинг 3-29. Скрипт для расчёта факториала числа 5", line-numbers: true, format: Bash}
![`for-factorial-brace.sh`](code/BashScripting/for-factorial-brace.sh)

Но допустим, что число для расчёта должно передаваться в скрипт через позиционный параметр `$1`. Тогда вы можете предложить следующий вариант условия цикла `for`:
{line-numbers: false, format: Bash}
```
for i in {1..$1}
```

Такой вариант не заработает. Почему? Согласно таблице 3-2, подстановка фигурных скобок выполняется до подстановки параметров. Поэтому вместо строки "1 2 3 4 5" в условии цикла, вы получите строку "{1..$1}". Эта строка попадёт в переменную `i`, и следующий далее арифметический оператор `((` просто не сможет её корректно обработать.

Проблему можно решить с помощью утилиты `seq`. Она принимает на вход один, два или три параметра. Таблица 3-21 демонстрирует каждый из вариантов вызова утилиты.

{caption: "Таблица 3-21. Параметры утилиты `seq`", width: "100%"}
| Число параметров | Описание параметров | Пример команды | Результат |
| --- | --- | --- | --- |
| 1 | Последнее число в генерируемой последовательности, которая начинается с единицы. | `seq 5` | 1 2 3 4 5 |
| 2 | Первое и последнее число в последовательности. | `seq -3 3` | -2 -1 0 1 2 |
| 3 | Первое число, шаг и последнее число в последовательности. | `seq 1 2 5` | 1 3 5 |

В выводе утилиты `seq` по умолчанию в качестве разделителя используется управляющий символ перевода строки `\n`. Его можно заменить на любой другой с помощью опции `-s`. Перевод строки входит в обычный список разделителей специальной переменной `IFS`. Поэтому в конструкции `for` можно использовать `seq` без опции `-s`.

I> В таблице 3-20 перевод строки был заменён на пробел в столбце "Результат" для удобства.

С помощью утилиты `seq` мы сможем написать параметризуемый скрипт расчёта факториала. Он приведён в листинге 3-30.

{caption: "Листинг 3-30. Скрипт для расчёта факториала", line-numbers: true, format: Bash}
![`for-factorial-seq.sh`](code/BashScripting/for-factorial-seq.sh)

Это решение работает, но его нельзя назвать эффективным. Нам пришлось вызывать стороннюю утилиту для подготовки условия цикла `for`. Такой вызов можно сравнить с запуском обычной программы (например, текстового редактора). Ядру ОС требуется значительное по меркам CPU время для создания нового процесса, в котором запущенная программа будет исполняться. Поэтому было бы лучше, если бы мы обошлись встроенными средствами Bash в нашем цикле `for`.

Именно для подобных задач создавалась вторая форма оператора `for`. В общем виде её можно записать так:
{line-numbers: true, format: Bash}
```
for (( ВЫРАЖЕНИЕ_1; ВЫРАЖЕНИЕ_2; ВЫРАЖЕНИЕ_3 ))
do
    ДЕЙСТВИЕ
done
```

В однострочном виде эта конструкция выглядит так:
{line-numbers: false, format: Bash}
```
for (( ВЫРАЖЕНИЕ_1; ВЫРАЖЕНИЕ_2; ВЫРАЖЕНИЕ_3 )); do ДЕЙСТВИЕ; done
```

Алгоритм выполнения цикла `for` с арифметическим условием следующий:

1. ВЫРАЖЕНИЕ_1 выполняется однократно перед первой итерацией цикла.

2. Цикл выполняется до тех пор, пока ВЫРАЖЕНИЕ_2 остаётся истинным. Как только оно вернуло ложь в качестве результата, цикл завершается.

3. В конце каждой итерации выполняется ВЫРАЖЕНИЕ_3.

Перепишем скрипт из листинга 3-30, заменив вызов утилиты `seq` в цикле `for` на арифметическое выражение. Результат приведён в листинге 3-31.

{caption: "Листинг 3-31. Скрипт для расчёта факториала", line-numbers: true, format: Bash}
![`for-factorial.sh`](code/BashScripting/for-factorial.sh)

Преимущество этого скрипта в том, что он использует только встроенные операторы Bash. Для их выполнения не требуется создания новых процессов. Поэтому в общем случае такое решение будет эффективнее.

Рассмотрим алгоритм выполнения конструкции `for` в нашем скрипте:

1. Перед первой итерацией цикла объявляется переменная `i`, равная единице.

2. Выполняется проверка условия `i <= $1`. На первой итерации `i` равна единице, а позиционный параметр `$1` переданному в скрипт числу (например, 5). Если условие выполняется, возвращается код возврата ноль.

3. Если условие вернуло ноль, выполняется первая итерация цикла. В противном случае цикл завершается.

4. В теле цикла вычисляется арифметическое выражение `result *= i`. В результате значение переменной `result` будет умножено на `i` (единицу для первой итерации).

5. После выполнения первой итерации, вычисляется третье выражение `++i` в условии цикла. В результате значение переменной `i` станет равно двум.

6. Переход ко второму шагу алгоритма с проверкой условия `i <= $1` и в случае кода возврата ноль выполнение следующей итерации цикла.

I> В общем случае переменные в операторе `((` и команде `let` можно указывать без знака доллара `$`. Однако, в нашем скрипте он необходим при подстановке позиционного параметра `$1` в условии цикла. Если этого не сделать, Bash не выполнит подстановку, а вместо этого будет работать с единицей как с обычным числом.

Обратите внимание, что в цикле используется префиксная форма инкремента. Как вы помните, её предпочтительнее использовать вместо постфиксной формы по причине лучшей производительности.

Вторая форма оператора `for` также окажется полезна, когда значение счётчика цикла рассчитывается по какой-то формуле. В этом случае утилиты `seq` будет недостаточно.

### Управление циклом

Любой цикл завершается согласно своему условию. Однако есть дополнительные средства управления циклом. Они позволяют прервать его выполнение или пропустить текущую итерацию. Рассмотрим их подробнее.

#### break

Встроенная команда `break` позволяет немедленно прекратить выполнение цикла и выйти из него. Она может быть полезна при обработке ошибок или для завершения бесконечного цикла.

Для примера предположим, что вы пишете скрипт поиска элемента индексируемого массива с определённым значением. В этом случае как только вы его нашли, нет смысла продолжать цикл. Можно сразу выйти из него. Листинг 3-32 демонстрирует такой скрипт.

{caption: "Листинг 3-32. Скрипт поиска элемента в массиве", line-numbers: true, format: Bash}
![`for-break.sh`](code/BashScripting/for-break.sh)

Здесь для хранения результатов поиска мы используем переменную `is_found`. Как только найден элемент массива, равный переданному в скрипт позиционному параметру `$1`, переменной `is_found` присваивается единица и выполнение цикла прерывается командой `break`. Далее в операторе `if` проверяется значение `is_found` и в зависимости от него выводится сообщение о результате поиска. Если ни один из элементов массива не равен параметру `$1`, переменная `is_found` останется равной нулю.

Команда `break` используется, когда необходимо продолжить выполнение скрипта после оператора цикла. Как, например, в листинге 3-32 результаты поиска выводятся в следующей за циклом конструкции `if`.

В некоторых случаях вместо команды `break` предпочтительнее использовать `exit`. Это оправдано, когда выполнение скрипта после цикла не имеет смысла. Например, в случае обнаружения ошибки или вывода результата сразу в цикле. Перепишем скрипт из листинга 3-32 с использованием команды `exit` вместо `break`. Результат приведён в листинге 3-33.

{caption: "Листинг 3-33. Скрипт поиска элемента в массиве", line-numbers: true, format: Bash}
![`for-exit.sh`](code/BashScripting/for-exit.sh)

Результат работы скриптов из листинга 3-22 и 3-23 полностью совпадает. Использование команды `exit` позволило написать более компактный код без вспомогательной переменной `is_found` и конструкции `if`. Поэтому всегда рассматривайте такой вариант выхода из цикла.

#### continue

Встроенная команда `continue` не прерывает цикл, но прекращает исполнение текущей итерации. Цикл продолжит выполняться, но уже со следующей итерации.

Предположим, что вы обрабатываете массив чисел. В нём вас интересуют только положительные числа, сумму которых надо рассчитать. В этом случае можно воспользоваться конструкцией `if` для проверки знака. Возможный вариант решения приведён в листинге 3-34.

{caption: "Листинг 3-34. Скрипт для расчёта суммы положительных чисел в массиве", line-numbers: true, format: Bash}
![`for-sum.sh`](code/BashScripting/for-sum.sh)

Если `element` оказался больше нуля (то есть он является положительным числом), его значение добавляется к результирующей сумме `sum`.

Этого же поведения можно добиться с помощью команды `continue`, как демонстрирует листинг 3-35.

{caption: "Листинг 3-35. Скрипт для расчёта суммы положительных чисел в массиве", line-numbers: true, format: Bash}
![`for-continue.sh`](code/BashScripting/for-continue.sh)

Что изменилось? Мы инвертировали условие в конструкции `if`. Теперь оно выполняется для отрицательных чисел. В этом случае вызывается команда `continue`. Благодаря ей, текущая итерация цикла прерывается, то есть следующая за конструкцией `if` арифметическая операция не выполняется. Вместо этого происходит переход к следующей итерации цикла, что означает обработку следующего элемента массива.

Команда `continue` позволяет реализовать уже известную нам технику раннего возврата в контексте цикла. Предпочитайте использовать эту команду для обработки ошибок и условий, которые требуют немедленного переход к следующей итерации цикла. Это позволит вам избежать вложенных конструкций `if` и сделает код более понятным и удобным для чтения.

{caption: "Упражнение 3-12. Использование операторов цикла", format: text, line-numbers: false}
```
Напишите игру "Больше-Меньше". В ней один участник загадывает число от 1 до 100. Второй участник пытается его отгадать за семь попыток. Ваш скрипт должен загадывать число и давать подсказки игроку в ответ на вводимые им варианты.
```
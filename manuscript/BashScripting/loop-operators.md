## Операторы цикла

Условные операторы нужны для управления [**порядком выполнения**](https://ru.wikipedia.org/wiki/Порядок_выполнения) программы. Под этим термином понимают последовательность, в которой выполняются операторы, команды и инструкции запущенной программы.

Условные операторы позволяют выбирать ветвь исполнения в зависимости от значений логических выражений. В некоторых случаях этого оказывается недостаточно и требуются дополнительные средства управления. Поэтому практически все высокоуровневые языки программирования имеют [**операторы цикла**](https://ru.wikipedia.org/wiki/Цикл_(программирование)).

Оператор цикла нужен для многократного повторения одного и того же блока команд. Выход из такой конструкции происходит по условию, которое обычно представляет собой логическое выражение.

### Повторение команд

Для чего может понадобиться многократно выполнять один и тот же блок команд? Чтобы ответить на этот вопрос, рассмотрим несколько примеров.

Команда `find` нам уже хорошо знакома. Она ищет файлы и каталоги на жёстком диске. Её опция `-exec` позволяет указать действие, которое будет выполнено над каждым найденным объектом. Например, следующая команда удаляет все PDF документы пользователя:
{line-numbers: false, format: Bash}
```
find ~/Documents -name "*.pdf" -exec rm {} \;
```

В этом случае утилита `rm` вызывается многократно. В качестве параметра ей передаётся очередной результат поиска `find`. Можно сказать, что утилита `find` неявно (внутри себя) выполняет оператор цикла. Условием выхода из него будет окончание списка найденных файлов.

Ещё одним примером многократного выполнения одних и тех же действий является утилита `du`. Как вы помните, она оценивает объём использованного дискового пространства. В качестве параметра можно указать путь, начиная с которого будет происходить оценка. Например так:
{line-numbers: false, format: Bash}
```
du ~/Documents
```

В результате выполнения этой команды утилита рекурсивно обойдёт все подкаталоги, находящиеся по пути `~/Documents`. Размер каждого найденного в них файла будет добавлен к конечному результату. Это означает, что операция сложения будет повторяться снова и снова.

Можно предположить, что утилита `du` выполняет цикл при переборе всех файлов каждого найденного ею каталога. Для каждого файла читается его размер, который прибавляется к конечному результату.

Повторение одних и тех же операций часто встречается в математических расчётах. Каноничным примером считается вычисление [**факториала**](https://ru.wikipedia.org/wiki/Факториал). Факториалом какого-либо числа N называется произведение последовательных натуральных чисел от 1 до N включительно. Например, факториал числа 4 рассчитывается следующим образом:
{line-numbers: false, format: Bash}
```
4! = 1 * 2 * 3 * 4 = 24
```

Факториал может быть легко рассчитан с помощью оператора цикла. Для этого цикл должен последовательно перебирать целые числа от 1 до N. Каждое из них должно умножаться на конечный результат. В этом случае операция умножения повторяется.

Последний наш пример с повторением действий связан с событиями в системе. Представьте, что вы пишете программу, которая загружает на компьютер файлы из интернета. В начале своей работы программа устанавливает соединение с сервером. Если ответ от сервера не получен сразу, у программы есть два варианта действий. Первый — завершить выполнение с кодом возврата, отличным от нуля. Второй — ожидать ответа. Второй вариант практически всегда окажется предпочтительнее. Есть много причин, по которым ответ от сервера может прийти с задержкой. Например, перегрузка сети или самого сервера. Двух-трёхсекундного ожидания может оказаться достаточно, чтобы ответ пришёл и наша программа продолжила выполнение.

Самый простой способ реализовать ожидание какого-либо события в программе, это использовать оператор цикла. В нём проверяется условие наступления события. В нашем примере — это получение ответа от сервера. До тех пор, пока событие не наступило, цикл продолжается. При этом в его блоке команд могут отсутствовать какие-либо действия (пустой цикл). Альтернативный вариант — вызывать в цикле команду остановки выполнения программы на заданный промежуток времени. Такая техника называется **активным ожиданием** событий или [**busy-waiting**](https://en.wikipedia.org/wiki/Busy_waiting).

Мы рассмотрели следующие задачи, требующие повторения одних и тех же действий:

1. Однообразная обработка нескольких сущностей. Например, результатов поиска команды `find`.

2. Накопление конечного результата из промежуточных данных. Например, сбор статистики утилитой `du`.

3. Математические расчёты. Например, вычисление факториала.

4. Ожидание наступления какого-либо события. Например, получение ответа от сервера по сети.

Этот список далеко не полный. Он включает только наиболее часто встречающиеся в программировании задачи, для решения которых требуются операторы цикла.

### Оператор while

В Bash есть два оператора цикла (`while` и `for`), у каждого из которых есть две формы. Начнём наше изучение с самого простого из них — оператора `while`. Его синтаксис напоминает условную конструкцию `if`. В общем виде его можно записать следующим образом:
{line-numbers: true}
```
while УСЛОВИЕ
do
    ДЕЙСТВИЕ
done
```

Запись оператора в одну строку будет выглядеть так:
{line-numbers: false}
```
while УСЛОВИЕ; do ДЕЙСТВИЕ; done
```

УСЛОВИЕ и ДЕЙСТВИЕ в конструкции `while` могут быть одной командой или блоком команд, как и в конструкции `if`. Сначала проверяется УСЛОВИЕ. Если оно завершилось успешно с кодом возврата ноль, выполняется ДЕЙСТВИЕ. После этого опять проверяется УСЛОВИЕ и, если его код возврата по-прежнему ноль, снова выполняется ДЕЙСТВИЕ. Цикл прервётся тогда, когда УСЛОВИЕ вернёт результат, отличный от нуля.

Цикл `while` применяется в случаях, когда количество итераций заранее неизвестно. Типичный пример такой ситуации — это ожидание наступления какого-либо события. Рассмотрим пример.

Напишем скрипт, для проверки доступности какого-либо сервера в интернете. Чтобы выполнить такую проверку, нам необходимо отправить серверу запрос и получить от него ответ. Как только ответ будет получен, скрипт может вывести сообщение на экран и завершить свою работу.

Для обращения к серверу воспользуемся утилитой [`ping`](https://ru.wikipedia.org/wiki/Ping). Она посылает [ICMP](https://ru.wikipedia.org/wiki/ICMP) echo-запросы на удалённый сетевой [хост](https://ru.wikipedia.org/wiki/Хост) и получает от него echo-ответы. В качестве параметра утилита принимает [URL](https://ru.wikipedia.org/wiki/URL) или [IP-адрес](https://ru.wikipedia.org/wiki/IP-адрес) целевого хоста.

Вы можете вызвать утилиту `ping` из командной строки следующим образом:
{line-numbers: false, format: Bash}
```
ping google.com
```

Таким образом вы обратитесь к одному из серверов поисковой системы Google. После запуска команды вы увидите примерно следующий вывод:
{line-numbers: true, format: Bash}
```
PING google.com (172.217.21.238) 56(84) bytes of data.
64 bytes from fra16s13-in-f14.1e100.net (172.217.21.238): icmp_seq=1 ttl=51 time=17.8 ms
64 bytes from fra16s13-in-f14.1e100.net (172.217.21.238): icmp_seq=2 ttl=51 time=18.5 ms
```

Это подробная информация о каждом отправленном echo-запросе и полученном на него echo-ответе. Сейчас утилита работает в бесконечном цикле. Чтобы её остановить, нажмите комбинацию клавиш Ctrl+C.

Для проверки доступности сервера будет достаточно отправить только один echo-запрос. Для этого воспользуемся опцией `-c` утилиты `ping`. Эта опция позволяет указать число отправляемых пакетов. С ней вызов `ping` будет выглядеть так:
{line-numbers: false, format: Bash}
```
ping -c 1 google.com
```

Если сервер `google.com` доступен, утилита вернёт код возврата ноль. В противном случае он будет ненулевым.

Добавим к нашему вызову `ping` опцию `-W`, чтобы задать таймаут ожидания ответа от сервера. Одной секунды будет достаточно. Получится следующий вызов:
{line-numbers: false, format: Bash}
```
ping -c 1 -W 1 google.com
```

Теперь запишем конструкцию `while`, в которой вызов утилиты `ping` будет выполнять роль условия. Получим следующее:
{line-numbers: true, format: Bash}
```
while ! ping -c 1 -W 1 google.com &> /dev/null
do
    sleep 1
done
```

Нам не интересен вывод утилиты, поэтому перенаправляем его в файл `/dev/null`. В условии цикла мы инвертировали результат вызова `ping`. Это значит, что пока утилита возвращает отличный от нуля код (то есть сервер недоступен), будет выполняться тело цикла. В качестве действия вызывается утилита `sleep`. Она останавливает выполнение скрипта на указанное количество секунд. В нашем примере остановка длится одну секунду.

I> Вы можете указать суффикс для параметра утилиты `sleep`. Секундам соответствует суффикс `s` (например, `5s`), минутам — `m`, часам — `h` и дням — `d`.

Листинг 3-18 демонстрирует полный скрипт для ожидания ответа от сервера. Когда ответ получен, на консоль выводится сообщение.

{caption: "Листинг 3-18. Скрипт для ожидания ответа от сервера", line-numbers: true, format: Bash}
![`while-ping.sh`](code/BashScripting/while-ping.sh)

У конструкции `while` есть альтернативная форма `until`. Её единственное отличие заключается в том, что ДЕЙСТВИЕ выполняется до тех пор, пока УСЛОВИЕ ложно, т.е. возвращает отличный от нуля код. Другими словами `until` позволяет инвертировать условие цикла `while`.

В общем виде конструкцию `until` можно записать так:
{line-numbers: true}
```
until УСЛОВИЕ
do
    ДЕЙСТВИЕ
done
```

Запись оператора в одну строку аналогична циклу `while`:
{line-numbers: false}
```
until УСЛОВИЕ; do ДЕЙСТВИЕ; done
```

Перепишем наш скрипт для ожидания ответа от сервера с помощью конструкции `until`. Для этого удалим логическое отрицание результата вызова утилиты `ping`. Получится скрипт, приведённый в листинге 3-19.

{caption: "Листинг 3-19. Скрипт для ожидания ответа от сервера", line-numbers: true, format: Bash}
![`until-ping.sh`](code/BashScripting/until-ping.sh)

Его поведение полностью совпадает со скриптом из листинга 3-18.

Выбирайте форму `while` или `until` в зависимости от условия цикла. Всегда старайтесь составлять условия так, чтобы по возможности избегать отрицаний. Они усложняют чтение кода и способствуют ошибкам.

#### Бесконечный цикл

Конструкция `while` часто применяется в [**бесконечных циклах**](https://ru.wikipedia.org/wiki/Бесконечный_цикл). Такие циклы никогда не завершаются и выполняются пока работает программа или скрипт. Они используются в системных программах, которые не должны завершаться (например, ОС или прошивки микроконтроллеров), а также компьютерных играх. Бесконечные циклы могут быть полезны в Bash для вывода разного рода статистики.

Чтобы цикл `while` был бесконечным, его условие должно всегда быть истинным. Самый простой способ этого добиться — использовать встроенную команду интерпретатора `true`. Например, следующим образом:
{line-numbers: true, format: Bash}
```
while true
do
	sleep 1
done
```

Команда `true` всегда возвращает истину, то есть код возврата ноль. У неё есть симметричная команда `false`, которая всегда возвращает единицу.

I> Во многих языках программирования `true` и `false` являются [**литералами**](https://ru.wikipedia.org/wiki/Литерал_(информатика)), то есть зарезервированными словами, обозначающими значение истина и ложь. Но в Bash это встроенные команды интерпретатора.

Вместо `true` вы также можете использовать двоеточие `:`. Тогда бесконечный `while` цикл будет выглядеть так:
{line-numbers: true, format: Bash}
```
while :
do
	sleep 1
done
```

Команда двоеточие является синонимом `true`. Она нужна для [совместимости](https://stackoverflow.com/questions/3224878/what-is-the-purpose-of-the-colon-gnu-bash-builtin) с Bourne shell, в котором `true` и `false` не было. Все три команды (`:`, `true`, `false`) включены в POSIX-стандарт.

Рассмотрим пример использования бесконечного цикла. Предположим, что вам нужно периодически выводить статистику об использовании дискового пространства в вашей системе. Для вывода этой информации можно воспользоваться утилитой `df`. При вызове её без параметров выводится статистика ждя каждого смонтированного диска в байтах. Например, следующим образом:
{line-numbers: true, format: Bash}
```
$ df
Filesystem     1K-blocks      Used Available Use% Mounted on
C:/msys64       41940988  24666880  17274108  59% /
Z:             195059116 110151748  84907368  57% /z
```

Если указать опцию `-h`, занятое и свободное дисковые пространства будут указаны в мегабайтах и гигабайтах. Также вы можете добавить опцию `-T`, чтобы вывести тип файловой системы для каждого диска. В результате вы полчите такой вывод:
{line-numbers: true, format: Bash}
```
$ df -hT
Filesystem     Type  Size  Used Avail Use% Mounted on
C:/msys64      ntfs   40G   24G   17G  59% /
Z:             hgfs  187G  106G   81G  57% /z
```

Если вам нужна информация обо всех точках монтирования, укажите опцию `-a`.

Будем вызывать утилиту `df` в бесконечном цикле каждые две секунды. Таким образом вы получите простейший скрипт для наблюдения за файловой системой. Он продемонстрирован в листинг 3-20.

{caption: "Листинг 3-20. Скрипт для наблюдения за файловой системой", line-numbers: true, format: Bash}
![`while-df.sh`](code/BashScripting/while-df.sh)

В начало цикла был добавлен вызов утилиты `clear`. Она очищает окно терминала от текста. Благодаря этому, в терминале будет только вывод нашего скрипта без какой-либо лишней информации.

Задача циклического выполнения команд с заданным интервалом встречается настолько часто, что для неё была разработана специальная утилита `watch` из пакета `procps`. Чтобы установить этот пакет под MSYS2, выполните следующую команду:
{line-numbers: false, format: Bash}
```
pacman -S procps
```

Теперь вы можете добиться поведения скрипта из листинга 3-20 всего одной командой:
{line-numbers: false, format: Bash}
```
watch -n 2 "df -hT"
```

Опция `-n` задаёт интервал между вызовами команды, которая идёт следующим параметром. Ещё одна полезная опция `watch` — это `-d`. Она позволяет подсветить разницу в выводе команды, выполненной на текущей итерации и на прошлой. Благодаря этому, вам будет легче отследить произошедшие изменения.

#### Чтение ассоциативного массива из файла

В качестве последнего примера использования цикла `while` рассмотрим чтение ассоциативного массива из файла.

// TODO:

while IFS== read -r key value
do
    ary[$key]=$value
done < "$fileName"

### Цикл for

// TODO

### Управление циклом

// TODO: continue, break
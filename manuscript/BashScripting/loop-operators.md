## Операторы цикла

Условные операторы нужны для управления [**порядком выполнения**](https://ru.wikipedia.org/wiki/Порядок_выполнения) программы. Под этим термином понимают последовательность, в которой выполняются операторы, команды и инструкции запущенной программы.

Условные операторы позволяют выбирать ветвь исполнения в зависимости от значений логических выражений. В некоторых случаях этого оказывается недостаточно и требуются дополнительные средства управления. Поэтому практически все высокоуровневые языки программирования имеют [**операторы цикла**](https://ru.wikipedia.org/wiki/Цикл_(программирование)).

Оператор цикла нужен для многократного повторения одного и того же блока команд. Выход из такой конструкции происходит по условию, которое обычно представляет собой логическое выражение.

### Повторение команд

Для чего может понадобиться многократно выполнять один и тот же блок команд? Чтобы ответить на этот вопрос, рассмотрим несколько примеров.

Команда `find` нам уже хорошо знакома. Она ищет файлы и каталоги на жёстком диске. Её опция `-exec` позволяет указать действие, которое будет выполнено над каждым найденным объектом. Например, следующая команда удаляет все PDF документы пользователя:
{line-numbers: false, format: Bash}
```
find ~/Documents -name "*.pdf" -exec rm {} \;
```

В этом случае утилита `rm` вызывается многократно. В качестве параметра ей передаётся очередной результат поиска `find`. Можно сказать, что утилита `find` неявно (внутри себя) выполняет оператор цикла. Условием выхода из него будет окончание списка найденных файлов.

Ещё одним примером многократного выполнения одних и тех же действий является утилита `du`. Как вы помните, она оценивает объём использованного дискового пространства. В качестве параметра можно указать путь, начиная с которого будет происходить оценка. Например так:
{line-numbers: false, format: Bash}
```
du ~/Documents
```

В результате выполнения этой команды утилита рекурсивно обойдёт все подкаталоги, находящиеся по пути `~/Documents`. Размер каждого найденного в них файла будет добавлен к конечному результату. Это означает, что операция сложения будет повторяться снова и снова.

Можно предположить, что утилита `du` выполняет цикл при переборе всех файлов каждого найденного ею каталога. Для каждого файла читается его размер, который прибавляется к конечному результату.

Повторение одних и тех же операций часто встречается в математических расчётах. Каноничным примером считается вычисление [**факториала**](https://ru.wikipedia.org/wiki/Факториал). Факториалом какого-либо числа N называется произведение последовательных натуральных чисел от 1 до N включительно. Например, факториал числа 4 рассчитывается следующим образом:
{line-numbers: false, format: Bash}
```
4! = 1 * 2 * 3 * 4 = 24
```

Факториал может быть легко рассчитан с помощью оператора цикла. Для этого цикл должен последовательно перебирать целые числа от 1 до N. Каждое из них должно умножаться на конечный результат. В этом случае операция умножения повторяется.

Последний наш пример с повторением действий связан с событиями в системе. Представьте, что вы пишете программу, которая загружает на компьютер файлы из интернета. В начале своей работы программа устанавливает соединение с сервером. Если ответ от сервера не получен сразу, у программы есть два варианта действий. Первый — завершить выполнение с кодом возврата, отличным от нуля. Второй — ожидать ответа. Второй вариант практически всегда окажется предпочтительнее. Есть много причин, по которым ответ от сервера может прийти с задержкой. Например, перегрузка сети или самого сервера. Двух-трёхсекундного ожидания может оказаться достаточно, чтобы ответ пришёл и наша программа продолжила выполнение.

Самый простой способ реализовать ожидание какого-либо события в программе, это использовать оператор цикла. В нём проверяется условие наступления события. В нашем примере — это получение ответа от сервера. До тех пор, пока событие не наступило, цикл продолжается. При этом в его блоке команд могут отсутствовать какие-либо действия (пустой цикл). Альтернативный вариант — вызывать в цикле команду остановки выполнения программы на заданный промежуток времени. Такая техника называется **активным ожиданием** событий или [**busy-waiting**](https://en.wikipedia.org/wiki/Busy_waiting).

Мы рассмотрели следующие задачи, требующие повторения одних и тех же действий:

1. Однообразная обработка нескольких сущностей. Например, результатов поиска команды `find`.

2. Накопление конечного результата из промежуточных данных. Например, сбор статистики утилитой `du`.

3. Математические расчёты. Например, вычисление факториала.

4. Ожидание наступления какого-либо события. Например, получение ответа от сервера по сети.

Этот список далеко не полный. Он включает только наиболее часто встречающиеся в программировании задачи, для решения которых требуются операторы цикла.

### Оператор while

В Bash есть два оператора цикла. Каждый из них имеет по две формы. Начнём наше изучение с самого простого оператора `while`. Его синтаксис напоминает условную конструкцию `if`. В общем виде его можно записать следующим образом:
{line-numbers: true}
```
while УСЛОВИЕ
do
    ДЕЙСТВИЕ
done
```

При записи оператора в одну строку, он будет выглядеть так:
{line-numbers: false}
```
while УСЛОВИЕ; do ДЕЙСТВИЕ; done
```

УСЛОВИЕ и ДЕЙСТВИЕ в конструкции `while` представляют собой одну команду или блок команд, как и в конструкции `if`. Сначала проверяется УСЛОВИЕ. Если оно завершилось успешно с кодом возврата 0, выполняется ДЕЙСТВИЕ. После этого опять проверяется УСЛОВИЕ и, если его код возврата по прежнему 0, снова выполняется ДЕЙСТВИЕ. Цикл прервётся тогда, когда УСЛОВИЕ вернёт отличный от 0 результат.

Цикл `while` применяется в случаях, когда заранее неизвестно, сколько потребуется итераций. Типичный пример такой ситуации — это ожидание наступления какого-либо события. Рассмотрим пример.

Напишем скрипт, который ожидает ответ от сервера. Как только ответ получен, скрипт выводит сообщение на экран и завершает свою работу. Для обращения к серверу воспользуемся утилитой [`ping`](https://ru.wikipedia.org/wiki/Ping). Она посылает [ICMP](https://ru.wikipedia.org/wiki/ICMP) echo-запросы на удалённый сетевой [хост](https://ru.wikipedia.org/wiki/Хост) и получает от него echo-ответы. В качестве параметра утилита принимает [URL](https://ru.wikipedia.org/wiki/URL) или [IP-адрес](https://ru.wikipedia.org/wiki/IP-адрес) целевого хоста.

Вы можете вызвать утилиту `ping` из командной строки следующим образом:
{line-numbers: false, format: Bash}
```
ping google.com
```

Таким образом вы обратитесь к одному из серверов поисковика Google. После запуска команды вы увидите примерно следующий вывод:
{line-numbers: true, format: Bash}
```
PING google.com (172.217.21.238) 56(84) bytes of data.
64 bytes from fra16s13-in-f14.1e100.net (172.217.21.238): icmp_seq=1 ttl=51 time=17.8 ms
64 bytes from fra16s13-in-f14.1e100.net (172.217.21.238): icmp_seq=2 ttl=51 time=18.5 ms
```

Это подробная информация о каждом отправленном echo-запросе и полученном echo-ответе. Сейчас утилита работает в бесконечном цикле. Чтобы её остановить, нажмите комбинацию клавишь Ctrl+C.

Наш скрипт должен запускать утилиту `ping` таким образом, чтобы она посылала только один echo-запрос. Для этого воспользуемся её опцией `-c`. Она позволяет указать число отправляемых пакетов. Тогда вызов утилиты будет выглядеть так:
{line-numbers: false, format: Bash}
```
ping -c 1 google.com
```

Если сервер `google.com` доступен, утилита вернёт код возврата 0. В противном случае, он будет ненулевым.

Теперь запишем конструкцию `while`, в которой вызов утилиты `ping` будет выполнять роль условия. Получим следующее:
{line-numbers: true, format: Bash}
```
while ! ping -c 1 google.com &> /dev/null
do
	sleep 1
done
```

В условии цикла мы инвертировали результат вызова `ping`. Это значит, что пока утилита возвращает отличный от нуля код (то есть сервер недоступен), будет выполняться тело цикла. В качестве действия вызывается утилита `sleep`. Она останавливает выполнение скрипта на указанное количество секунд. В нашем примере остановка длится одну секунду.

I> Вы можете указать суффикс для параметра утилиты `sleep`. Секундам соответствует суффикс `s` (например, `5s`), минутам — `m`, часам — `h` и дням — `d`.

Листинг 3-18 демонстрирует полный скрипт для ожидания ответа от сервера. Когда ответ получен, на консоль выводится сообщение.

{caption: "Листинг 3-18. Скрипт для ожидания ответа от сервера", line-numbers: true, format: Bash}
![`while-ping.sh`](code/BashScripting/while-ping.sh)

У конструкции `while` есть альтернативная форма `until`. Её единственное отличие заключается в том, что ДЕЙСТВИЕ выполняется до тех пор, пока УСЛОВИЕ ложно, т.е. возвращает отличный от нуля код. Другими словами `until` позволяет инвертировать условие цикла `while`.

В общем виде конструкцию `until` можно записать так:
{line-numbers: true}
```
until УСЛОВИЕ
do
    ДЕЙСТВИЕ
done
```

Запись оператора в одну строку аналогична циклу `while`:
{line-numbers: false}
```
until УСЛОВИЕ; do ДЕЙСТВИЕ; done
```

Перепишем наш скрипт для ожидания ответа от сервера с помощью конструкции `until`. Для этого удалим логическое отрицание результата вызова утилиты `ping`. Получится скрипт, приведённый в листинге 3-19.

{caption: "Листинг 3-19. Скрипт для ожидания ответа от сервера", line-numbers: true, format: Bash}
![`until-ping.sh`](code/BashScripting/until-ping.sh)

Его поведение полностью совпадает со скриптом из листинга 3-18.

Выбирайте форму `while` или `until` в зависимости от условия цикла. Всегда старайтесь составлять условия так, чтобы по возможности избегать отрицаний. Они усложняют чтение кода и способствуют ошибкам.

### Цикл for
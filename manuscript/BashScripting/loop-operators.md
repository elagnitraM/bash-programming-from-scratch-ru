## Операторы цикла

Условные операторы нужны для управления [**порядком выполнения**](https://ru.wikipedia.org/wiki/Порядок_выполнения) программы. Под этим термином понимают последовательность, в которой выполняются операторы, команды и инструкции запущенной программы.

Условные операторы позволяют выбирать ветвь исполнения в зависимости от значений логических выражений. В некоторых случаях этого оказывается недостаточно и требуются дополнительные средства управления. Поэтому практически все высокоуровневые языки программирования имеют [**операторы цикла**](https://ru.wikipedia.org/wiki/Цикл_(программирование)).

Оператор цикла нужен для многократного повторения одного и того же блока команд. Выход из такой конструкции происходит по условию, которое обычно представляет собой логическое выражение.

### Повторение команд

Для чего может понадобиться многократно выполнять один и тот же блок команд? Чтобы ответить на этот вопрос, рассмотрим несколько примеров.

Команда `find` нам уже хорошо знакома. Она ищет файлы и каталоги на жёстком диске. Её опция `-exec` позволяет указать действие, которое будет выполнено над каждым найденным объектом. Например, следующая команда удаляет все PDF документы пользователя:
{line-numbers: false, format: Bash}
```
find ~/Documents -name "*.pdf" -exec rm {} \;
```

В этом случае утилита `rm` вызывается многократно. В качестве параметра ей передаётся очередной результат поиска `find`. Можно сказать, что утилита `find` неявно (внутри себя) выполняет оператор цикла. Условием выхода из него будет окончание списка найденных файлов.

Ещё одним примером многократного выполнения одних и тех же действий является утилита `du`. Как вы помните, она оценивает объём использованного дискового пространства. В качестве параметра можно указать путь, начиная с которого будет происходить оценка. Например так:
{line-numbers: false, format: Bash}
```
du ~/Documents
```

В результате выполнения этой команды утилита рекурсивно обойдёт все подкаталоги, находящиеся по пути `~/Documents`. Размер каждого найденного в них файла будет добавлен к конечному результату. Это означает, что операция сложения будет повторяться снова и снова.

Можно предположить, что утилита `du` выполняет цикл при переборе всех файлов каждого найденного ею каталога. Для каждого файла читается его размер, который прибавляется к конечному результату.

Повторение одних и тех же операций часто встречается в математических расчётах. Каноничным примером считается вычисление [**факториала**](https://ru.wikipedia.org/wiki/Факториал). Факториалом какого-либо числа N называется произведение последовательных натуральных чисел от 1 до N включительно. Например, факториал числа 4 рассчитывается следующим образом:
{line-numbers: false, format: Bash}
```
4! = 1 * 2 * 3 * 4 = 24
```

Факториал может быть легко рассчитан с помощью оператора цикла. Для этого цикл должен последовательно перебирать целые числа от 1 до N. Каждое из них должно умножаться на конечный результат. В этом случае операция умножения повторяется.

Последний наш пример с повторением действий связан с событиями в системе. Представьте, что вы пишете программу, которая загружает на компьютер файлы из интернета. В начале своей работы программа устанавливает соединение с сервером. Если ответ от сервера не получен сразу, у программы есть два варианта действий. Первый — завершить выполнение с кодом возврата, отличным от нуля. Второй — ожидать ответа. Второй вариант практически всегда окажется предпочтительнее. Есть много причин, по которым ответ от сервера может прийти с задержкой. Например, перегрузка сети или самого сервера. Двух-трёхсекундного ожидания может оказаться достаточно, чтобы ответ пришёл и наша программа продолжила выполнение.

Самый простой способ реализовать ожидание какого-либо события в программе, это использовать оператор цикла. В нём проверяется условие наступления события. В нашем примере — это получение ответа от сервера. До тех пор, пока событие не наступило, цикл продолжается. При этом в его блоке команд могут отсутствовать какие-либо действия (пустой цикл). Альтернативный вариант — вызывать в цикле команду остановки выполнения программы на заданный промежуток времени. Такая техника называется **активным ожиданием** событий или [**busy-waiting**](https://en.wikipedia.org/wiki/Busy_waiting).

Мы рассмотрели следующие задачи, требующие повторения одних и тех же действий:

1. Однообразная обработка нескольких сущностей. Например, результатов поиска команды `find`.

2. Накопление конечного результата из промежуточных данных. Например, сбор статистики утилитой `du`.

3. Математические расчёты. Например, вычисление факториала.

4. Ожидание наступления какого-либо события. Например, получение ответа от сервера по сети.

Этот список далеко не полный. Он включает только наиболее часто встречающиеся в программировании задачи, для решения которых требуются операторы цикла.

### Оператор while

В Bash есть два оператора цикла (`while` и `for`), у каждого из которых есть две формы. Начнём наше изучение с самого простого из них — оператора `while`. Его синтаксис напоминает условную конструкцию `if`. В общем виде его можно записать следующим образом:
{line-numbers: true, format: Bash}
```
while УСЛОВИЕ
do
    ДЕЙСТВИЕ
done
```

Запись оператора в одну строку будет выглядеть так:
{line-numbers: false, format: Bash}
```
while УСЛОВИЕ; do ДЕЙСТВИЕ; done
```

УСЛОВИЕ и ДЕЙСТВИЕ в конструкции `while` могут быть одной командой или блоком команд, как и в конструкции `if`.

Выполнение `while` начинается с проверки УСЛОВИЯ. Если оно завершилось успешно с кодом возврата ноль, выполняется ДЕЙСТВИЕ. После этого опять проверяется УСЛОВИЕ и, если его код возврата по-прежнему ноль, снова выполняется ДЕЙСТВИЕ. Цикл прервётся тогда, когда УСЛОВИЕ вернёт результат, отличный от нуля.

Цикл `while` применяется в случаях, когда количество итераций заранее неизвестно. Типичный пример такой ситуации — это ожидание наступления какого-либо события. Рассмотрим пример.

Напишем скрипт, для проверки доступности какого-либо сервера в интернете. Чтобы выполнить такую проверку, нам необходимо отправить серверу запрос и получить от него ответ. Как только ответ будет получен, скрипт может вывести сообщение на экран и завершить свою работу.

Для обращения к серверу воспользуемся утилитой [`ping`](https://ru.wikipedia.org/wiki/Ping). Она посылает [ICMP](https://ru.wikipedia.org/wiki/ICMP) echo-запросы на удалённый сетевой [хост](https://ru.wikipedia.org/wiki/Хост) и получает от него echo-ответы. В качестве параметра утилита принимает [URL](https://ru.wikipedia.org/wiki/URL) или [IP-адрес](https://ru.wikipedia.org/wiki/IP-адрес) целевого хоста.

Вы можете вызвать утилиту `ping` из командной строки следующим образом:
{line-numbers: false, format: Bash}
```
ping google.com
```

Таким образом вы обратитесь к одному из серверов поисковой системы Google. После запуска команды вы увидите примерно следующий вывод:
{line-numbers: true, format: Bash}
```
PING google.com (172.217.21.238) 56(84) bytes of data.
64 bytes from fra16s13-in-f14.1e100.net (172.217.21.238): icmp_seq=1 ttl=51 time=17.8 ms
64 bytes from fra16s13-in-f14.1e100.net (172.217.21.238): icmp_seq=2 ttl=51 time=18.5 ms
```

Это подробная информация о каждом отправленном echo-запросе и полученном на него echo-ответе. Сейчас утилита работает в бесконечном цикле. Чтобы её остановить, нажмите комбинацию клавиш Ctrl+C.

Для проверки доступности сервера будет достаточно отправить только один echo-запрос. Для этого воспользуемся опцией `-c` утилиты `ping`. Эта опция позволяет указать число отправляемых пакетов. С ней вызов `ping` будет выглядеть так:
{line-numbers: false, format: Bash}
```
ping -c 1 google.com
```

Если сервер `google.com` доступен, утилита вернёт код возврата ноль. В противном случае он будет ненулевым.

Добавим к нашему вызову `ping` опцию `-W`, чтобы задать таймаут ожидания ответа от сервера. Одной секунды будет достаточно. Получится следующий вызов:
{line-numbers: false, format: Bash}
```
ping -c 1 -W 1 google.com
```

Теперь запишем конструкцию `while`, в которой вызов утилиты `ping` будет выполнять роль условия. Получим следующее:
{line-numbers: true, format: Bash}
```
while ! ping -c 1 -W 1 google.com &> /dev/null
do
    sleep 1
done
```

Нам не интересен вывод утилиты, поэтому перенаправляем его в файл `/dev/null`. В условии цикла мы инвертировали результат вызова `ping`. Это значит, что пока утилита возвращает отличный от нуля код (то есть сервер недоступен), будет выполняться тело цикла. В качестве действия вызывается утилита `sleep`. Она останавливает выполнение скрипта на указанное количество секунд. В нашем примере остановка длится одну секунду.

I> Вы можете указать суффикс для параметра утилиты `sleep`. Секундам соответствует суффикс `s` (например, `5s`), минутам — `m`, часам — `h` и дням — `d`.

Листинг 3-18 демонстрирует полный скрипт для ожидания ответа от сервера. Когда ответ получен, на консоль выводится сообщение.

{caption: "Листинг 3-18. Скрипт для ожидания ответа от сервера", line-numbers: true, format: Bash}
![`while-ping.sh`](code/BashScripting/while-ping.sh)

У конструкции `while` есть альтернативная форма `until`. Её единственное отличие заключается в том, что ДЕЙСТВИЕ выполняется до тех пор, пока УСЛОВИЕ ложно, т.е. возвращает отличный от нуля код. Другими словами `until` позволяет инвертировать условие цикла `while`.

В общем виде конструкцию `until` можно записать так:
{line-numbers: true}
```
until УСЛОВИЕ
do
    ДЕЙСТВИЕ
done
```

Запись оператора в одну строку аналогична циклу `while`:
{line-numbers: false}
```
until УСЛОВИЕ; do ДЕЙСТВИЕ; done
```

Перепишем наш скрипт для ожидания ответа от сервера с помощью конструкции `until`. Для этого удалим логическое отрицание результата вызова утилиты `ping`. Получится скрипт, приведённый в листинге 3-19.

{caption: "Листинг 3-19. Скрипт для ожидания ответа от сервера", line-numbers: true, format: Bash}
![`until-ping.sh`](code/BashScripting/until-ping.sh)

Его поведение полностью совпадает со скриптом из листинга 3-18.

Выбирайте форму `while` или `until` в зависимости от условия цикла. Всегда старайтесь составлять условия так, чтобы по возможности избегать отрицаний. Они усложняют чтение кода и способствуют ошибкам.

#### Бесконечный цикл

Конструкция `while` часто применяется в [**бесконечных циклах**](https://ru.wikipedia.org/wiki/Бесконечный_цикл). Такие циклы обычно выполняются до тех пор, пока работает программа или скрипт. Они используются в системном ПО, которое не должно завершаться до отключения питания (например, ОС или прошивки микроконтроллеров), а также в компьютерных играх. Бесконечные циклы могут быть полезны в Bash для вывода разного рода статистики.

Чтобы цикл `while` стал бесконечным, его условие должно всегда быть истинным. Самый простой способ этого добиться — использовать встроенную команду интерпретатора `true`. Например, следующим образом:
{line-numbers: true, format: Bash}
```
while true
do
    sleep 1
done
```

Команда `true` всегда возвращает истину, то есть её код возврата всегда ноль. У неё есть симметричная команда `false`, которая всегда возвращает единицу.

I> Во многих языках программирования `true` и `false` являются [**литералами**](https://ru.wikipedia.org/wiki/Литерал_(информатика)), то есть зарезервированными словами, обозначающими значение истина и ложь. Но в Bash это встроенные команды интерпретатора.

Вместо `true` вы также можете использовать двоеточие `:`. Тогда бесконечный `while` цикл будет выглядеть так:
{line-numbers: true, format: Bash}
```
while :
do
    sleep 1
done
```

Команда двоеточие является синонимом `true`. Она нужна для [совместимости](https://stackoverflow.com/questions/3224878/what-is-the-purpose-of-the-colon-gnu-bash-builtin) с Bourne shell, в котором `true` и `false` отсутствуют. Все три команды (`:`, `true`, `false`) включены в POSIX-стандарт.

Рассмотрим пример использования бесконечного цикла. Предположим, что вам нужно периодически выводить статистику об использовании дискового пространства в вашей системе. Для вывода этой информации можно воспользоваться утилитой `df`. При вызове её без параметров, вы получите следующий результат:
{line-numbers: true, format: Bash}
```
$ df
Filesystem     1K-blocks      Used Available Use% Mounted on
C:/msys64       41940988  24666880  17274108  59% /
Z:             195059116 110151748  84907368  57% /z
```

Занятое (Used) и свободное (Available) дисковое пространство указано в байтах. Для удобства можно использовать опцию утилиты `-h`. Тогда байты будут переведены в килобайты, мегабайты, гигабайты и терабайты. Также вы можете добавить опцию `-T`, чтобы вывести тип файловой системы для каждого диска. В результате получится вывод в таком формате:
{line-numbers: true, format: Bash}
```
$ df -hT
Filesystem     Type  Size  Used Avail Use% Mounted on
C:/msys64      ntfs   40G   24G   17G  59% /
Z:             hgfs  187G  106G   81G  57% /z
```

Если вам нужна информация обо всех точках монтирования, укажите опцию `-a`.

Будем вызывать утилиту `df` в бесконечном цикле каждые две секунды. Таким образом вы получите простейший скрипт для наблюдения за файловой системой. Он приведён в листинге 3-20.

{caption: "Листинг 3-20. Скрипт для наблюдения за файловой системой", line-numbers: true, format: Bash}
![`while-df.sh`](code/BashScripting/while-df.sh)

В начале цикла вызывается утилита `clear`. Она очищает окно терминала от текста. Благодаря этому, в терминале останется только вывод нашего скрипта без какой-либо лишней информации.

Задача циклического выполнения команд с заданным интервалом встречается настолько часто, что для неё была разработана специальная утилита `watch` из пакета `procps`. Чтобы установить этот пакет под MSYS2, выполните следующую команду:
{line-numbers: false, format: Bash}
```
pacman -S procps
```

Теперь вы можете получить поведение скрипта из листинга 3-20 всего одной командой:
{line-numbers: false, format: Bash}
```
watch -n 2 "df -hT"
```

Опция `-n` задаёт интервал между вызовами команды, которая идёт следующим параметром. Ещё одна полезная опция `watch` — это `-d`. Она позволяет подсветить разницу в выводе команды, выполненной на текущей итерации и на прошлой. Благодаря этому, вам будет легче отследить произошедшие изменения.

#### Чтение стандартного потока ввода

Цикл `while` часто используется для обработки стандартного потока ввода. Рассмотрим эту возможность на примере. Напишем скрипт, который будет читать ассоциативный массив из текстового файла.

Листинг 3-10 демонстрирует скрипт для работы с контактами. Они хранятся в коде скрипта, что неудобно для редактирования и сопровождения. Было бы лучше поместить контакты в обычный текстовый файл и читать его при старте скрипта. Таким образом мы разделим данные и код. Возможный формат файла с контактами приведён в листинге 3-21.

{caption: "Листинг 3-21. Текстовый файл `contacts.txt` со списком контактов", line-numbers: true, format: text}
![`contacts.txt`](code/BashScripting/contacts.txt)

Теперь напишем скрипт для чтения этого файла и записи его содержимого в ассоциативный массив. Очевидно, что для решения этой задачи нам понадобится цикл. Перед началом его выполнения мы не знаем, сколько потребуется итераций. Это верный признак того, что вам нужно использовать цикл `while`.

Почему число итераций цикла неизвестно? Мы собираемся выполнять обработку файла контактов построчно. Каждая строка хранит одну запись. Прочитав её, мы добавим соответствующий элемент в ассоциативный массив и перейдём к следующей записи. Получается, что число итераций цикла соответствует числу строк в файле. Но число строк станет нам известно только после окончания его обработки. Можно было бы прочитать файл целиком, подсчитать число строк в нём и сделать массив с фиксированным числом итераций. Но это было бы неоправданным усложнением кода, потому что у такого подхода нет никаких преимуществ.

Для чтения строк файла мы можем применить встроенную команду интерпретатора `read`. Она читает строку из стандартного потока ввода и сохраняет её в переменную, имя которой передаётся в качестве параметра. Например, следующим образом:
{line-numbers: false, format: Bash}
```
read var
```

В этом случае после запуска команды на исполнение вы должны ввести строку, которая будет сохранена в переменной `var`. Если вызвать `read` без параметров, строка будет сохранена в зарезервированной переменной `REPLY`.

Команда `read` позволяет экранировать некоторые введённые символы с помощью обратного слэша `\`. Чтобы отключить эту функцию, используйте опцию `-r`. В противном случае вы рискуете потерять некоторые символы из ввода.

Если команде `read` передать несколько имён переменных, следующих через пробел, то вводимый пользователем текст будет поделён на строки. В качестве разделителей между ними будут использоваться символы из зарезервированной переменной `IFS`. По умолчанию это пробел, знаки табуляции и перевода строки.

Рассмотрим пример. Предположим, что вам надо сохранить вводимые пользователем строки в двух переменных с именами `path` и `file`. Команда `read` в этом случае будет выглядеть так:
{line-numbers: false, format: Bash}
```
read -r path file
```

Пользователь вводит следующий текст:
{line-numbers: false, format: text}
```
~/Documents report.txt
```

В этом случае путь `~/Documents` попадёт в переменную `path`, а имя файла `report.txt` в `file`.

Если путь содержит пробелы (например, `~/My Documents`), то произойдёт ошибка. Предположим, ввод пользователя выглядит так:
{line-numbers: false, format: text}
```
~/My Documents report.txt
```

В этом случае в переменную `path` попадёт строка `~/My`, а в `file` всё остальное: `Documents report.txt`. Всегда учитывайте эту особенность работы утилиты `read`. Эту проблему можно решить, если переопределить зарезервированную переменную `IFS`. Например так:
{line-numbers: false, format: text}
```
IFS=$',' read -r path file
```

I> В этом примере мы применили специфичный для Bash [вид кавычек](http://mywiki.wooledge.org/Quotes) `$'...'`. В них не выполняются никакие подстановки. Но некоторые управляющие последовательности разрешены: `\n` (новая строка), `\\` (экранированный обратный слэш), `\t` (табуляция) и `\xnn` (байты в шестнадцатеричной системе).

Тогда следующий ввод пользователя даст корректный результат.
{line-numbers: true, format: text}
```
~/My Documents,report.txt
```

В этом примере мы использовали в качестве разделителя запятую `,`. Поскольку она не встречается ни в пути, ни в имени файла, ввод пользователя обработается корректно. Строка `~/My Documents` попадёт в переменную `path`, а `report.txt` в `file`.

Команда `read` читает данные со стандартного потока ввода. Это значит, что вы можете перенаправить ей на вход содержимое файла. Например, прочитать первую строчку файла `contacts.txt` из листинга 3-21 можно следующей командой:
{line-numbers: false, format: Bash}
```
read -r contact < contacts.txt
```

После выполнения этой команды в переменную `contact` будет записана строка `Alice=alice@gmail.com`. 

Вы можете сохранить имя и контактные данные в разные переменные. Для этого в качестве разделителя определите знак равно `=`. Получится следующий вызов:
{line-numbers: false, format: Bash}
```
IFS=$'=' read -r name contact < contacts.txt
```

Теперь имя `Alice` попало в переменную `name`, а адрес электронной почты в `contact`.

Чтобы пройти по всему списку контактов в файле `contacts.txt`, мы могли бы написать следующий цикл `while`:
{line-numbers: true, format: Bash}
```
while IFS=$'=' read -r name contact < "contacts.txt"
do
  echo "$name = $contact"
done
```

Однако, это не сработает. Произойдёт зацикливание, потому что команда `read` всегда будет читать только первую строчку файла и возвращать нулевой код возврата. Нулевой код приведёт к повторному выполнению цикла снова и снова.

Чтобы цикл `while` последовательно прошёл по всем строкам из стандартного ввода, его нужно записать в следующей форме:
{line-numbers: true, format: Bash}
```
while УСЛОВИЕ
do
  ДЕЙСТВИЕ
done < ФАЙЛ
```

Если вам необходимо обработать ввод пользователя с клавиатуры, в качестве файла укажите `/dev/tty`. В этом случае чтобы закончить ввод, необходимо нажать сочетание клавиш Ctrl+D.

Таким образом правильный вариант цикла `while` для чтения файла `contacts.txt` выглядит так:
{line-numbers: true, format: Bash}
```
while IFS=$'=' read -r name contact
do
  echo "$name = $contact"
done < "contacts.txt"
```

После выполнения этого цикла будет распечатано всё содержимое файла.

Последний шаг, который нам остался, заключается в инициализации ассоциативного массива с помощью прочитанных переменных `name` и `contact`. Конечный вариант скрипта для чтения и работы с контактами приведён в листинге 3.22

{caption: "Листинг 3-22. Скрипт для работы с файлом контактов", line-numbers: true, format: Bash}
![`while-contacts.sh`](code/BashScripting/while-contacts.sh)

Поведение этого скрипта полностью повторяет скрипт из листинга 3-10.

### Оператор for

Оператор цикла `for` используется в случаях, когда количество итераций заранее известно. У него есть две формы. Первая позволяет последовательно обработать каждое слово в некоторой строке. Вторая форма в качестве условия выхода из цикла использует арифметическое выражение.

### Первая форма for

Начнём с первой формы `for` как более простой. В общем виде её можно записать так:
{line-numbers: true, format: Bash}
```
for ПЕРЕМЕННАЯ in СТРОКА
do
    ДЕЙСТВИЕ
done
```

В однострочном виде эта же конструкция выглядит так:
{line-numbers: false, format: Bash}
```
for ПЕРЕМЕННАЯ in СТРОКА; do ДЕЙСТВИЕ; done
```

ДЕЙСТВИЕ в конструкции `for` может быть одной командой или блоком команд, как и в операторе `while`.

Перед первой итерации цикла Bash выполняет все подстановки в конструкции `for`. Что это значит? Предположим, что вместо СТРОКИ вы указали команду. Тогда перед выполнением цикла она будет выполнена и будет подставлен её вывод. Если же вы указали шаблон — он будет развёрнут. Дальше СТРОКА разделяется на слова. В качестве разделителей используются символы, указанные в зарезервированной переменной `IFS`. Затем происходит выполнение первой итерации цикла. При этом каждое слово, прочитанное из СТРОКИ, будет доступно в теле цикла как значение ПЕРЕМЕННОЙ.

Рассмотрим простой пример использования `for`. Напишем скрипт, который обрабатывает каждое слово в строке, переданной ему в первом позиционном параметре. Листинг 3-23 демонстрирует код скрипта.

{caption: "Листинг 3-23. Скрипт для обработки слов в строке", line-numbers: true, format: Bash}
![`for-string.sh`](code/BashScripting/for-string.sh)

Обратите внимание, что заключать позиционный параметр `$1` в кавычки не следует. Если это сделать, разделения строки на слова (word splitting) не произойдёт и цикл выполнит только одну итерацию. В ней переменная `word` будет равна всей строке.

Передаваемую в скрипт строку напротив следует заключить в кавычки, чтобы она целиком попала в позиционный параметр `$1`. Например так:
{line-numbers: false, format: Bash}
```
./for-string.sh "this is a string"
```

Чтобы скрипт корректно обрабатывал переданную ему строку без кавычек, замените позиционный параметр `$1` на `$@` следующим образом:
{line-numbers: false, format: Bash}
```
for word in $@
```

Теперь оба варианта передачи строки будут работать корректно:
{line-numbers: true, format: Bash}
```
./for-string.sh this is a string
./for-string.sh "this is a string"
```

Немного усложним задачу. Предположим, что пользователь передаёт в скрипт список путей (например, к файлам), которые разделены запятыми. В путях могут встречаться пробелы. Чтобы правильно обработать такую строку, нам нужно переопределить разделитель в специальной переменной `IFS`. В результате получим скрипт, приведённый в листинге 3-24.

{caption: "Листинг 3-24. Скрипт для обработки списка путей", line-numbers: true, format: Bash}
![`for-path.sh`](code/BashScripting/for-path.sh)

В этом скрипте мы присвоили переменной `IFS` единственный символ — запятую `,`. Поэтому цикл `for` при обработке строки из параметра `$1` будет ориентироваться именно на запятые и игнорировать пробелы. Таким образом на каждой итерации в переменную `path` будет записываться один путь.

Вызов скрипта может выглядеть, например, следующим образом:
{line-numbers: false, format: Bash}
```
./for-path.sh "~/My Documents/file1.pdf,~/My Documents/report2.txt"
```

Опять же обратите внимание на обязательные кавычки для передачи строки в скрипт. В этом случае замена позиционного параметра `$1` на `$@` не поможет избавиться от них. Word splitting произойдёт до нашего переобъявления переменной `IFS`. Поэтому строка будет поделена пробелами.

Цикл `for` часто используется для прохода по всем элементам индексируемого массива. Например, как в листинге 3-25.

{caption: "Листинг 3-25. Скрипт для обработки всех элементов массива", line-numbers: true, format: Bash}
![`for-array.sh`](code/BashScripting/for-array.sh)

Если вам нужны не все элементы, а только определённые, вы можете обратиться к ним по индексам. Цикл `for` позволяет пройти по словам в строке. Мы можем использовать строку чисел, разделённых пробелами. Например, следующим образом:
{line-numbers: true, format: Bash}
```
array=(Alice Bob Eve Mallory)

for i in 0 1 2
do
    echo "${array[i]}"
done
```

Такой цикл пройдёт только по элементам с индексами 0, 1 и 2. Вместо того чтобы указывать их явно, вы можете использовать подстановку фигурных скобок. Например:
{line-numbers: true, format: Bash}
```
array=(Alice Bob Eve Mallory)

for i in {0..2}
do
    echo "${array[i]}"
done
```

Будьте осторожны при обработке массивов с пропусками подобным образом. Обратите внимание, что вариант прохода по массиву из листинга 3-25 корректно обрабатывает пропуски. Это происходит потому, что он работает не с индексами, а с самим элементами.

### Обработка списка файлов

Цикл `for` также часто применяется для обработки списка файлов. При таком его использовании есть несколько подводных камней, которые будет лучше рассмотреть на примерах.

Предположим, что вам нужно написать скрипт, который бы выводил типы всех файлов в текущем каталоге. Для вывода типа файла воспользуемся уже знакомой нам утилитой `file`. Единственное, что нам нужно сделать, это правильно написать условие цикла `for`.

Одна из самых частых ошибок начинающих программистов при написании циклов `for` это пренебрежение шаблонами. Многие в качестве СТРОКИ используют подстановку вывода утилит `ls` или `find`. Например так:
{line-numbers: true, format: Bash}
```
for filename in $(ls)
for filename in $(find . - type f)
```

Это неправильный подход. Он приводит к следующим проблемам:

1. Word splitting приведёт к тому, что содержащие пробелы имена файлов и каталогов, будут обработаны по частям за несколько итераций. 

2. Если имя файла содержит символ звёздочка `*`, перед очередной итерацией цикла будет выполнена подстановка шаблонов. Её результат будет записан в переменную `filename`. Таким образом правильное значение будет утеряно.

3. В зависимости от региональных настроек и кодировок, утилита `ls` может некорректно обрабатывать имена файлов. Это приведёт к тому, что некоторые символы в них будут заменены на знаки вопроса `?`.

Правильно всегда использовать шаблоны (globbing) в цикле `for`, если вам нужно перебрать имена файлов. В нашем случае условие цикла должно выглядеть так:
{line-numbers: false, format: Bash}
```
for filename in *
```

Полная версия скрипта приведена в листинге 3-26

{caption: "Листинг 3-26. Скрипт для вывода типов файлов", line-numbers: true, format: Bash}
![`for-file.sh`](code/BashScripting/for-file.sh)

Не забывайте про двойные кавычки при подстановке переменной `filename`. Это позволит избежать word splitting в именах файлов с пробелами.

Если вам нужно обработать список файлов из конкретного каталога, вы по-прежнему можете использовать подстановку шаблонов. Например так:
{line-numbers: false, format: Bash}
```
for filename in /usr/share/doc/bash/*
```

Если вам нужны только файлы с определённым расширением, вы опять же можете воспользоваться шаблоном. Например:
{line-numbers: false, format: Bash}
```
for filename in ~/Documents/*.pdf
```

В Bash начиная с версии 4 появилась возможность рекурсивного обхода всех каталогов при подстановке шаблона. Например:
{line-numbers: true, format: Bash}
```
shopt -s globstar

for filename in **
```

Обратите внимание, что для использования этой возможности, необходимо включить дополнительную опцию интерпретатора `globstar` с помощью встроенной команды `shopt`.

В результате подстановки `**` в конструкции `for` мы получим список всех подкаталогов и файлов в них, начиная с текущего каталога. Эту возможность можно совмещать с обычными шаблонами. Вот пример для прохода по всем файлам с расширением PDF из домашнего каталога пользователя:
{line-numbers: true, format: Bash}
```
shopt -s globstar

for filename in ~/**/*.pdf
```

Скрипт из листинга 3-26 мы могли бы заменить следующей командой `find`:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -exec file {} \;
```

Очевидно, что такое решение более предпочтительно, чем использование цикла `for`. Оно компактнее и быстрее, поскольку содержит меньше операций.

Когда же использование цикла `for` оправдано для работы с файлами и каталогами? Утилита `find` хорошо справляется в том случае, когда для обработки найденных ею объектов достаточно одной команды без дополнительных условных операторов. В противном случае вызов `find` становится громоздким и неудобным для чтения. Тогда его стоит заменить на цикл `for`.

Скрипт из листинга 3-26 можно переписать с использованием оператора `while`. Для этого ему на вход следует передать вывод утилиты `find`. При вызове `find` обязательно надо использовать опцию `-print0`. Листинг 3-27 демонстрирует такой вариант скрипта.

{caption: "Листинг 3-27. Скрипт для вывода типов файлов", line-numbers: true, format: Bash}
![`while-file.sh`](code/BashScripting/while-file.sh)

Рассмотрим этот скрипт подробнее. Прежде всего может возникнуть вопрос, почему мы переобъявили зарезервированную переменную `IFS` и присвоили ей пустое значение? Если этого не сделать, то вывод команды `find` будет разделён пробелами, знаками табуляции и перевода строки. Таким образом имена файлов и каталогов, содержащие эти символы, будут обработаны неправильно.

Второй вопрос вызывает опция `-d` команды `read`. Что она означает? С её помощью можно переопределить символ, по которому `read` будет разделять полученный текст. Таким образом в переменную `filename` будет записана часть исходной строки до очередного разделителя.

В нашем примере разделитель для команды `read` пустой. Это значит, что он равен NUL-символу. Вы также можете указать его явно. Например так:
{line-numbers: false, format: Bash}
```
while IFS= read -r -d $'\0' filename
```

С опцией `-d` команда `read` теперь сможет обработать вывод утилиты `find`, в которой в качестве разделителя тоже используется NUL-символ (благодаря опции `-print0`).

Обратите внимание, что вы не можете указать NUL-символ в качестве разделителя через зарезервированную переменную `IFS`. Другими словами следующий вариант не заработает:
{line-numbers: false, format: Bash}
```
while IFS=$'\0' read -r filename
```

Причина этого в [особенности интерпретации](https://mywiki.wooledge.org/IFS) значения переменной `IFS`. Если значение пустое, Bash вообще не выполняет word splitting.

Последний вопрос по скрипту из листинга 3-27 связан с подстановкой процесса. Почему мы не использовали подстановку команды? Например так:
{line-numbers: true, format: Bash}
```
while IFS= read -r -d '' filename
do
  file "$filename"
done < $(find . -maxdepth 1 -print0)
```

Проблема в том, что вы не можете перенаправлять результат выполнения команды таким образом. Оператор `<` связывает стандартный поток ввода с указанным файловым дескриптором. Но в случае подстановки команды никакого дескриптора нет. Bash просто вызывает утилиту `find` и подставляет её вывод. Если же использовать подстановку процессов, вывод `find` будет сохранён во временном файле, у которого будет дескриптор. Поэтому перенаправление отработает корректно.

У подстановки процессов есть одна проблема. Она специфична для Bash и не включена в POSIX-стандарт. Если вам важно следовать стандарту, используйте конвейер. Листинг 3-28 демонстрирует это решение.

{caption: "Листинг 3-28. Скрипт для вывода типов файлов", line-numbers: true, format: Bash}
![`while-file-pipe.sh`](code/BashScripting/while-file-pipe.sh)

Если вам требуется пройти по файлам, полученным в результате поиска со сложным условием, всегда предпочитайте комбинацию утилиты `find` с циклом `while`, а не `for`. Тогда с помощью команды `read` вы сможете разделить результаты поиска NUL-символом. Это позволит избежать ошибок с именами файлов и каталогов, использующих пробелы и другие специальные символы.

### Вторая форма for

Во второй форме `for` в качестве условия цикла используется арифметическое выражение. В каких случаях это окажется полезным? Чтобы ответить на этот вопрос, рассмотрим пример.

Предположим, вы пишете скрипт для расчёта факториала. Если число, для которого он рассчитывается заранее известно, вы можете использовать первую форму оператора `for`. Например так, как демонстрирует листинг 3-29.

{caption: "Листинг 3-29. Скрипт для расчёта факториала числа 5", line-numbers: true, format: Bash}
![`for-factorial-brace.sh`](code/BashScripting/for-factorial-brace.sh)

Но допустим, что число для расчёта должно передаваться в скрипт через позиционный параметр `$1`. Тогда вы можете предложить следующий вариант условия цикла `for`:
{line-numbers: false, format: Bash}
```
for i in {1..$1}
```

Такой вариант не заработает. Почему? Согласно таблице 3-2, подстановка фигурных скобок выполняется до подстановки параметров. Поэтому вместо строки "1 2 3 4 5" в условии цикла, вы получите строку "{1..$1}". Эта строка попадёт в переменную `i`, и следующий далее арифметический оператор `((` просто не сможет её корректно обработать.

Проблему можно решить с помощью утилиты `seq`. Она принимает на вход один, два или три параметра. Таблица 3-20 демонстрирует каждый из вариантов вызова утилиты.

{caption: "Таблица 3-20. Параметры утилиты `seq`", width: "100%"}
| Число параметров | Описание параметров | Пример команды | Результат |
| --- | --- | --- | --- |
| 1 | Последнее число в генерируемой последовательности, которая начинается с единицы. | `seq 5` | 1 2 3 4 5 |
| 2 | Первое и последнее число в последовательности. | `seq -3 3` | -2 -1 0 1 2 |
| 3 | Первое число, шаг и последнее число в последовательности. | `seq 1 2 5` | 1 3 5 |

В выводе утилиты `seq` по умолчанию в качестве разделителя используется управляющий символ перевода строки `\n`. Его можно заменить на любой другой с помощью опции `-s`. Перевод строки входит в обычный список разделителей специальной переменной `IFS`. Поэтому в конструкции `for` можно использовать `seq` без опции `-s`.

I> В таблице 3-20 перевод строки был заменён на пробел в столбце "Результат" для удобства.

С помощью утилиты `seq` мы сможем написать параметризуемый скрипт расчёта факториала. Он приведён в листинге 3-30.

{caption: "Листинг 3-30. Скрипт для расчёта факториала", line-numbers: true, format: Bash}
![`for-factorial-seq.sh`](code/BashScripting/for-factorial-seq.sh)

Это решение работает, но его нельзя назвать эффективным. Нам пришлось вызывать стороннюю утилиту для подготовки условия цикла `for`. Такой вызов можно сравнить с запуском обычной программы (например, текстового редактора). Ядру ОС требуется значительное по меркам CPU время для создания нового процесса, в котором запущенная программа будет исполняться. Поэтому было бы лучше, если бы мы обошлись встроенными средствами Bash в нашем цикле `for`.

Именно для подобных задач создавалась вторая форма оператора `for`. В общем виде её можно записать так:
{line-numbers: true, format: Bash}
```
for (( ВЫРАЖЕНИЕ_1; ВЫРАЖЕНИЕ_2; ВЫРАЖЕНИЕ_3 ))
do
    ДЕЙСТВИЕ
done
```

В однострочном виде эта конструкция выглядит так:
{line-numbers: false, format: Bash}
```
for (( ВЫРАЖЕНИЕ_1; ВЫРАЖЕНИЕ_2; ВЫРАЖЕНИЕ_3 )); do ДЕЙСТВИЕ; done
```

Алгоритм выполнения цикла `for` с арифметическим условием следующий:

1. ВЫРАЖЕНИЕ_1 выполняется однократно перед первой итерацией цикла.

2. Цикл выполняется до тех пор, пока ВЫРАЖЕНИЕ_2 остаётся истинным. Как только оно вернуло ложь в качестве результата, цикл завершается.

3. В конце каждой итерации выполняется ВЫРАЖЕНИЕ_3.

Перепишем скрипт из листинга 3-30, заменив вызов утилиты `seq` в цикле `for` на арифметическое выражение. Результат приведён в листинге 3-31.

{caption: "Листинг 3-31. Скрипт для расчёта факториала", line-numbers: true, format: Bash}
![`for-factorial.sh`](code/BashScripting/for-factorial.sh)

Преимущество этого скрипта в том, что он использует только встроенные операторы Bash. Для их выполнения не требуется создания новых процессов. Поэтому в общем случае такое решение будет эффективнее.

Рассмотрим алгоритм выполнения конструкции `for` в нашем скрипте:

1. Перед первой итерацией цикла объявляется переменная `i`, равная единице.

2. Выполняется проверка условия `i <= $1`. На первой итерации `i` равна единице, а позиционный параметр `$1` переданному в скрипт числу (например, 5). Если условие выполняется, возвращается код возврата ноль.

3. Если условие вернуло ноль, выполняется первая итерация цикла. В противном случае цикл завершается.

4. В теле цикла вычисляется арифметическое выражение `result *= i`. В результате значение переменной `result` будет умножено на `i` (единицу для первой итерации).

5. После выполнения первой итерации, вычисляется третье выражение `++i` в условии цикла. В результате значение переменной `i` станет равно двум.

6. Переход ко второму шагу алгоритма с проверкой условия `i <= $1` и в случае кода возврата ноль выполнение следующей итерации цикла.

I> В общем случае переменные в операторе `((` и команде `let` можно указывать без знака доллара `$`. Однако, в нашем скрипте он необходим при подстановке позиционного параметра `$1` в условии цикла. Если этого не сделать, Bash не выполнит подстановку, а вместо этого будет работать с единицей как с обычным числом.

Обратите внимание, что в цикле используется префиксная форма инкремента. Как вы помните, её предпочтительнее использовать вместо постфиксной формы по причине лучшей производительности.

Вторая форма оператора `for` также окажется полезна, когда значение счётчика цикла рассчитывается по какой-то формуле. В этом случае утилиты `seq` будет недостаточно.

### Управление циклом

Любой цикл завершается согласно своему условию. Однако есть дополнительные средства управления циклом. Они позволяют прервать его выполнение или пропустить текущую итерацию. Рассмотрим их подробнее.

#### break

Встроенная команда `break` позволяет немедленно прекратить выполнение цикла и выйти из него. Оно может быть полезно при обработке ошибок или для завершения бесконечного цикла.

Для примера предположим, что вы пишете скрипт поиска элемента индексируемого массива с определённым значением. В этом случае как только вы его нашли, нет смысла продолжать цикл. Можно сразу выйти из него. Листинг 3-32 демонстрирует такой скрипт.

{caption: "Листинг 3-32. Скрипт поиска элемента в массиве", line-numbers: true, format: Bash}
![`for-break.sh`](code/BashScripting/for-break.sh)

Для хранения результатов поиска мы используем переменную `is_found`. Как только найден элемента массива, равный переданному в скрипт позиционному параметру `$1`, переменной `is_found` присваивается единица и выполнение цикла прерывается командой `break`. Далее в операторе `if` проверяется значение `is_found` и в зависимости от него выводится сообщение о результате поиска. Если ни один из элементов массива не равен парметру `$1`, переменная `is_found` останется равной нулю.

Команда `break` используется, когда необходимо продолжить выполнение скрипта после оператора цикла. Как например в листинге 3-32, результаты поиска выводятся в следующей за циклом конструкции `if`.

В некоторых случаях вместо команды `break` предпочтительнее использовать `exit`. Это оправдано, когда выполнение скрипта после цикла не имеет смысла. Например, в случае обнаружения ошибки или вывода результата сразу в цикле. Перепишем скрипт из листинга 3-32 с использованием команды `exit` вместо `break`. Результат приведён в листинге 3-33.

{caption: "Листинг 3-33. Скрипт поиска элемента в массиве", line-numbers: true, format: Bash}
![`for-exit.sh`](code/BashScripting/for-exit.sh)

Результат работы скриптов из листинга 3-22 и 3-23 полностью совпадает. Использование команды `exit` позволило написать более компактный код без вспомогательной переменной `is_found` и конструкции `if`. Поэтому всегда рассматривайте и такой вариант выхода из цикла.

#### continue

Встроенная команда `continue` не прерывает цикл, но прекращает исполнение текущей итерации. Цикл продолжит выполняться, но со следующей итерациии.

Предположим, что вы обрабатываете массив чисел. В нём вас интересуют только положительные числа, сумму которых надо рассчитать. В этом случае можно воспользоваться конструкцией `if` для проверки знака. Возможный вариант решения приведён в листинге 3-34.

{caption: "Листинг 3-34. Скрипт для расчёта суммы положительных чисел в массиве", line-numbers: true, format: Bash}
![`for-sum.sh`](code/BashScripting/for-sum.sh)

Если `element` оказался больше нуля (то есть положительное число), добавляем его значение к результирующей сумме `sum`.

Этого же поведения можно добиться с помощью команды `continue`, как демонстрирует листинг 3-35.

{caption: "Листинг 3-35. Скрипт для расчёта суммы положительных чисел в массиве", line-numbers: true, format: Bash}
![`for-continue.sh`](code/BashScripting/for-continue.sh)

Что изменилось? Мы инвертировали условие в конструкции `if`. Теперь оно выполняется для отрицательных чисел. В этом случае вызывается команда `continue`. Благодаря ей, текущая итерация цикла прерывается, то есть следующая за конструкией `if` арифметическая операция не выполняется. Вместо этого происходит переход к следующей итерации цикла, что означает обработку следующего элемента массива.

Команда `continue` позволяет реализовать уже известную нам технику раннего возврата в контексте цикла. Предпочитайте использовать эту команду для обработки ошибок и условий, которые требуют немедленного переход к следующей итерации цикла. Это позволит вам избежать вложенных констуркций `if` и сделает код более понятным и удобным для чтения.
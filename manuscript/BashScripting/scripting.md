## Скрипт

В прошлой главе мы научились писать достаточно сложные Bash команды. С их помощью мы реализовали не только линейные алгоритмы, но и содержащие ветвление. Может возникнуть вопрос: зачем вообще нужно объединять набор команд в законченную программу? Это разумное замечание. Предлагаю рассмотреть его подробнее.

### Неверное техническое решение

Предположим, что мы написали команду для резервного копирования фотографий на [внешний жёсткий диск](https://ru.wikipedia.org/wiki/Внешний_жёсткий_диск). С помощью коннекторов в ней проверяется корректность каждой операции. Результат копирования сохраняется в лог-файл. В результате наша команда получится достаточно длинной. Если мы планируем выполнять резервное копирование регулярно, нам потребуется где-то её сохранить. Иначе придётся каждый раз набирать её в терминале по новой.

Мы уже знаем, что все выполненные Bash команды автоматически сохраняются в файле истории `~/.bash_history`. Тогда с помощью комбинации Ctrl+R найти эту команду не составит труда. Возможно, вам это решение покажется надёжным и удобным. Не торопитесь с выводом, давайте рассмотрим его возможные проблемы.

Прежде всего размер истории Bash ограничен. По умолчанию сохраняются только 1000 последних команд. Если превысить это число, то самые новые начнут записываться вместо самых старых. Таким образом появляется риск случайно потерять нашу команду резервного копирования. Можно увеличить максимальный размер истории. Но сразу возникает вопрос: увеличить на сколько? Какой бы большой размер мы не выбрали, рано или поздно возникнет риск переполнения истории. Есть варинт вообще снять ограничение на этот размер. Тогда будут сохраняться все введёные команды, а старые никогда не будут удаляться.

Кажется, нам удалось решить проблему и найти приемлемое техническое решение. Имеет ли оно какие-то побочные эффекты? Давайте подумает над этим вопросом. Предположим, что вы используйте Bash год или два. Все команды, ввёденые вами за это время попадут в файл `~/.bash_history`. Учтите, что одни и те же команды в нём дублируются. То есть, например, каждая команда `cd ~` будет записана в этот файл, независимо от того есть она в нём уже или нет. Можно предположить, что за год этот файл достигнет значительного размера около нескольких сотен мегабайт. При этом большая часть сохранённой в нём информации нам не нужна. Нас интересует только несколько команд, которые мы используем регулярно. В результате, мы получили первый побочный эффект: нерациональное использование места на жёстком диске.

Вы можете возразить, что хранить лишние две-три сотни мегабайт - это не проблема для современных компьютеров. Да, это так. Но не забывайте, что при каждом поиске по нажатию Ctrl+R Bash ищет нужную вам команду по всему файлу истории. Чем он больше, тем дольше будет длиться этот поиск. В какой-то момент он может занимать больше 10 секунд даже на мощном копьютере. Дальше с ростом файла это время будет только увеличиваться.

Раздувание файла истории приводит к увеличению времени поиска. Это связано не только с тем, что Bash приходится перебирать больше строк. Поиск по Ctrl+R позволяет вам ввести начало нужной команды. Представьте себе, что история огромна. В этом случае в ней содержится очень много команд, которые начинаются одинаково. В результате вам придётся набирать больше символов, чтобы найти  из них нужную. Неудобство вызова команды - это второй побочный эффект нашего решения.

Предположим, что у нас появились новые альбомы фотографий. Но наша команда резервного копирования работаёт со строго определёнными путями старых альбомов. Чтобы она стала поддерживать другие пути, достаточно просто поменять параметр вызова `cp`. К сожалению, в нашем случае это означает написать новую команду, которая также будет сохранена в истории. В результате каждый раз вам искать по нескольким версиям команды резервного копирования, чтобы найти среди них последнюю. Сложность расширения функций - третий побочный эффект.

Если вы решите объединить нашу команду резервного копирования фотографий с аналогичной ей, которая копирует документы, это будет проблематично. Опять же понадобиться новая команда, которая сочетает в себе две существующие.

Какой можно сделать вывод из рассмотренных возможных проблем? Долговременное хранение команд в файле истории неудобно. Настоящая причина этого в том, что мы попытались использовать механизм для целей, к которым он не предназначен. В результате мы пришли к техническому решению, которое неудобно в использовании и сопровождении.

Неверные технические решения распространены не только среди начинающих программистов. Профессионалы с большим опытом тоже их совершают и достаточно часто. В чём причина таких решений?

В нашем случае причиной можно назвать нежелание учиться новому. Мы освоились с работой Bash в режиме командного интерпретатора. Но применяя полученные знания для новой задачи резервного копирования, мы не учли в полной мере её требования. Они звучат следующим образом:

1. Долговременное хранение команды.
2. Возможность её расширения.
3. Возможность сочетания с другими командами.
4. Удобство вызова.

Чтобы удовлетворить этим требованиям, наших знаний просто недостаточно. Поэтому нам нужно сначала изучить возможности Bash скриптов, а затем проверить, помогут ли новые знания в решении поставленной задачи.

### Возможности Bash скриптов
## Арифметические выражения

Интерпретатор Bash позволяет выполнять математические операции над целыми числами. К ним относятся не только хорошо знакомые вам арифметические действия (сложение, вычитание, умножение и деление), но также битовые и логические операции. Они применяются практически во всех современных языках программирования. Поэтому рассмотрим их подробнее.

### Арифметические действия

Начнём с самых простых математических операций — арифметических. В языках программирования они обозначаются привычными символами:

* `+` сложение
* `-` вычитание
* `/` деление
* `*` умножение

В программировании помимо них часто используются ещё два действия: возведение в степень и вычисление [остатка от деления](https://ru.wikipedia.org/wiki/Деление_с_остатком).

Возведение в степень принято записывать в виде a<sup>b</sup>, где `a` является основанием, а `b` — показателем. Например, два в степени семь записывается как 2<sup>7</sup>. В Bash для этого арифметического действия используются два символа `*`:
{line-numbers: false}
```
2**7
```

Вычисление остатка от деления — более сложная операция. Что это такое и для чего она применяется?

Если в результате деления одного целого числа на другое получается дробное, возникает остаток. Например, разделим 10 (делимое) на 3 (делитель). В результате получится примерно 3,33333 (частное). В этом случае остаток от деления будет равен 1. Чтобы его вычислить, необходимо делитель 3 умножить на целую часть частного (или неполное частное) 3. Затем получившиеся число 9 вычтем из делимого 10 и получим 1.

Обозначим делимое буквой `a`, делитель — `b`, а неполное частное — `q`. Тогда формулу нахождения остатка от деления `r` можно записать в следующем виде:
{line-numbers: false}
```
r = a - b * q
```

Вопросы вызывает выбор неполного частного `q`. На самом деле, вместо него мы не можем подставить в приведенную формулу любое число. Неполное частное `q` должно быть таким, чтобы остаток от деления `r` был положительным и по абсолютной величине оказался меньше делителя `b`.

Вычисление остатка в Bash обозначается знаком `%`. Обратите внимание, что в некоторых языках этим же символом обозначается операция [**modulo**](https://en.wikipedia.org/wiki/Modulo_operation). Между этими действиями есть [тонкое различие](https://habr.com/ru/post/421071). Оно заключается в поведении, когда либо делимое, либо делитель являются отрицательным числом. Рассмотрим пример для делимого 19 и делителя -12:
{line-numbers: false}
```
19 % -12 = 7
19 modulo -12 = -5
```

Остаток от деления был получен по следующей формуле:
{line-numbers: false}
```
19 - (-12) * (-1) = 7
```

Для расчёта modulo используется та же формула, но выбирается другое неполное частное `q`:
{line-numbers: false}
```
19 - (-12) * (-2) = -5
```

Для вычисления остатка от деления неполное частное выбирается так, чтобы получить наименьшее целое положительное число. В случае modulo — чтобы получить наименьшее целое число, которое может быть как положительным так и отрицательным. Всегда помните об этом различии при программировании на любом языке.

Для чего используется вычисление остатка от деления? Одна из самых распространённых задач — проверка числа на чётность. Она возникает в коммуникациях, чтобы проверить корректность принятых данных. Этот подход известен как [**бит контроля чётности**](https://ru.wikipedia.org/wiki/Бит_чётности).

Чтобы проверить число на чётность, достаточно вычислить остаток его деления на 2. Если остаток равен нулю, значит число чётное. В противном случае — нечётное.

Другая распространённая задача в которой не обойтись без вычисления остатка — это преобразование единиц времени. Рассмотрим пример. Предположим, что нам надо перевести 128 секунд в минуты. Для этого нам надо подсчитать целое число минут и приписать к нему остаток. Чтобы найти минуты, разделим 128 на 60. Получим неполный остаток 2. Для нахождения оставшихся минут вычислим остаток от деления 128 на 60 — получим 8. Следовательно, 128 секунд равны двум минутам и восьми секундам.

Операция modulo активно используется в [криптографии](https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities)).

### Битовые операции

Ещё один тип математических действий, который активно используется в программировании, — это [**битовые операции**](https://ru.wikipedia.org/wiki/Битовая_операция). Своё название они получили потому, что совершаются над каждым битом числа. Другими словами, чтобы выполнить такую операцию, вам необходимо сначала представить число в двоичном виде, а затем применить действие над его каждым разрядом.

Начнём с самой простой битовой операции — отрицания. Она иногда обозначается как НЕ или NOT. Чтобы выполнить побитовое отрицание, необходимо заменить каждый разряд в двоичном представлении числа на противоположный. То есть единица заменяется на ноль и наоборот. Например, выполним побитовое отрицание числа 5:
{line-numbers: false}
```
5 = 101
NOT 5 = 010
```

Это действие достаточно простое, если мы ограничимся только математикой. В программировании с ним возникает несколько сложностей. Прежде всего сразу стоит задать вопрос: сколько байт отводится под число? Предположим, что в нашем примере 5 хранится в двухбайтовой переменной. Тогда в памяти в двоичном виде оно будет выглядеть так:
{line-numbers: false}
```
00000000 00000101
```

После побитового отрицания содержимое переменной станет таким:
{line-numbers: false}
```
11111111 11111010
```

Теперь возникает другой вопрос: как интерпретировать результат? Если переменная была объявлена как беззнаковая, нашим результатом будет число 65530. Если же переменная знаковая, дело осложняется.

### Оператор ((

Bash поддерживает целочисленную арифметику. Она выполняет в так называемом **математическом контексте** (math context).

Для вычисления арифметических выражений используется оператор `((`. Результат его работы зависит от наличия знака `$`. Если перед оператором стоит `$`, арфиметическое выражение будет вычисленно и интерпретатор подставит его результат. Если знакак `$` нет, после вычисления будет подставлено логическое значение, соответствующее результату. Рассмотрим эти случаи на примерах.

Предположим, что вам необходимо сохранить в переменной `var` результат сложения двух чисел. Вы можете объявить её целочисленной и присвоить ей значение при объявлении без дополнительных операторов. Например так:
{line-numbers: false, format: Bash}
```
declare -i var=12+7
```

Если переменная объявлена как строковая, вы также можете присвоить ей результат арфиметического выражения с помощью оператора `((`. Например:
{line-numbers: false, format: Bash}
```
var=$((12+7))
```

Оператор `((` является синонимом встроенной команды `let`, точно так же как оператор `[[` является синонимом `test`.

С помощью команды `let` мы можем записать прошлый пример следующими способами:
{line-numbers: true, format: Bash}
```
let var=12+7
let var="12 + 7"
let "var = 12 + 7"
let 'var = 12 + 7'
```

Обратите внимание, что каждый параметр команды `let` должен быть корректным арифметическим выражением. Если в выражении встречаются пробелы, оно будет разделено ими на части в результате word splitting. Тогда `let` попытается вычислить каждую часть по отдельности, что приведёт к ошибке. Это значит, что следующее выражение будет некорректно:
{line-numbers: false, format: Bash}
```
let var=12 + 7
```

Чтобы предотвратить word splitting, необходимо заключать выражение в одинарные или двойные кавычки. Эта подстановка не выполняется в операторе `((`. Поэтому всегда предпочитайте использовать его.

I> Кроме встроенной команды `let` есть две другие устаревшие формы для вычисления арифметических выражений: `$[ ]` и `expr`. Никогда их не используйте.

Таблица 3-9 демонстрирует операции, допустимые в арфиметических выражениях.

{caption: "Таблица 3-9. Операции в арифметических выражениях", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| | **Вычисления** | |
|  | | |
| `*` | Умножение | `echo "$((2*9)) = 18"` |
| `/` | Деление | `echo "$((25/5)) = 5"` |
| `%` | Остаток от деления | `echo "$((8%3)) = 2"` |
| `+` | Сложение | `echo "$((7+3)) = 10"` |
| `-` | Вычитание | `echo "$((8-5)) = 3"` |
| `**` | Возведение в степень |  `echo "$((4**3)) = 64"` |
|  | | |
| | **Битовые операции** | |
|  | | |
| `~` |  | |
| `<<` |  | |
| `>>` |  | |
| `&` |  | |
| `^` |  | |
| `|` |  | |
|  | | |
| | **Присваивания** | |
|  | | |
| `=` | Обычное присваивание | `echo "$((num=5)) = 5"` |
| `*=` | Умножение и присваивание результата | `echo "$((num+=5)) = 10"` |
| `/=` | Деление и присваивание результата | `echo "$((num/=2)) = 5"` |
| `%=` | Остаток от деления и присваивание результата | `echo "$((num%=2)) = 1"` |
| `+=` | Сложение и присваивание результата | `echo "$((num+=7)) = 8"` |
| `-=` | Вычитание и присваивание результата | `echo "$((num-=3)) = 5"` |
| `<<=` | Битовый сдвиг влево и присваивание результата | `echo "$((num<<=1)) = 10` |
| `>>=` | Битовый сдвиг вправо и присваивание результата | `echo "$((num>>=2)) = 2"` |
| `&=` | Побитовое И (AND), затем присваивание результата | `echo "$((num&=3)) = 2"` |
| `^=` | Побитовое [исключающее ИЛИ](https://ru.wikipedia.org/wiki/Исключающее_«или») (XOR), затем присваивание результата | `echo "$((num^=7)) = 5"` |
| `|=` | Побитовое ИЛИ (OR), затем присваивание результата | `echo "$((num|=7)) = 7"` |
|  | | |
| | **Логические операции** | |
|  | | |
| `!` |  | |
| `&&` |  | |
| `||` |  | |
|  | | |
| | **Сравнения** | |
|  | | |
| `<` |  | |
| `>` |  | |
| `<=` |  | |
| `>=` |  | |
| `==` |  | |
| `!=` |  | |
|  | | |
| | **Другие операции** | |
|  | | |
| `num++` |  | |
| `num--` |  | |
| `++num` |  | |
| `--num` |  | |
| `+num` |  | |
| `-num` |  | |
| `УСЛОВИЕ ? ДЕЙСТВИЕ1 : ДЕЙСТВИЕ2` |  | |
| `ДЕЙСТВИЕ1, ДЕЙСТВИЕ2` |  | |
| `( ДЕЙСТВИЕ1 )` |  | |

// TODO: Объяснить все операции

// TODO: Таблица с форматами чисел (системы счисления).

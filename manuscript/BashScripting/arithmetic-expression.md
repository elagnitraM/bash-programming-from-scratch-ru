## Арифметические выражения

Интерпретатор Bash позволяет выполнять математические операции над целыми числами. К ним относятся не только хорошо известные арифметические действия (сложение, вычитание, умножение и деление), но также битовые и логические операции. Эти операции применяются практически во всех современных языках программирования. Поэтому рассмотрим их подробнее.

### Арифметические действия

Начнём с самых простых математических операций — арифметических. В языках программирования они обозначаются привычными символами:

* `+` сложение
* `-` вычитание
* `/` деление
* `*` умножение

В программировании помимо перечисленных часто используются ещё два действия: возведение в степень и вычисление [остатка от деления](https://ru.wikipedia.org/wiki/Деление_с_остатком).

Возведение в степень принято записывать в виде a^b^, где `a` является основанием, а `b` — показателем. Например, два в степени семь записывается как 2^7^. В Bash это арифметическое действие обозначается двумя символа звёздочки `*`:
{line-numbers: false}
```
2**7
```

Вычисление остатка от деления — более сложная операция. В чём она заключается и для чего применяется?

Если в результате деления одного целого числа на другое получается дробное, возникает остаток. Например, разделим 10 (делимое) на 3 (делитель). В результате с округлением получится 3,33333 (частное). В этом случае остаток от деления будет равен 1. Чтобы его вычислить, необходимо делитель 3 умножить на целую часть частного (или неполное частное) 3. Затем получившиеся число 9 вычтем из делимого 10 и получим 1.

Обозначим делимое буквой `a`, делитель — `b`, неполное частное — `q`, а остаток как `r`. Тогда формулу нахождения делимого `a` можно записать так:
{line-numbers: false}
```
a = b * q + r
```

Отсюда можно вывести формулу для нахождения остатка:
{line-numbers: false}
```
r = a - b * q
```

Выбор неполного частного `q` вызывает вопросы. Может показаться, что в качестве него можно использовать любое число. Но для выбора частного есть важное ограничение. Оно должно быть таким, чтобы остаток от деления `r` по абсолютной величине оказался меньше делителя `b`. Другими словами должно выполняться неравенство `|r| < |b|`.

Вычисление остатка в Bash обозначается знаком `%`. Обратите внимание, что в некоторых языках этим же символом обозначается операция [**modulo**](https://en.wikipedia.org/wiki/Modulo_operation). В общем случае это [два разных действия](https://habr.com/ru/post/421071). Но они дают одинаковый результат, когда знаки делимого и делителя совпадают.

Например вычислим остаток и modulo для следующих случаев:
{line-numbers: false}
```
19 % 12 = 19 - 12 * 1 = 7
19 modulo 12 = 19 - 12 * 1 = 7

-19 % -12 = -19 - (-12) * 1 = -7
-19 modulo -12 = -19 - (-12) * 1 = -7
```

Если знаки делимого и делителя различаются, остаток и modulo — разные:
{line-numbers: false}
```
19 % -12 = 19 - (-12) * (-1) = 7
19 modulo -12 = 19 - (-12) * (-2) = -5

-19 % 12 = -19 - 12 * (-1) = -7
-19 modulo 12 = -19 - 12 * (-2) = 5
```

Обратите внимание, что для расчёта modulo используется та же формула, что и для остатка, но выбирается другое неполное частное `q`. Для нахождения остатка, оно вычисляется по следующей формуле:
{line-numbers: false}
```
a / b = q
```

Результат следует округлить к меньшему по модулю. То есть отбросить все знаки после запятой. Неполное частное для modulo считается так же, но только когда `a` и `b` имеют одинаковые знаки. Если знаки разные, формула выглядит так:
{line-numbers: false}
```
a / b = q - 1
```

Результат также надо округлить к меньшему по модулю.

Обычно когда говорят об остатке `r`, подразумевают, что делимое `a` и делитель `b` положительны. Поэтому в справочниках часто можно встретить следующее условие: `0 ≤ r < |b|`. Но в случае деления чисел с разными знаками остаток может быть отрицательным. Запомните простое правило: у остатка всегда такой же знак, что и у делимого. Если знаки различаются, значит вы нашли modulo.

Всегда помните о различии остатка от деления и modulo при программировании на любом языке. Если вы сомневаетесь в своих вычисления, вы можете их проверить. Предположим, что вам нужно найти остаток деления 32 на -7. Для этого выполните следующую команду в Bash:
{line-numbers: false, format: Bash}
```
echo $((32 % -7))
```

Результат будет равен четырём.

Чтобы найти modulo для этой же пары чисел, наберите в поисковике Google следующую строку:
{line-numbers: false, format: Bash}
```
32 % -7
```

В результате на странице браузера будет выведен калькулятор с ответом -3.

Для чего используется вычисление остатка от деления? Одна из самых распространённых задач — проверка числа на чётность. Она возникает в коммуникациях, чтобы проверить корректность принятых данных. Этот подход известен как [**бит контроля чётности**](https://ru.wikipedia.org/wiki/Бит_чётности).

Чтобы проверить число на чётность, достаточно вычислить остаток его деления на 2. Если остаток равен нулю, значит число чётное. В противном случае — нечётное.

Другая распространённая задача в которой не обойтись без вычисления остатка — это преобразование единиц времени. Рассмотрим пример. Предположим, что нам надо перевести 128 секунд в минуты. Для этого нам надо подсчитать целое число минут и приписать к нему остаток. Чтобы найти минуты, разделим 128 на 60. Получим неполный остаток 2. Для нахождения оставшихся минут вычислим остаток от деления 128 на 60 — получим 8. Следовательно, 128 секунд равны двум минутам и восьми секундам.

Операция modulo активно используется в [криптографии](https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities)).

{caption: "Упражнение 3-6. Вычисление остатка от деления и modulo", format: text, line-numbers: false}
```
Вычислите остаток от деления и modulo:

* 1697 % 13
* 1697 modulo 13

* 772 % -45
* 772 modulo -45

* -568 % 12
* -568 modulo 12

* -5437 % -17
* -5437 modulo -17
```

### Представление целых чисел

Прежде чем мы познакомимся с битовыми операциями, будет полезно рассмотреть способы представления целых чисел в памяти компьютера.

Целые числа могут быть положительными и отрицательными. Соответствующий им тип данных называется [**целое**](https://ru.wikipedia.org/wiki/Целое_(тип_данных)) или [**integer**](https://en.wikipedia.org/wiki/Integer_(computer_science)).

Если переменная целого типа может принимать только положительные значения, она называется **беззнаковой** (unsigned). Если допустимы как положительные, так и отрицательные значения — это переменная **со знаком** (signed).

Наиболее известны и распространены следующие три способа представления целых в памяти компьютера:

* [**Прямой код**](https://ru.wikipedia.org/wiki/Прямой_код) (signed magnitude representation или SMR).
* [**Обратный код**](https://ru.wikipedia.org/wiki/Обратный_код) (ones' complement).
* [**Дополнительный код**](https://ru.wikipedia.org/wiki/Дополнительный_код) (two’s complement).

#### Прямой код

Прямой код может использоваться в двух вариантах:

* Для записи только положительных целых (беззнаковых).
* Для записи как положительных, так и отрицательных целых (со знаком).

В первом варианте все разряды двоичного числа используются для хранения его значения. Примеры хранения беззнаковых целых в прямом коде приведены в таблице 3-9.

{caption: "Таблица 3-9. Представление беззнаковых целых в прямом коде", width: "70%"}
| Десятичное число | Шестнадцатеричный формат | Прямой код |
| --- | --- | --- |
| 0 | 0 | 0000 0000 |
| 5 | 5 | 0000 0101 |
| 60 | 3C | 0011 1100 |
| 110 | 6E | 0110 1110 |
| 255 | FF | 1111 1111 |

В одном байте с помощью представления в прямом коде можно сохранить целые беззнаковые от 0 до 255.

Прямой код можно использовать и для хранения целых со знаком. В этом случае старший бит резервируется для знака числа. Другими словами на значение числа отводится только семь битов из восьми доступных, если для переменной зарезервирован один байт. Таблица 3-10 демонстрирует представление целых со знаком в прямом коде.

{caption: "Таблица 3-10. Представление целых со знаком в прямом коде", width: "70%"}
| Десятичное число | Шестнадцатеричный формат | Прямой код |
| --- | --- | --- |
| -127 | FF | 1111 1111 |
| -110 | EE | 1110 1110 |
| -60 | BC | 1011 1100 |
| -5 | 85 | 1000 0101 |
| -0 | 80 | 1000 0000 |
| 0 | 0 | 0000 0000 |
| 5 | 5 | 0000 0101 |
| 60 | 3C | 0011 1100 |
| 110 | 6E | 0110 1110 |
| 127 | 7F | 0111 1111 |

Обратите внимание, что старший бит всех отрицательных чисел равен единице, а положительных — нулю.

Из-за использования старшего бита для знака, мы больше не можем сохранить числа больше 127 в одном байте. По этой же причине минимальное отрицательное число равно -127.

Прямой код не получил широкого распространения в компьютерной технике по двум причинам:

1. Арифметические операции над отрицательными числами требуют усложнения архитектуры процессора. Модуль для суммирования положительных чисел для этих целей не подходит.

2. Существует два представления нуля: положительное (0000 0000) и отрицательное (1000 0000). Это осложняет арифметические сравнения, поскольку эти значения не равны.

Понимание принципа работы прямого кода пригодится нам при рассмотрении оставшихся двух способов представления целых.

#### Обратный код

Обратный код решает первую проблему прямого кода, связанную с действиями над отрицательными числами. Разберёмся, почему вообще возникла эта сложность.

Предположим, что нам надо сложить 10 и -5. Для начала представим эти числа в прямом коде. Предположим, что на каждому из них отводится один байт в памяти компьютера. Тогда получим следующий результат:
{line-numbers: false}
```
10 = 0000 1010
-5 = 1000 0101
```

Теперь возникает вопрос — как процессору следует складывать эти два числа? У любого современного процессора есть стандартный модуль под названием [**сумматор**](https://ru.wikipedia.org/wiki/Сумматор). Он позволяет побитово складывать числа. Если мы применим его для нашей задачи, то получим следующее:
{line-numbers: false}
```
10 + (-5) = 0000 1010 + 1000 0101 = 1000 1111 = -15
```

Мы получили неправильный результат. Это означает, что сумматор не подходит для арифметических операций над целыми в прямом коде. Вместо него нужен другой модуль процессора, который бы выполнял операцию в зависимости от старшего бита числа.

Вместо того чтобы усложнять процессор, можно изменить способ представления отрицательных целых.

В обратном коде положительные целые представляются точно также, как в прямом коде. Старший бит отводится под знак и равен нулю, а остальные используются для значения числа. Если число отрицательное, старший бит равен единице, а оставшиеся разряды инвертируются. Это означает, что нули становятся единицами и наоборот.

Таблица 3-11 демонстрирует представление некоторых чисел в обратном коде.

{caption: "Таблица 3-11. Представление целых со знаком в обратном коде", width: "70%"}
| Десятичное число | Шестнадцатеричный формат | Обратный код |
| --- | --- | --- |
| -127 | 80 | 1000 0000 |
| -110 | 91 | 1001 0001 |
| -60 | C3 | 1100 0011 |
| -5 | FA | 1111 1010 |
| -0 | FF | 1111 1111 |
| 0 | 0 | 0000 0000 |
| 5 | 5 | 0000 0101 |
| 60 | 3C | 0011 1100 |
| 110 | 6E | 0110 1110 |
| 127 | 7F | 0111 1111 |

В одном байте можно сохранить числа от -127 до 127, как и в прямом коде. Главное отличие заключается в представлении отрицательных чисел.

Что нам дало инвертирование разрядов отрицательных чисел? Попробуем опять выполнить сложение чисел 10 и -5, но на этот раз представим их в обратном коде. Они будут выглядеть следующим образом:
{line-numbers: false}
```
10 = 0000 1010
-5 = 1111 1010
```

Теперь сложим эти два числа с помощью стандартного сумматора. Получим следующее:
{line-numbers: false}
```
10 + (-5) = 0000 1010 + 1111 1010 = 1 0000 0100
```

Обратите внимание, что в результате сложения произошло переполнение. Старшая единица не поместилась в один байт, отведённый под число. В этом случае её надо отбросить. Тогда получим:
{line-numbers: false}
```
0000 0100
```

На втором этапе вычисления надо прибавить отброшенную единицу к результату: 
{line-numbers: false}
```
0000 0100 + 0000 0001 = 0000 0101 = 5 
```

Это правильный результат сложения чисел 10 и -5.

Если в результате сложения получается отрицательное число, второй этап вычисления не нужен. Для примера сложим числа -7 и 2. Сначала представим их в обратном коде:
{line-numbers: false}
```
-7 = 1111 1000
2 = 0000 0010
```

Выполним первый этап сложения:
{line-numbers: false}
```
-7 + 2 = 1111 1000 + 0000 0010 = 1111 1010
```

Мы получили отрицательное число, потому что старший бит равен единице. В этом случае компьютеру больше не нужно совершать никаких действий. Он может использовать полученный результат для дальнейший вычислений.

Для человека будет удобнее перевести отрицательное число из обратного кода в прямой, чтобы проверить корректность результата. Для этого инвертируем все разряды со значением, а знаковый оставляем без изменений. В результате получим следующее: 
{line-numbers: false}
```
1111 1010 -> 1000 0101 = -5
```

Обратный код позволил совершать арифметические действия над отрицательными числами с помощью стандартного сумматора. Однако, эти действия происходят в два этапа, а не в один. Кроме того, проблема с представлением нуля двумя способами осталась нерешённой.

#### Дополнительный код

Дополнительный код решает обе проблемы обратного кода. Во-первых, он позволяет выполнять арифметические действия за одну операцию. Во-вторых, в нём ноль может быть представлен единственным способ.

В дополнительном коде положительные числа соответствуют своему представлению в прямом коде: старший разряд равен нулю, а остальные используются для значения числа. Все разряды отрицательных чисел (включая старший знаковый) инвертируются точно также как и в обратном коде. После этого к результату прибавляет единица.

Представление некоторых чисел в дополнительном коде приведено в таблице 3-12.

{caption: "Таблица 3-12. Представление целых со знаком в дополнительном коде", width: "70%"}
| Десятичное число | Шестнадцатеричный формат | Дополнительный код |
| --- | --- | --- |
| -127 | 81 | 1000 0001 |
| -110 | 92 | 1001 0010 |
| -60 | C4 | 1100 0100 |
| -5 | FB | 1111 1011 |
| 0 | 0 | 0000 0000 |
| 5 | 5 | 0000 0101 |
| 60 | 3C | 0011 1100 |
| 110 | 6E | 0110 1110 |
| 127 | 7F | 0111 1111 |

Диапазон допустимых значений для однобайтового целого такой же, как и для представления числа в обратном коде: от -127 до 127.

Рассмотрим, как стали выглядеть арифметические операции над отрицательными числами в обратном коде. Например, сложим числа 14 и -8. Сначала представим каждое из них в дополнительном коде. Получим:
{line-numbers: false}
```
14 = 0000 1110
-8 = 1111 1000
```

Теперь выполним сложение:
{line-numbers: false}
```
14 + (-8) = 0000 1110 + 1111 1000 = 1 0000 0110
```

В результате сложения произошло переполнение. Старшую единицу надо отбросить. Тогда мы получим конечный результат:
{line-numbers: false}
```
0000 0110 = 6
```

Если результат сложения отрицательный, то отбрасывать старший разряд ненужно. Для примера сложим числа -25 и 10. В дополнительном коде они выглядят так:
{line-numbers: false}
```
-25 = 1110 0111
10 = 0000 1010

-25 + 10 = 1110 0111 0000 1010 = 1111 0001
```

Переведём результат `1111 0001` из дополнительного кода в обратный, а потом в прямой. Для этого выполним следующие преобразования:
{line-numbers: false}
```
1111 0001 - 1 = 1111 0000 -> 1000 1111 = -15
```

При переводе из обратного кода в прямой мы инвертируем все разряды кроме старшего со знаком. В итоге мы получили корректный результат сложения.

Благодаря дополнительному коду стало возможно выполнять арифметические действия с отрицательными числами с помощью стандартного сумматора за один этап. Также решилась проблема с представлением нуля двумя разными способами.

В современных компьютерах целые представляются в дополнительном коде.

{caption: "Упражнение 3-7. Арифметические действия в дополнительном коде", format: text, line-numbers: false}
```
Выполните сложение следующих однобайтовых целых:

* 79 и -46
* -97 и 96

Выполните сложение следующих двухбайтовых целых:

* 12868 и -1219
```

### Битовые операции

Ещё один тип математических действий, который активно используется в программировании, — это [**битовые операции**](https://ru.wikipedia.org/wiki/Битовая_операция). Своё название они получили потому, что совершаются над каждым битом числа по отдельности. Другими словами, чтобы выполнить такую операцию, вам необходимо сначала представить число в двоичном виде, а затем применить действие над каждым его разрядом.

#### Побитовое отрицание

Начнём с самой простой битовой операции — отрицания. В компьютерной литературе она иногда обозначается как НЕ или NOT, а в Bash — знаком тильда `~`.

Чтобы выполнить побитовое отрицание, необходимо заменить каждый разряд в двоичном представлении числа на противоположный. То есть каждая единица заменяется на ноль и наоборот. Например, выполним побитовое отрицание числа 5:
{line-numbers: false}
```
5 = 101
~5 = 010
```

Это действие достаточно простое, если мы ограничимся только математикой. В программировании с ним возникает несколько сложностей. Прежде всего сразу возникает вопрос: сколько байтов отводится под число? Предположим, что число 5 в нашем примере хранится в двухбайтовой переменной. Тогда в памяти в двоичном виде оно будет выглядеть так:
{line-numbers: false}
```
00000000 00000101
```

После побитового отрицания содержимое переменной станет таким:
{line-numbers: false}
```
11111111 11111010
```

Теперь возникает другой вопрос: как интерпретировать полученный результат? Если переменная была объявлена как беззнаковое целое, нашим результатом будет число 65530 в прямом коде. Если же переменная знаковая, её значение необходимо представить в дополнительном коде. В этом случае мы получим -6.

По умолчанию Bash представляет все целые знаковыми и отводит под них 64 бита. Это значит, что максимальное положительное число в Bash равно 7FFFFFFFFFFFFFFF в HEX или 9223372036854775807 в DEC. Минимальное отрицательное число равно 8000000000000000 в HEX или -9223372036854775808 в DEC.

Встроенная команда Bash `printf` может запутать при проверке максимально допустимого положительного целого. Она позволяет указать формат, в котором следует интерпретировать её входные параметры. Вы можете указать формат беззнакового 64-битного целого. Тогда число FFFFFFFFFFFFFFFF будет представлено `printf` как 18446744073709551615. Однако другие команды (например `echo`) и операторы Bash будут интерпретировать это число как знаковое и равное -1. Выводы следующих команд демонстриурют сказанное:
{line-numbers: true, format: Bash}
```
$ echo $((16#FFFFFFFFFFFFFFFF))
-1
$ printf "%llu\n" $((16#FFFFFFFFFFFFFFFF))
18446744073709551615
```

В этом случае правильное значение числа выводит команда `echo`.

Учитывая, что все целые в Bash являются знаковыми, результат побитового отрицания числа 5 будет равен -6. Вывести результат этого вычисления можно следующей командой:
{line-numbers: true, format: Bash}
```
$ echo $((~5))
-6
```

// TODO: Упражнение

### Оператор ((

Bash поддерживает целочисленную арифметику. Она выполняет в так называемом **математическом контексте** (math context).

Для вычисления арифметических выражений используется оператор `((`. Результат его работы зависит от наличия знака `$`. Если перед оператором стоит `$`, арфиметическое выражение будет вычисленно и интерпретатор подставит его результат. Если знакак `$` нет, после вычисления будет подставлено логическое значение, соответствующее результату. Рассмотрим эти случаи на примерах.

Предположим, что вам необходимо сохранить в переменной `var` результат сложения двух чисел. Вы можете объявить её целочисленной и присвоить ей значение при объявлении без дополнительных операторов. Например так:
{line-numbers: false, format: Bash}
```
declare -i var=12+7
```

Если переменная объявлена как строковая, вы также можете присвоить ей результат арфиметического выражения с помощью оператора `((`. Например:
{line-numbers: false, format: Bash}
```
var=$((12+7))
```

Оператор `((` является синонимом встроенной команды `let`, точно так же как оператор `[[` является синонимом `test`.

С помощью команды `let` мы можем записать прошлый пример следующими способами:
{line-numbers: true, format: Bash}
```
let var=12+7
let var="12 + 7"
let "var = 12 + 7"
let 'var = 12 + 7'
```

Обратите внимание, что каждый параметр команды `let` должен быть корректным арифметическим выражением. Если в выражении встречаются пробелы, оно будет разделено ими на части в результате word splitting. Тогда `let` попытается вычислить каждую часть по отдельности, что приведёт к ошибке. Это значит, что следующее выражение будет некорректно:
{line-numbers: false, format: Bash}
```
let var=12 + 7
```

Чтобы предотвратить word splitting, необходимо заключать выражение в одинарные или двойные кавычки. Эта подстановка не выполняется в операторе `((`. Поэтому всегда предпочитайте использовать его.

I> Кроме встроенной команды `let` есть две другие устаревшие формы для вычисления арифметических выражений: `$[ ]` и `expr`. Никогда их не используйте.

Таблица 3-13 демонстрирует операции, допустимые в арфиметических выражениях.

{caption: "Таблица 3-13. Операции в арифметических выражениях", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| | **Вычисления** | |
|  | | |
| `*` | Умножение | `echo "$((2*9)) = 18"` |
| `/` | Деление | `echo "$((25/5)) = 5"` |
| `%` | Остаток от деления | `echo "$((8%3)) = 2"` |
| `+` | Сложение | `echo "$((7+3)) = 10"` |
| `-` | Вычитание | `echo "$((8-5)) = 3"` |
| `**` | Возведение в степень |  `echo "$((4**3)) = 64"` |
|  | | |
| | **Битовые операции** | |
|  | | |
| `~` |  | |
| `<<` |  | |
| `>>` |  | |
| `&` |  | |
| `^` |  | |
| `|` |  | |
|  | | |
| | **Присваивания** | |
|  | | |
| `=` | Обычное присваивание | `echo "$((num=5)) = 5"` |
| `*=` | Умножение и присваивание результата | `echo "$((num+=5)) = 10"` |
| `/=` | Деление и присваивание результата | `echo "$((num/=2)) = 5"` |
| `%=` | Остаток от деления и присваивание результата | `echo "$((num%=2)) = 1"` |
| `+=` | Сложение и присваивание результата | `echo "$((num+=7)) = 8"` |
| `-=` | Вычитание и присваивание результата | `echo "$((num-=3)) = 5"` |
| `<<=` | Битовый сдвиг влево и присваивание результата | `echo "$((num<<=1)) = 10` |
| `>>=` | Битовый сдвиг вправо и присваивание результата | `echo "$((num>>=2)) = 2"` |
| `&=` | Побитовое И (AND), затем присваивание результата | `echo "$((num&=3)) = 2"` |
| `^=` | Побитовое [исключающее ИЛИ](https://ru.wikipedia.org/wiki/Исключающее_«или») (XOR), затем присваивание результата | `echo "$((num^=7)) = 5"` |
| `|=` | Побитовое ИЛИ (OR), затем присваивание результата | `echo "$((num|=7)) = 7"` |
|  | | |
| | **Логические операции** | |
|  | | |
| `!` |  | |
| `&&` |  | |
| `||` |  | |
|  | | |
| | **Сравнения** | |
|  | | |
| `<` |  | |
| `>` |  | |
| `<=` |  | |
| `>=` |  | |
| `==` |  | |
| `!=` |  | |
|  | | |
| | **Другие операции** | |
|  | | |
| `num++` |  | |
| `num--` |  | |
| `++num` |  | |
| `--num` |  | |
| `+num` |  | |
| `-num` |  | |
| `УСЛОВИЕ ? ДЕЙСТВИЕ1 : ДЕЙСТВИЕ2` |  | |
| `ДЕЙСТВИЕ1, ДЕЙСТВИЕ2` |  | |
| `( ДЕЙСТВИЕ1 )` |  | |

// TODO: Объяснить все операции

// TODO: Таблица с форматами чисел (системы счисления).

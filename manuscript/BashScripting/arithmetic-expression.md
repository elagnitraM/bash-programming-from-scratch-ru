## Арифметические выражения

Интерпретатор Bash может выполнять математические операции над целыми числами. К таким операциям относятся простые арифметические действия: сложение, вычитание, умножение и деление. Кроме них есть битовые и логические операции. Они часто применяются в программировании. Поэтому в этом разделе мы рассмотрим их подробнее.

I> В Bash для арифметики с плавающей точкой используйте калькулятор [bc](https://ru.wikipedia.org/wiki/Bc) или [dc](https://ru.wikipedia.org/wiki/Dc).

### Представление целых чисел

Рассмотрим способы представления целых чисел в памяти компьютера. Это поможет лучше понять, как работают математические операции в Bash.

Целые числа могут быть положительными и отрицательными. Соответствующий им тип данных называется [**целое**](https://ru.wikipedia.org/wiki/Целое_(тип_данных)) ([integer](https://en.wikipedia.org/wiki/Integer_(computer_science))).

Если переменная целого типа принимает только положительные значения, она называется **беззнаковой** (unsigned). Если допустимы как положительные, так и отрицательные значения — это переменная **со знаком** (signed).

Наиболее распространены три способа представления целых в памяти компьютера:

* [**Прямой код**](https://ru.wikipedia.org/wiki/Прямой_код) (signed magnitude representation или SMR).

* [**Обратный код**](https://ru.wikipedia.org/wiki/Обратный_код) (ones' complement).

* [**Дополнительный код**](https://ru.wikipedia.org/wiki/Дополнительный_код) (two’s complement).

#### Прямой код

Все числа в памяти компьютера представляются в двоичном виде. То есть любое число — это последовательность нулей и единиц. Что означают эти нули и единицы, зависит от способа представления числа.

Начнём с самого простого представления чисел — прямого кода. Его можно использовать двумя способами:

* Для записи только положительных целых (беззнаковых).

* Для записи как положительных, так и отрицательных целых (со знаком).

Под любое число отводится фиксированный блок памяти. В первом варианте прямого кода все биты этой памяти используются одинаково. В них хранится значение числа. Таблица 3-13 приводит примеры такого способа хранения.

{caption: "Таблица 3-13. Представление беззнаковых целых в прямом коде", width: "70%"}
| Десятичное число | Шестнадцатеричный формат | Прямой код |
| --- | --- | --- |
| 0 | 0 | 0000 0000 |
| 5 | 5 | 0000 0101 |
| 60 | 3C | 0011 1100 |
| 110 | 6E | 0110 1110 |
| 255 | FF | 1111 1111 |

Предположим, что на число выделен один байт памяти. Тогда в прямом коде можно сохранить целые беззнаковые числа от 0 до 255.

Прямой код можно использовать вторым способом. Он позволяет хранить целые числа со знаком. Для этого старший бит числа резервируется для знака. Поэтому на значение числа остаётся меньше битов. Например, отведём для хранения числа один байт памяти. Один бит уйдёт на знак. Останется только семь битов на значение числа.

Таблица 3-14 демонстрирует представление целых со знаком в прямом коде.

{caption: "Таблица 3-14. Представление целых со знаком в прямом коде", width: "70%"}
| Десятичное число | Шестнадцатеричный формат | Прямой код |
| --- | --- | --- |
| -127 | FF | 1111 1111 |
| -110 | EE | 1110 1110 |
| -60 | BC | 1011 1100 |
| -5 | 85 | 1000 0101 |
| -0 | 80 | 1000 0000 |
| 0 | 0 | 0000 0000 |
| 5 | 5 | 0000 0101 |
| 60 | 3C | 0011 1100 |
| 110 | 6E | 0110 1110 |
| 127 | 7F | 0111 1111 |

Обратите внимание, что старший (первый) бит всех отрицательных чисел равен единице, а положительных — нулю. Из-за знака теперь нельзя сохранить числа больше 127 в одном байте. По этой же причине минимальное отрицательное число равно -127.

Прямой код не получил широкого распространения в компьютерной технике по двум причинам:

1. Арифметические операции над отрицательными числами требуют усложнения архитектуры процессора. Модуль процессора для суммирования положительных чисел не подходит для отрицательных.

2. Существует два представления нуля: положительное (0000 0000) и отрицательное (1000 0000). Это осложняет операцию сравнения, так как в памяти эти значения не равны.

Постарайтесь разобраться в принципе работы прямого кода. Без этого вы не поймёте другие два способа представления целых.

#### Обратный код

У прямого кода есть два недостатка. Они привели к техническим проблемам при использовании кода в компьютерах. Это заставило инженеров искать альтернативное представление чисел в памяти. Так появился обратный код.

Первая проблема прямого кода связана с операциями над отрицательными числами. Прямой код решает именно её. Разберёмся, почему вообще возникла эта сложность.

Для примера сложим числа 10 и -5. Представим их в прямом коде. Предположим, что на каждое число отводится один байт в памяти компьютера. Тогда получим следующий результат:
{line-numbers: false}
```
10 = 0000 1010
-5 = 1000 0101
```

Теперь возникает вопрос — как процессору сложить эти числа? У любого современного процессора есть стандартный модуль под названием [**сумматор**](https://ru.wikipedia.org/wiki/Сумматор). Он побитово складывает два числа. Если применить его для нашей задачи, получим следующее:
{line-numbers: false}
```
10 + (-5) = 0000 1010 + 1000 0101 = 1000 1111 = -15
```

Результат неверный. Это означает, что сумматор не подходит для сложения целых в прямом коде. Проблема в том, что при сложении не учитывается старший бит числа.

Проблема решается двумя способами:

1. Добавить в процессор специальный модуль для операций над отрицательными числами.

2. Изменить способ представления отрицательных целых так, чтобы сумматор смог их складывать.

Развитие компьютерной техники пошло по второму пути. Он дешевле, чем усложнение процессора.

Принцип работы обратного кода очень похож на прямой код. Старший бит отводится под знак. Остальные биты хранят значение числа. Отличие в том, что для отрицательных чисел все биты значения инвертируются. То есть нули становятся единицами, а единицы — нулями. Биты значения положительных чисел не инвертируются.

Таблица 3-15 демонстрирует представление чисел в обратном коде.

{caption: "Таблица 3-15. Представление целых со знаком в обратном коде", width: "70%"}
| Десятичное число | Шестнадцатеричный формат | Обратный код |
| --- | --- | --- |
| -127 | 80 | 1000 0000 |
| -110 | 91 | 1001 0001 |
| -60 | C3 | 1100 0011 |
| -5 | FA | 1111 1010 |
| -0 | FF | 1111 1111 |
| 0 | 0 | 0000 0000 |
| 5 | 5 | 0000 0101 |
| 60 | 3C | 0011 1100 |
| 110 | 6E | 0110 1110 |
| 127 | 7F | 0111 1111 |

Вместимость памяти при использовании прямого и обратного кодов одинакова. В одном байте по-прежнему можно сохранить числа от -127 до 127.

Что дало инвертирование битов значения для отрицательных чисел? Проверим, как теперь будет работать сложение чисел. Представим 10 и -5 в обратном коде. Затем сложим их с помощью сумматора.

Числа в обратном коде выглядят так:
{line-numbers: false}
```
10 = 0000 1010
-5 = 1111 1010
```

Сложение даст следующее:
{line-numbers: false}
```
10 + (-5) = 0000 1010 + 1111 1010 = 1 0000 0100
```

Обратите внимание, что в результате сложения произошло переполнение. Старшая единица не поместилась в один байт, отведённый под число. В этом случае она отбрасывается. Тогда результат сложения станет таким:
{line-numbers: false}
```
0000 0100
```

Отброшенная единица влияет на конечный результат. Нужен второй этап вычисления, чтобы её учесть. На этом этапе просто добавим единицу к результату:
{line-numbers: false}
```
0000 0100 + 0000 0001 = 0000 0101 = 5
```

Мы получили правильный результат сложения чисел 10 и -5.

Если в результате сложения получилось отрицательное число, второй этап вычисления не нужен. Для примера сложим числа -7 и 2. Сначала представим их в обратном коде:
{line-numbers: false}
```
-7 = 1111 1000
2 = 0000 0010
```

Выполним первый этап сложения:
{line-numbers: false}
```
-7 + 2 = 1111 1000 + 0000 0010 = 1111 1010
```

Старший бит равен единице. Это значит, что мы получили отрицательное число. В этом случае второй этап сложения не нужен.

Проверим корректность результата. Для удобства переведём число из обратного кода в прямой. Чтобы это сделать, инвертируем все биты значения числа. Знаковый бит оставляем без изменений. В результате получим следующее:
{line-numbers: false}
```
1111 1010 -> 1000 0101 = -5
```

Мы снова получили верный результат.

Обратный код решил одну проблему. Если представить числа в нём, стандартный сумматор сможет их сложить независимо от знака. Недостаток такого решения в том, что сложение происходит в два этапа. Это замедляет работу компьютера.

У прямого кода есть вторая проблема: представление нуля двумя способами. Её обратный код решить не смог.

#### Дополнительный код

Дополнительный код решает обе проблемы прямого кода. Во-первых, он позволяет выполнять арифметические действия за одну операцию. Во-вторых, в нём ноль может быть представлен единственным способ.

В дополнительном коде положительные числа соответствуют своему представлению в прямом коде: старший разряд равен нулю, а остальные используются для значения числа. Все разряды отрицательных чисел (включая старший знаковый) инвертируются точно также как и в обратном коде. После этого к результату прибавляет единица.

Представление некоторых чисел в дополнительном коде приведено в таблице 3-16.

{caption: "Таблица 3-16. Представление целых со знаком в дополнительном коде", width: "70%"}
| Десятичное число | Шестнадцатеричный формат | Дополнительный код |
| --- | --- | --- |
| -127 | 81 | 1000 0001 |
| -110 | 92 | 1001 0010 |
| -60 | C4 | 1100 0100 |
| -5 | FB | 1111 1011 |
| 0 | 0 | 0000 0000 |
| 5 | 5 | 0000 0101 |
| 60 | 3C | 0011 1100 |
| 110 | 6E | 0110 1110 |
| 127 | 7F | 0111 1111 |

Диапазон допустимых значений для однобайтового целого такой же, как и для представления числа в обратном коде: от -127 до 127.

Рассмотрим, как стали выглядеть арифметические операции над отрицательными числами в обратном коде. Например, сложим числа 14 и -8. Сначала представим каждое из них в дополнительном коде. Получим:
{line-numbers: false}
```
14 = 0000 1110
-8 = 1111 1000
```

Теперь выполним сложение:
{line-numbers: false}
```
14 + (-8) = 0000 1110 + 1111 1000 = 1 0000 0110
```

В результате сложения произошло переполнение. Старшую единицу надо отбросить. Тогда мы получим конечный результат:
{line-numbers: false}
```
0000 0110 = 6
```

Если результат сложения отрицательный, то отбрасывать старший разряд ненужно. Для примера сложим числа -25 и 10. В дополнительном коде они выглядят так:
{line-numbers: false}
```
-25 = 1110 0111
10 = 0000 1010

-25 + 10 = 1110 0111 0000 1010 = 1111 0001
```

Переведём результат `1111 0001` из дополнительного кода в обратный, а потом в прямой. Для этого выполним следующие преобразования:
{line-numbers: false}
```
1111 0001 - 1 = 1111 0000 -> 1000 1111 = -15
```

При переводе из обратного кода в прямой мы инвертируем все разряды кроме старшего со знаком. В итоге мы получили корректный результат сложения.

Благодаря дополнительному коду стало возможно выполнять арифметические действия с отрицательными числами с помощью стандартного сумматора за один этап. Также решилась проблема с представлением нуля двумя разными способами.

В современных компьютерах целые представляются в дополнительном коде.

{caption: "Упражнение 3-7. Арифметические действия в дополнительном коде", format: text, line-numbers: false}
```
Выполните сложение следующих однобайтовых целых в дополнительном коде:

* 79 и -46
* -97 и 96

Выполните сложение следующих двухбайтовых целых в дополнительном коде:

* 12868 и -1219
```

#### Конвертирование чисел

Мы рассмотрели способы представления чисел в памяти компьютера. Может возникнуть вопрос — пригодятся ли эти знания на практике?

Современные языки программирования берут на себя большую часть работы по конвертированию чисел в правильный формат. Например, вы объявляете целую знаковую переменную в десятичной системе счисления для выполнения арифметических операций. Вам не надо заботиться о том, в каком виде она хранится в памяти компьютера. Если переменная примет отрицательное значение, она будет корректно сохранена в дополнительном коде без вашего участия.

Когда вам надо работать с переменной как с набором битов, вы объявляете её положительным целым и работаете с ней в шестнадцатеричной системе счисления. При этом вы используете все её разряды и никогда не переводите её в десятичную систему. Таким образом вы избегаете задачи конвертирования чисел.

Проблема возникает тогда, когда вам необходимо самостоятельно интерпретировать данные. Эта задача часто возникает в [системном программировании](https://ru.wikipedia.org/wiki/Системное_программное_обеспечение). К нему относится разработка драйверов устройств, ядер и модулей ОС, системных библиотек и стеков сетевых протоколов.

Предположим, что вы пишете драйвер для какого-то периферийного устройства. Каждый раз, когда вы получаете от него данные по некоторому интерфейсу, вы сталкиваетесь с задачей их правильной интерпретации. Представления чисел на этом устройстве и вашем компьютере могут отличаться (например, порядком байтов). В этом случае вам понадобятся знания о представлении чисел в памяти.

Ещё одна важная задача с которой сталкивается каждый программист — это [**отладка**](https://ru.wikipedia.org/wiki/Отладка_программы). Отладкой программы называется поиск и устранение в ней ошибок. Проверяя корректность выполнения арифметических выражений, вы легко сможете обнаружить ошибку переполнения, если знаете о знаковом разряде числа.

### Оператор ((

Целочисленная арифметика в Bash выполняет в так называемом **математическом контексте** (math context). В нём применяется синтаксис, напоминающий язык C для целочисленной арифметики.

Предположим, что вам необходимо сохранить результат сложения двух чисел в переменной `var`. Вы можете объявить её с целочисленным атрибутом `-i` и сразу же присвоить ей значение. Например так:
{line-numbers: false, format: Bash}
```
declare -i var=12+7
```

Если переменная объявлена с атрибутом `-i`, любое присваиваемое ей выражение будет вычисляться в математическом контексте. Другими словами присвоение значения такой переменной будет выполняться так, как будто перед ним стоит встроенная команда `let`. Поэтому следующие команды будут эквивалентны:
{line-numbers: true, format: Bash}
```
let var=5*7
var=5*7
```

Такое неявное применение математического контекста может стать источником ошибок. Поэтому рекомендуется не использовать атрибут `-i` при объявлении переменных. Независимо от наличия атрибута, их значение в памяти будет храниться в виде строк. Конвертирование строк в числа и обратно будет происходить каждый раз во время подстановок.

Если переменная объявлена как строковая, ей можно присвоить результат арифметического выражения с помощью встроенной команды `let`. Например, одним из следующих способов:
{line-numbers: true, format: Bash}
```
let var=12+7
let var="12 + 7"
let "var = 12 + 7"
let 'var = 12 + 7'
```

Все четыре команды дадут один и тот же результат: переменной `var` будет присвоено значение 19.

Каждый параметр команды `let` должен быть корректным арифметическим выражением. Если в выражении встречаются пробелы, оно будет разделено ими на части в результате word splitting. Тогда `let` попытается вычислить каждую часть по отдельности, что может привести к ошибке. Это значит, что следующая команда некорректна:
{line-numbers: false, format: Bash}
```
let var=12 + 7
```

В этом случае `let` попытается вычислить по отдельности три выражения: `var=12`, `+` и `7`. Проблема возникнет с вычислением `+`. Это арифметическое действие требует операндов, но их нет. Если все переданные в `let`выражения корректны, они будут вычислены друг за другом. Например:
{line-numbers: true, format: Bash}
```
let a=1+1 b=5+1
let "a = 1 + 1" "b = 5 + 1"
let 'a = 1 + 1' 'b = 5 + 1'
```

Чтобы предотвратить word splitting, необходимо заключать арифметические выражения в одинарные или двойные кавычки.

У встроенной команды `let` есть синоним — оператор `((`. Внутри него word splitting не выполняется, и поэтому указанные в нём выражения не требуют кавычек. Всегда предпочитайте использовать оператор `((` вместо `let`, чтобы избежать ошибок.

I> Отношения оператора `((` и команды `let` напоминают `test` и `[[`. В обоих случаях лучше использовать операторы, а не команды.

Оператор `((` имеет две формы. Первая форма называется **арифметическая оценка** ([arithmetic evaluation](https://wiki.bash-hackers.org/syntax/ccmd/arithmetic_eval)) и является полным аналогом команды `let`. Она выглядит следующим образом:
{line-numbers: false, format: Bash}
```
((var = 12 + 7))
```

В этой конструкции команда `let` заменяется на открывающие скобки `((`, а в конце добавляются закрывающие — `))`. Как и любая команда, такая форма оператора возвращает 0 в случае успешного выполнения и 1 в случае ошибки.

Вторая форма оператора `((` называется **арифметическая подстановка** ([arithmetic expansion](https://wiki.bash-hackers.org/syntax/expansion/arith)) и выглядит следующим образом:
{line-numbers: false, format: Bash}
```
var=$((12 + 7))
```

В ней перед оператором ставится знак доллара `$`. Встретив такую форму, интерпретатор вычислит выражение и подставит его результат, а не код возврата.

I> Вторая форма оператора `((` со знаком `$` является частью POSIX-стандарта. Её можно использовать для написания переносимого кода. Первая же форма `((` без `$` доступна только в интерпретаторах Bash, ksh и zsh.

Внутри оператора `((` и команды `let` имена переменных можно указывать без знака доллар `$`. В этом случае интерпретатор будет выполнять корректную подстановку их значений. Например, следующие два выражения для вычисления переменной `result` будут эквивалентны:
{line-numbers: true, format: Bash}
```
a=5 b=10
result=$(($a + $b))
result=$((a + b))
```

Предпочтительнее опускать знак `$` перед именами переменных в арифметических выражениях. Это делает код более удобным для чтения.

I> У команды `let` есть устаревший синоним — оператор `$[ ]`. Не используйте его. Также для расчёта арифметических выражений есть GNU утилита `expr`. Она нужна для совместимости со скриптами, написанными на Bourne Shell. Её никогда не следует применять при разработке новых скриптов.

Таблица 3-17 демонстрирует операции, допустимые в арифметических выражениях.

{caption: "Таблица 3-17. Операции в арифметических выражениях", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| | **Вычисления** | |
|  | | |
| `*` | Умножение | `echo "$((2 * 9)) = 18"` |
| `/` | Деление | `echo "$((25 / 5)) = 5"` |
| `%` | Остаток от деления | `echo "$((8 % 3)) = 2"` |
| `+` | Сложение | `echo "$((7 + 3)) = 10"` |
| `-` | Вычитание | `echo "$((8 - 5)) = 3"` |
| `**` | Возведение в степень | `echo "$((4**3)) = 64"` |
|  | | |
| | **Битовые операции** | |
|  | | |
| `~` | Побитовое НЕ (NOT) | `echo "$((~5)) = -6"` |
| `<<` | Битовый сдвиг влево | `echo "$((5 << 1)) = 10"` |
| `>>` | Битовый сдвиг вправо | `echo "$((5 >> 1)) = 2"` |
| `&` | Побитовое И (AND) | `echo "$((5 & 4)) = 4"` |
| `|` | Побитовое ИЛИ (OR) | `echo "$((5 | 2)) = 7"` |
| `^` | Побитовое исключающее ИЛИ (XOR) | `echo "$((5 ^ 4)) = 1"` |
|  | | |
| | **Присваивания** | |
|  | | |
| `=` | Обычное присваивание | `echo "$((num = 5)) = 5"` |
| `*=` | Умножение и присваивание результата | `echo "$((num += 5)) = 10"` |
| `/=` | Деление и присваивание результата | `echo "$((num /= 2)) = 5"` |
| `%=` | Остаток от деления и присваивание результата | `echo "$((num %= 2)) = 1"` |
| `+=` | Сложение и присваивание результата | `echo "$((num += 7)) = 8"` |
| `-=` | Вычитание и присваивание результата | `echo "$((num -= 3)) = 5"` |
| `<<=` | Битовый сдвиг влево и присваивание результата | `echo "$((num <<= 1)) = 10` |
| `>>=` | Битовый сдвиг вправо и присваивание результата | `echo "$((num >>= 2)) = 2"` |
| `&=` | Побитовое И (AND), затем присваивание результата | `echo "$((num &= 3)) = 2"` |
| `^=` | Побитовое [исключающее ИЛИ](https://ru.wikipedia.org/wiki/Исключающее_«или») (XOR), затем присваивание результата | `echo "$((num^=7)) = 5"` |
| `|=` | Побитовое ИЛИ (OR), затем присваивание результата | `echo "$((num |= 7)) = 7"` |
|  | | |
| | **Сравнения** | |
|  | | |
| `<` | Меньше | `((num < 5)) && echo "переменная num меньше 5"` |
| `>` | Больше | `((num > 5)) && echo "переменная num больше 3"` |
| `<=` | Меньше или равно | `((num <= 20)) && echo "переменная num меньше или равна 20"` |
| `>=` | Больше или равно | `((num >= 15)) && echo "переменная num больше или равна 15"` |
| `==` | Равно | `((num == 3)) && echo "переменная num равна 3"` |
| `!=` | Не равно | `((num != 3)) && echo "переменная num не равна 3"` |
|  | | |
| | **Логические операции** | |
|  | | |
| `!` | Логическое НЕ (NOT) | `(( ! num )) && echo "переменная num имеет значение ЛОЖЬ"` |
| `&&` | Логическое И (AND) | `(( 3 < num && num < 5 )) && echo "переменная num больше 3, но меньше 5"` |
| `||` | Логическое ИЛИ (OR) | `(( num < 3 || 5 < num )) && echo "переменная num меньше 3 или больше 5"` |
|  | | |
| | **Другие операции** | |
|  | | |
| `num++` | Постфикс-инкремент | `echo "$((num++))"` |
| `num--` | Постфикс-декремент | `echo "$((num--))"` |
| `++num` | Префикс-инкремент | `echo "$((++num))"` |
| `--num` | Префикс-декремент | `echo "$((--num))"` |
| `+num` | Унарный плюс или умножение числа на 1 | `a=$((+num))"` |
| `-num` | Унарный минус или умножение числа на -1 | `a=$((-num))"`|
| `УСЛОВИЕ ? ДЕЙСТВИЕ1 : ДЕЙСТВИЕ2` | [Тернарная условная операция](https://ru.wikipedia.org/wiki/Тернарная_условная_операция) | `a=$(( b < c ? b : c ))` |
| `ДЕЙСТВИЕ1, ДЕЙСТВИЕ2` | Список выражений | `((a = 4 + 5, b = 16 - 7))` |
| `( ДЕЙСТВИЕ1 )` | Группирование выражений (подвыражение) | `a=$(( (4 + 5) * 2 ))`|

Порядок выполнения математических операций приведён в таблице 3-18.

{caption: "Таблица 3-18. Порядок выполнения математических операций", width: "100%"}
| Порядок выполнения | Операция | Описание |
| --- | --- | --- |
| 1 | `( ДЕЙСТВИЕ1 )` | Группирование выражений |
| 2 | `num++, num--` | Постфиксный инкремент и декремент |
| 3 | `++num, --num` | Префиксный инкремент и декремент |
| 4 | `+num, -num` | Унарный плюс и минус |
| 5 | `~, !` | Побитовое и логическое отрицание |
| 6 | `**` | Возведение в степень |
| 7 | `*, /, %` | Умножение, деление, нахождение остатка |
| 8 | `+, -` | Сложение и вычитание |
| 9 | `<<, >>` | Битовые сдвиги |
| 10 | `<, <=, >, >=` | Сравнения |
| 11 | `==, !=` | Равенство и неравенство |
| 12 | `&` | Побитовое И |
| 13 | `^` | Побитовое исключающее ИЛИ |
| 14 | `|` | Побитовое ИЛИ |
| 15 | `&&` | Логическое И |
| 16 | `||` | Логическое ИЛИ |
| 17 | `УСЛОВИЕ ? ДЕЙСТВИЕ1 : ДЕЙСТВИЕ2` | Тернарная условная операция |
| 18 | `=, *=, /=, %=, +=, -=, <<=, >>=, &=, ^=, |=` | Присваивания |
| 19 | `ДЕЙСТВИЕ1, ДЕЙСТВИЕ2` | Список выражений |

Порядок выполнения может быть изменён с помощью скобок `( )`. Они создают подвыражение (subexpression), которое интерпретатор рассчитывает в первую очередь. Если подвыражений несколько, они будут выполнены в порядке их следования.

С помощью префикса можно указать систему счисления числовой константы. Если префикс не указан, будет использоваться десятичная система. Список допустимых префиксов приведён в таблице 3-19.

{caption: "Таблица 3-19. Префиксы для систем счисления", width: "100%"}
| Префикс | Система счисления | Пример |
| --- | --- | --- |
| `0` | Восьмеричная | `echo "$((071)) = 57"` |
| `0x` | Шестнадцатеричная | `echo "$((0xFF)) = 255"` |
| `0X` | Шестнадцатеричная | `echo "$((0XFF)) = 255"` |
| `<основание>#` | Система с указанным основанием от 2 до 64 | `echo "$((16#FF)) = 255"` |
| | | `echo "$((2#101)) = 5"` |

При выводе значений переменных и констант в файл или на экран интерпретатор будет переводить их в десятичную систему. Менять формат вывода можно с помощью встроенной команды `printf`. Например, следующая команда выведет число на экран в шестнадцатеричной системе:
{line-numbers: false, format: Bash}
```
printf "%x\n" 250
```

Аналогично можно вывести и значение переменной:
{line-numbers: false, format: Bash}
```
printf "%x\n" $var
```

### Арифметические действия

Начнём с самых простых математических операций — арифметических. В языках программирования они обозначаются привычными символами:

* `+` сложение
* `-` вычитание
* `/` деление
* `*` умножение

В программировании помимо перечисленных часто используются ещё два действия: возведение в степень и вычисление [остатка от деления](https://ru.wikipedia.org/wiki/Деление_с_остатком).

Возведение в степень принято записывать в виде a^b^, где `a` является основанием, а `b` — показателем. Например, два в степени семь записывается как 2^7^. В Bash это арифметическое действие обозначается двумя символа звёздочки `*`:
{line-numbers: false}
```
2**7
```

Вычисление остатка от деления — более сложная операция. В чём она заключается и для чего применяется?

Если в результате деления одного целого числа на другое получается дробное, возникает остаток. Например, разделим 10 (делимое) на 3 (делитель). В результате с округлением получится 3,33333 (частное). В этом случае остаток от деления будет равен 1. Чтобы его вычислить, необходимо делитель 3 умножить на целую часть частного (или неполное частное) 3. Затем получившиеся число 9 вычтем из делимого 10 и получим 1.

Обозначим делимое буквой `a`, делитель — `b`, неполное частное — `q`, а остаток как `r`. Тогда формулу нахождения делимого `a` можно записать так:
{line-numbers: false}
```
a = b * q + r
```

Отсюда можно вывести формулу для нахождения остатка:
{line-numbers: false}
```
r = a - b * q
```

Выбор неполного частного `q` вызывает вопросы. Может показаться, что в качестве него можно использовать любое число. Но для выбора частного есть важное ограничение. Оно должно быть таким, чтобы остаток от деления `r` по абсолютной величине оказался меньше делителя `b`. Другими словами должно выполняться неравенство `|r| < |b|`.

Вычисление остатка в Bash обозначается знаком `%`. В некоторых языках этим же символом обозначается операция [**modulo**](https://en.wikipedia.org/wiki/Modulo_operation). В общем случае это [два разных действия](https://habr.com/ru/post/421071). Но они дают одинаковый результат, когда знаки делимого и делителя совпадают.

Например вычислим остаток и modulo для следующих случаев:
{line-numbers: false}
```
19 % 12 = 19 - 12 * 1 = 7
19 modulo 12 = 19 - 12 * 1 = 7

-19 % -12 = -19 - (-12) * 1 = -7
-19 modulo -12 = -19 - (-12) * 1 = -7
```

Если знаки делимого и делителя различаются, остаток и modulo — разные:
{line-numbers: false}
```
19 % -12 = 19 - (-12) * (-1) = 7
19 modulo -12 = 19 - (-12) * (-2) = -5

-19 % 12 = -19 - 12 * (-1) = -7
-19 modulo 12 = -19 - 12 * (-2) = 5
```

Обратите внимание, что для расчёта modulo используется та же формула, что и для остатка, но выбирается другое неполное частное `q`. Для нахождения остатка, оно вычисляется по следующей формуле:
{line-numbers: false}
```
a / b = q
```

Результат следует округлить к меньшему по модулю. То есть отбросить все знаки после запятой. Неполное частное для modulo считается так же, но только когда `a` и `b` имеют одинаковые знаки. Если знаки разные, формула выглядит так:
{line-numbers: false}
```
a / b = q - 1
```

Результат также надо округлить к меньшему по модулю.

Обычно когда говорят об остатке `r`, подразумевают, что делимое `a` и делитель `b` положительны. Поэтому в справочниках часто можно встретить следующее условие: `0 ≤ r < |b|`. Но в случае деления чисел с разными знаками остаток может быть отрицательным. Запомните простое правило: у остатка всегда такой же знак, что и у делимого. Если знаки различаются, значит вы нашли modulo.

Всегда помните о различии остатка от деления и modulo при программировании на любом языке. Если вы сомневаетесь в своих вычисления, вы можете их проверить. Предположим, что вам нужно найти остаток деления 32 на -7. Для этого выполните следующую команду в Bash:
{line-numbers: false, format: Bash}
```
echo $((32 % -7))
```

Результат будет равен четырём.

Чтобы найти modulo для этой же пары чисел, наберите в поисковике Google следующую строку:
{line-numbers: false, format: Bash}
```
32 % -7
```

В результате на странице браузера будет выведен калькулятор с ответом -3.

Для чего используется вычисление остатка от деления? Одна из самых распространённых задач — проверка числа на чётность. Она возникает в коммуникациях, чтобы проверить корректность принятых данных. Этот подход известен как [**бит контроля чётности**](https://ru.wikipedia.org/wiki/Бит_чётности).

Чтобы проверить число на чётность, достаточно вычислить остаток его деления на 2. Если остаток равен нулю, значит число чётное. В противном случае — нечётное.

Другая распространённая задача в которой не обойтись без вычисления остатка — это преобразование единиц времени. Рассмотрим пример. Предположим, что нам надо перевести 128 секунд в минуты. Для этого нам надо подсчитать целое число минут и приписать к нему остаток. Чтобы найти минуты, разделим 128 на 60. Получим неполный остаток 2. Для нахождения оставшихся минут вычислим остаток от деления 128 на 60 — получим 8. Следовательно, 128 секунд равны двум минутам и восьми секундам.

При работе с циклами может быть полезно выполнять какое-то действие на каждой N-ой операции (например на каждой десятой). В этом случае можно проверять остаток от деления счётчика цикла на N (на 10 в нашем примере). Если остаток равен нулю, значит текущая итерация кратна N и действие должно быть выполнено.

Операция modulo активно используется в [криптографии](https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities)).

{caption: "Упражнение 3-8. Вычисление остатка от деления и modulo", format: text, line-numbers: false}
```
Вычислите остаток от деления и modulo:

* 1697 % 13
* 1697 modulo 13

* 772 % -45
* 772 modulo -45

* -568 % 12
* -568 modulo 12

* -5437 % -17
* -5437 modulo -17
```

### Битовые операции

Ещё один тип математических действий, который активно используется в программировании, — это [**битовые операции**](https://ru.wikipedia.org/wiki/Битовая_операция). Своё название они получили потому, что совершаются над каждым битом числа по отдельности. Другими словами, чтобы выполнить такую операцию, вам необходимо сначала представить число в двоичном виде, а затем выполнить действие над каждым его разрядом.

#### Побитовое отрицание

Начнём с самой простой битовой операции — отрицания. В компьютерной литературе она иногда обозначается как НЕ или NOT, а в Bash — знаком тильда `~`.

Чтобы выполнить побитовое отрицание, необходимо заменить каждый разряд в двоичном представлении числа на противоположный. То есть каждая единица заменяется на ноль и наоборот. Например, выполним побитовое отрицание числа 5:
{line-numbers: false}
```
5 = 101
~5 = 010
```

Это действие достаточно простое, если мы ограничимся только математикой. В программировании с ним возникает несколько сложностей. Прежде всего сразу возникает вопрос: сколько байтов отводится под число? Предположим, что число 5 в нашем примере хранится в двухбайтовой переменной. Тогда в памяти в двоичном виде оно будет выглядеть так:
{line-numbers: false}
```
00000000 00000101
```

После побитового отрицания содержимое переменной станет таким:
{line-numbers: false}
```
11111111 11111010
```

Теперь возникает другой вопрос: как интерпретировать полученный результат? Если переменная была объявлена как беззнаковое целое, нашим результатом будет число 65530 в прямом коде. Если же переменная знаковая, её значение необходимо представить в дополнительном коде. В этом случае мы получим -6.

Разные команды и операторы Bash представляют целые по-разному. Например, `echo` всегда выводит числа как знаковые. В команде `printf` есть возможность указать формат выводимых целых: знаковые или беззнаковые. 

Поскольку Bash явно не имеет типов, все скалярные переменные хранятся в виде строк. Следовательно, интерпретация целых происходит в момент их подстановки в арифметические выражения. В зависимости от контекста они могут быть подставлены как знаковые и как беззнаковые.

Независимо от наличия знака под целые в Bash отводится 64 бита. Это значит, что максимальное положительное знаковое число в Bash равно 7FFFFFFFFFFFFFFF в HEX или 9223372036854775807 в DEC. Минимальное отрицательное число равно 8000000000000000 в HEX или -9223372036854775808 в DEC. Максимальное беззнаковое целое равно FFFFFFFFFFFFFFFF в HEX или 18446744073709551615 в DEC.

Следующие команды демонстрируют различные интерпретации целых в Bash:
{line-numbers: true, format: Bash}
```
$ echo $((16#FFFFFFFFFFFFFFFF))
-1

$ printf "%llu\n" $((16#FFFFFFFFFFFFFFFF))
18446744073709551615

if ((18446744073709551615 == 16#FFFFFFFFFFFFFFFF)); then echo "ok"; fi
ok

if ((-1 == 16#FFFFFFFFFFFFFFFF)); then echo "ok"; fi
ok

$ if ((18446744073709551615 == -1)); then echo "ok"; fi
ok
```

Последний пример с конструкцией `if` показывает, что знаковые и беззнаковые целые хранятся в памяти одинаковым способом. Однако, они интерпретируются по-разному в зависимости от контекста.

Вернёмся к нашему примеру с побитовым отрицанием числа 5. Результат будет зависеть от способа его вывода:
{line-numbers: true, format: Bash}
```
$ echo $((~5))
-6

$ printf "%llu\n" $((~5))
18446744073709551610
```

Оба результата равны 0xFFFFFFFFFFFFFFFA в шестнадцатеричной системе и являются правильными с точки зрения операции побитового отрицания.

{caption: "Упражнение 3-9. Вычисление побитового отрицания", format: text, line-numbers: false}
```
Выполните побитовое отрицание следующих беззнаковых двухбайтовых целых:

* 56
* 1018
* 58362

Повторите вычисления для случая, когда эти целые являются знаковыми.
```

#### Побитовое И, ИЛИ, исключающее ИЛИ

Операция побитового И, также известная как AND, выполняется над двумя числами. Она очень похожа на логическое И. В нём, как вы помните, результат выражения истеннен только в том случае, когда оба операнда истинны. Для всех остальных значений операндов результатом будет ложь. В побитовом И надо выполнить операцию логического И над каждой парой разрядов её операндов.

Чтобы выполнить побитовое И, необходимо выполнить следующие действия:

1. Представить оба операнда операции в двоичном виде.

2. Если число разрядов в одном операнде меньше чем в другом, дополнить его слева нулями.

3. Применить логическое И к каждой паре битов, которые стоят на одинаковых позициях в двоичном представлении операндов.

Рассмотрим пример. Вычислим побитовое И для чисел 5 и 3. В двоичном виде эти числа представляются следующим образом:
{line-numbers: false}
```
5 = 101
3 = 11
```

У числа 3 оказалось меньше разрядов чем у 5. Поэтому дополним двоичное представление 3 одним нулём слева:
{line-numbers: false}
```
3 = 011
```

Теперь выполним операцию логического И для каждой пары битов чисел 5 и 3. Для удобства запишем двоичное представление чисел в столбик. Получим следующее:
{line-numbers: false}
```
101
011
---
001
```

Переведём результат в десятичную систему:
{line-numbers: false}
```
001 = 1
```

В Bash операция побитового И обозначается знаком амперсанд `&`. С её помощью результат рассчитанного нами выражения можно вывести следующим образом:
{line-numbers: false, format: Bash}
```
echo $((5 & 3))
```

Операция побитового ИЛИ (OR) выполняется аналогично побитовому И. Только вместо логического И над каждой парой битов операндов надо выполнить логическое ИЛИ.

Рассмотрим пример выполнения побитового ИЛИ для чисел 10 и 6. В двоичном виде они представляются следующим образом:
{line-numbers: false}
```
10 = 1010
6 = 110
```

Число 6 надо дополнть нулём до четырёх разрядов:
{line-numbers: false}
```
6 = 0110
```

Теперь выполним логическое ИЛИ над каждой парой битов чисел 10 и 6:
{line-numbers: false}
```
1010
0110
----
1110
```

Переведём результат в десятичную систему:
{line-numbers: false}
```
1110 = 14
```

В Bash побитовое ИЛИ обозначается знаком `|`. Вывести результат расчёта нашего примера можно следующей командой:
{line-numbers: false, format: Bash}
```
echo $((10 | 6))
```

Операция побитового исключающего ИЛИ (XOR) похожа на побитовое ИЛИ. В ней над каждой парой битов операндов выполняется логическое исключающее ИЛИ. В исключающем ИЛИ в отличие от обычного если оба разряда равны единице, результат будет ноль. В остальных случаях результат будет такой же как и у обычного ИЛИ.

Рассмотрим пример исключающего ИЛИ для чисел 12 и 5. Переведём числа в двоичный вид:
{line-numbers: false}
```
12 = 1100
5 = 101
```

Дополним число 5 до четырёх разрядов:
{line-numbers: false}
```
5 = 0101
```

Выполним побитовое исключающее ИЛИ для каждой пары разрядов:
{line-numbers: false}
```
1100
0101
----
1001
```

Переведём результат в десятичную систему:
{line-numbers: false}
```
1001 = 9
```

В Bash эта операция обозначается символом `^`. Расчёт нашего примера будет выглядеть так:
{line-numbers: false, format: Bash}
```
echo $((12 ^ 5))
```

{caption: "Упражнение 3-10. Вычисление побитовых И, ИЛИ, исключающего ИЛИ", format: text, line-numbers: false}
```
Выполните побитовое И, ИЛИ, исключающее ИЛИ для следующих беззнаковых двухбайтовых целых:

* 1122 и 908
* 49608 и 33036
```

#### Битовые сдвиги

Битовым сдвигом называется изменение позиций битов в двоичном представлении числа. Всего есть три типа сдвигов:

1. Логический
2. Арифметический
3. Циклический

Самый простой из них — это логический. Рассмотрим сначала его.

Операция битового сдвига принимает два операнда. Первый из них — это число, над которым выполняется операция. Второй операнд — количество битов, на которое происходит сдвиг.

Для выполнения логического сдвига исходное число необходимо представить в двоичном виде. Если сдвиг происходит вправо на N битов, то крайние справа N битов числа отбрасываются. Вместо них слева записываются нули. Аналогично происходит сдвиг влево: отбрасывание N битов слева и запись вместо них нулей справа.

Рассмотрим пример. Выполним логический сдвиг беззнакового однобайтового целого 58 вправо на три бита. Сначала представим число в двоичном виде:
{line-numbers: false}
```
58 = 0011 1010
```

Операция сдвига влево обозначается как `<<`, а в право как `>>`. Выполним логический сдвиг числа 58 вправо на три бита:
{line-numbers: false}
```
0011 1010 >> 3 = 0011 1 = 0000 0111 = 7
```

Мы выполнили операцию в два этапа. Сначала отбросили три крайних справа бита числа и получили `0011 1`. Затем добавили три нуля слева, что дало конечный результат `0000 0111`.

Теперь выполним сдвиг этого же числа на три бита влево. Получим следующее:
{line-numbers: false}
```
0011 1010 << 3 = 1 1010 = 1101 0000 = 208
```

Алгоритм аналогичен сдвигу вправо. Сначала отбрасываем крайние слева биты, а затем дописываем справа нули.

Арифметический сдвиг влево выполняется точно так же как и логический.  

Арифметический сдвиг вправо отличается от логического. Чтобы его выполнить, надо отбросить соответствующее количество битов справа. После этого результат дополняется слева битами, имеющими то же значение, которое имеет старший бит. Если старший бит равен единице, дополняем результат единицами, а если нулю — нулями. Таким образом после операции знак числа не меняется.

Для примера рассмотрим арифметический сдвиг знакового однобайтового целого -105 вправо на два бита.

Сначала представим число в дополнительном коде:
{line-numbers: false}
```
-105 = 1001 0111
```

Теперь выполним арифметический сдвиг вправо на два бита:
{line-numbers: false}
```
1001 0111 >> 2 -> 1001 01 -> 1110 0101
```

Обратите внимание, что в нашем случае старший бит равен единице. Поэтому мы дополняем результат слева двумя единицами.

Мы получили отрицательное число в дополнительном коде. Переведём его в прямой:
{line-numbers: false}
```
1110 0101 = 1001 1011 = -27
```

Операции интерпретатора Bash выполняют арифметические сдвиги. Рассмотренные нами примеры можно вычислить с помощью следующих команд:
{line-numbers: true, format: Bash}
```
$ echo $((58 >> 3))
7
$ echo $((58 << 3))
464
$ echo $((-105 >> 2))
-27
```

Результат сдвига 58 влево на три бита отличается от нашего, потому что Bash оперирует восьмибайтовыми целыми.

Циклический сдвиг редко применяется в программировании. Поэтому большинство языков не имеет соответствующего ему встроенного оператора.

В циклическом сдвиге отброшенные биты появляются на освободившемся месте с другого конца числа.

Например, выполним циклический сдвиг числа 58 вправо на три бита. Результат будет следующим:
{line-numbers: false}
```
0011 1010 >> 3 = 010 0011 1 = 0100 0111 = 71
```

Обратите внимание, что отброшенные справа биты `010` оказались в левой части числа.

{caption: "Упражнение 3-11. Вычисление битовых сдвигов", format: text, line-numbers: false}
```
Выполните следующие арифметические битовые сдвиги знаковых двухбайтовых целых:

* 25649 >> 3
* 25649 << 2
* -9154 >> 4
* -9154 << 3
```

#### Применение битовых операций

Битовые операции, как и знания о представлении чисел в памяти, находят широкое применение в системном программировании. Каждый раз когда вы получаете некоторые данные по сети или какому-либо интерфейсу, вы можете привести их в нужный формат с помощью битовых операций.

Рассмотрим пример. Предположим, что вы получили двухбайтовое число 0xAABB от устройства с порядком байтов от старшего к младшему (big-endian). Однако, ваш компьютер использует порядок от младшего к старшему (little-endian). Необходимо поменять порядок байтов в числе, чтобы перевести его в формат вашего компьютера. Тогда мы получим 0xBBAA вместо 0xAABB. Как это выполнить?

Для конвертирования достаточно три действия:

1. Прочитать младший байт числа и сдвинуть его влево на восемь битов (т.е. на один байт):
{line-numbers: false, format: Bash}
```
little=$(((0xAABB & 0x00FF) << 8))
```

2. Прочитать старший байт числа и сдвинуть его вправо на восемь битов:
{line-numbers: false, format: Bash}
```
big=$(((0xAABB & 0xFF00) >> 8))
```

3. Соединить старший и младший байты с помощью побитового ИЛИ:
{line-numbers: false, format: Bash}
```
result=$((little | big))
```

В результате этих операций в переменную `result` будет записано число 0xBBAA. Это же значение можно рассчитать и одной командой:
{line-numbers: false, format: Bash}
```
value=0xAABB
result=$(( ((value & 0x00FF) << 8) | ((value & 0xFF00) >> 8) ))
```

Битовые операции помогают для расчёта масок. Мы уже рассматривали маски с правами доступа к файлам в Unix-окружении. Предположим, что некоторый файл имеет права `-rw-r--r--`. То есть в двоичном виде маску можно представить как двоичное число `0000 0110 0100 0100`. Чтобы проверить, имеет ли владелец файла право на его исполнение, достаточно выполнить побитовое И с маской `0000 0001 0000 0000`. В результате получим:
{line-numbers: false}
```
0000 0110 0100 0100 & 0000 0001 0000 0000 = 0000 0000 0000 0000 = 0
```

Результат равен нулю. Это значит, что ответ на наш вопрос отрицательный: владелец не имеет права исполнять файл.

Для добавления битов в маску можно применить операцию побитового ИЛИ. Добавим право на исполнение владельцем файлу из нашего примера следующим образом:
{line-numbers: false}
```
0000 0110 0100 0100 | 0000 0001 0000 0000 = 0000 0111 0100 0100 = -rwxr--r--
```

Число, с которым мы выполнили операцию ИЛИ, имеет равный единице бит в том же месте, в котором его следует установить в маске доступа к файлу. Таким образом независимо от значения этого бита в маске, он будет установлен в единицу. Все остальные биты числа установлены в ноль. Благодаря этому, биты в тех же позиция маски останутся без изменений.

Чтобы удалить биты, воспользуемся побитовым И. Например, удалим право владельца файла на запись:
{line-numbers: false}
```
0000 0111 0100 0100 & 1111 1101 1111 1111 = 0000 0101 0100 0100 = -r-xr--r--
```

В этом случае мы выполнили операцию И с числом, в котором все биты установлены в единицу кроме бита, который необходимо занулить в маске доступа к файлу. Таким образом этот бита станет равен нулю независимо от его исходного значения. Все остальные разряды маски не будут изменены.

Подобные операции с масками выполняются операционной системой каждый раз, когда вы пытаетесь получить доступ к файлу или меняете его права.

В недавнем прошлом битовые сдвиги широко применялись как [альтернатива умножения и деления на степень двойки](https://habr.com/ru/company/pvs-studio/blog/141880). Например, сдвиг влево на два бита соответствует умножению на 2^2^ (т.е. четыре):
{line-numbers: true, format: Bash}
```
$ echo $((3 << 2))
12
```

Сдвиг вправо на три бита соответствует делению на 2^3^ (т.е. восемь):
{line-numbers: true, format: Bash}
```
$ echo $((16 >> 3))
2
```

Подобные трюки позволяли сократить число тактов процессора на операции умножения и деления в несколько раз. Сейчас эти оптимизации стали неактуальны из-за развития компиляторов и процессоров. Первые автоматически выбирают наиболее дешевые ассемблерные инструкции при генерации кода. Вторые позволяют выполнять эти инструкции параллельно. Поэтому сегодня программисты склонны писать более удобный для чтения и понимания код, а не более оптимальный. Операции умножения и деления с этой точки зрения выигрывают.

Битовые операции также активно применяются в криптографии и компьютерной графике.

### Логические операции

Как мы уже отметили, оператор `[[` неудобен для сравнения целых чисел в конструкции `if`. В этом операторе отношения между операндами обозначаются двухбуквенными сокращениями (например, `-gt` для больше). Вместо того чтобы запоминать эти сокращения, можно использовать оператор `((` в форме арифметической оценки. В нём допустимы привычные символы сравнения чисел: `>`, `<`, `=` и т.д.

Рассмотрим пример. Предположим, что вам надо сравнить значение переменной с константой 5. В этом случае можно использовать следующую конструкцию `if`:
{line-numbers: true, format: Bash}
```
if ((var < 5)) 
then
  echo "Значение var меньше 5"
fi
```

Можно заменить оператор `((` на команду `let`. В результате мы получим то же самое поведение:
{line-numbers: true, format: Bash}
```
if let "var < 5"
then
  echo "Значение var меньше 5"
fi
```

Однако вместо `let` предпочтительнее всегда использовать оператор `((`.

Обратите внимание на важное отличие арифметической оценки и подстановки. Согласно POSIX-стандарту, при успешном выполнении любая программа или команда должна возвращать ноль. В случае ошибки возвращается код возврата от 1 до 255. Этот код можно интерпретировать следующим образом: ноль означает истину, а не ноль — ложь. В этом смысле результат арифметической подстановки инвертирован, а оценки нет.

Дело в том, что арифметическая оценка — это синоним команды `let`, а значит она подчиняется требованиям POSIX-стандарта, как и любая другая команда. Арифметическая подстановка выполняется в контексте другой команды. Поэтому результат её работы зависит от реализации конкретного интерпретатора. В случае Bash если условие в операторе `((` в форме подстановки истинно, будет возвращена единица. В противном случае оператор возвращает ноль. Такое поведение соответствует правилам вывода логических выражений языка C.

Рассмотрим пример. Предположим, что вы пишете однострочную команду для вывода на консоль результата сравнения переменной с числом. Она будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
((var < 5)) && echo "Значение var меньше 5"
```

Здесь мы использовали арифметическую оценку. Поэтому если значение переменной меньше 5, оператор `((`, как синоним команды `let`, выполнится успешно и, согласно стандарту POSIX вернёт, значение ноль.

Если же вы воспользуетесь оператором `((` в форме арифметической подстановки, результат будет отличаться. Например:
{line-numbers: false, format: Bash}
```
echo "$((var < 5))"
```

Если условие истинно, вы увидите на экране число 1, согласно правилам вывода языка C.

Логические операции, как правило, используются в форме арифметической оценки оператора `((`. Они полностью соответствуют уже рассмотренным нами логическим операторам Bash.

Рассмотрим следующий пример использования логических операций для сравнения значения переменной с константами:
{line-numbers: true, format: Bash}
```
if ((1 < var && var < 5))
then
  echo "Значение var меньше 5, но больше 1"
fi
```

В этом случае условие будет истинно только тогда, когда оба неравенства будут выполнены. Аналогично применяется логическое ИЛИ:
{line-numbers: true, format: Bash}
```
if ((var < 1 || 5 < var))
then
  echo "Значение var меньше 1 или больше 5"
fi
```

Выражение будет истинно, когда хотя бы одно из неравенств выполнится.

Логическое НЕ редко применяется к самим числам. Чаще оно используется для отрицания подвыражения в составе другого выражения. Если применить НЕ к числам, правила вывода будут соответствовать POSIX-стандарту: ноль истинна, не ноль — ложь. Например:
{line-numbers: true, format: Bash}
```
if ((! var))
then
  echo "Значение var равно истина или ноль"
fi
```

В этом случае условие выполнится только тогда, когда переменная будет равна нулю.

### Инкремент и декремент

Операции инкремента и декремента впервые появились в [языке программирования B](https://ru.wikipedia.org/wiki/Би_(язык_программирования)), разработанном в 1969 году Кеном Томпсоном и Денисом Ритчи в Bell Labs. Позднее Денис Ритчи перенёс эти операции в свой язык C. После чего их скопировал и разработчик Bash.

Чтобы нам было легче разобраться в работе инкремента и декремента, познакомимся сначала с операциями присваивания. Обычное присваивание в арифметической оценке выглядит так:
{line-numbers: false, format: Bash}
```
((var = 5))
```

В результате переменной `var` будет присвоено значение 5.

Bash позволяет совместить присваивание с одним арифметическим действием или битовой операцией. Например, совмещение сложения и присваивания выглядит следующим образом:
{line-numbers: false, format: Bash}
```
((var += 5))
```

В этой операции происходит последовательно два действия:

1. К текущему значению переменной `var` прибавляется число 5.

2. Результат сложение записывается в переменную `var`.

Аналогично работают все другие операции присваивания: сначала выполняется действие, затем результат записывается в переменную. Такой синтаксис позволяет писать более компактный и удобный для чтения код.

Теперь рассмотрим операции инкремента и декремент. У них есть две формы: постфиксная и префиксная. Они записываются по-разному. В постфиксной форме знаки `++` или `--` идут после имени переменной, а в префиксной — до.

Рассмотрим префиксный инкремент:
{line-numbers: false, format: Bash}
```
((++var))
```

Это выражение даст такой же результат, как и следующая операция присваивания:
{line-numbers: false, format: Bash}
```
((var+=1))
```

Другими словами инкремент — это увеличение значения переменной на единицу. Аналогично ему декремент — это уменьшение на единицу.

Может быть непонятно, зачем нужно было вводить отдельную операцию для прибавления и вычитания единицы. Ведь уже есть достаточно компактные операции сложения и вычитания, совмещённые с присваиванием. Наиболее вероятная причина такого решения заключается в том, что в программировании очень часто используется [**счётчик цикла**](https://ru.wikipedia.org/wiki/Счётчик_цикла). Он позволяет отсчитывать номер итерации цикла и таким образом вовремя прерывать его выполнение. Благодаря инкременту и декременту со счётчиками становится очень удобно работать. Кроме того современные процессоры могут выполнять эти операции на аппаратном уровне. За счёт этого их выполнение происходит быстрее чем аналогичное сложение или вычитание с присваиванием.

В чём отличие префиксного и постфиксного инкремента? Если выражение состоит только из операции инкремента, то результат префиксной и постфиксной формы будет одинаковым. Например, следующие две команды увеличат значение переменной на единицу:
{line-numbers: true, format: Bash}
```
((++var))
((var++))
```

Разница между формами инкремента проявляется, когда результат операции присваивается какой-то переменной. Рассмотрим следующий пример:
{line-numbers: true, format: Bash}
```
var=1
((result = ++var))
```

После выполнения этих команд значения обеих переменных `result` и `var` будут равны двум. Таким образом префиксный инкремент сначала выполняет сложение, а затем возвращает результат, который можно дальше использовать в выражении. В нашем случае результат просто присваивается переменной `result`.

Если расписать наш пример с префиксным инкрементом по отдельным командам, получится следующий код:
{line-numbers: true, format: Bash}
```
var=1
((var = var + 1))
((result = var))
```

Поведение постфиксного инкремента отличается. Повторим наш пример, но заменим форму инкремента. Получим следующее:
{line-numbers: true, format: Bash}
```
var=1
((result = var++))
```

После выполнения этих команд в переменную `result` будет записана единица, а `var` будет равна двум.

Постфиксный инкремент сначала возвращает результат, а затем увеличивает значение переменной. Его можно заменить следующими командами:
{line-numbers: true, format: Bash}
```
var=1
((tmp = var))
((var = var + 1))
((result = tmp))
```

Обратите внимание на порядок выполнения постфиксного инкремента. Сначала происходит увеличение переменной `var` на единицу, и только после этого её прошлое значение возвращается в качестве результата. Именно поэтому прошлое значение приходится временно сохранять. В нашем случае для этого используется вспомогательная переменная `tmp`.

Постфиксная и префиксная формы декремента работают аналогично соответствующим формам инкремента.

Всегда предпочитайте использовать префиксную форму инкремента и декремента вместо постфиксной. Во-первых, она быстрее выполняется процессором, поскольку не требуется сохранять текущее значение переменной. Во-вторых, используя постфиксную форму, проще совершить ошибку из-за неочевидного порядка выполнения присваивания.

### Тернарная условная операция

Тернарная условная операция (также известная как тернарный оператор) изначально появилась в языке [Алгол](https://ru.wikipedia.org/wiki/Алгол). Она оказалась очень удобной и востребованной программистами. Поэтому её добавили в языки следующего поколения: [BCPL](https://ru.wikipedia.org/wiki/BCPL) и C. Большинство современных языков (C++, C#, Java, Python, PHP и т.д.) также имеет этот оператор.

Тернарный оператор представляет собой компактную форму конструкции `if`. Рассмотрим следующий пример:
{line-numbers: true, format: Bash}
```
if ((var < 10))
then
    ((result = 0))
else
    ((result = var))
fi
```

Здесь переменной `result` присваивается ноль, если переменная `var` меньше 10. В противном случае `result` будет присвоено значение `var`.

Этот же самый код можно переписать с помощью тернарного оператора следующим образом:
{line-numbers: false, format: Bash}
```
((result = var < 10 ? 0 : var))
```

Шесть строк конструкции `if` мы заменили на одну.

Тернарный оператор состоит из условного выражения и двух действий. В общем случае его можно записать так:
{line-numbers: false}
```
(( УСЛОВИЕ ? ДЕЙСТВИЕ 1 : ДЕЙСТВИЕ 2 ))
```

Если УСЛОВИЕ истинно, выполняется ДЕЙСТВИЕ 1, иначе — ДЕЙСТВИЕ 2. Такое поведение полностью совпадает с условным оператором `if`:
{line-numbers: true}
```
if УСЛОВИЕ
then
    ДЕЙСТВИЕ 1
else
    ДЕЙСТВИЕ 2
fi
```

К сожалению, тернарный оператор в Bash может применяться только в арифметической оценке и подстановке. Это означает, что в качестве условия и действий вы можете указывать только арифметические выражения. Вызов команд Bash или внешних утилит невозможен. Это ограничение отсутствует в других языках программирования.

Использование тернарного оператора считается хорошей практикой. Он позволяет писать более компактный и удобный для чтения код. Также считается, что в меньшем объёме кода меньше потенциальных мест, где можно совершить ошибку.
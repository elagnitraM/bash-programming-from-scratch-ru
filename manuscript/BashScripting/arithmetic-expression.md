## Арифметические выражения

Интерпретатор Bash позволяет выполнять математические операции над целыми числами. К ним относятся не только хорошо известные арифметические действия (сложение, вычитание, умножение и деление), но также битовые и логические операции. Эти операции применяются практически во всех современных языках программирования. Поэтому рассмотрим их подробнее.

### Представление целых чисел

Прежде чем мы познакомимся с математическими операциями, будет полезно рассмотреть способы представления целых чисел в памяти компьютера.

Целые числа могут быть положительными и отрицательными. Соответствующий им тип данных называется [**целое**](https://ru.wikipedia.org/wiki/Целое_(тип_данных)) или [**integer**](https://en.wikipedia.org/wiki/Integer_(computer_science)).

Если переменная целого типа может принимать только положительные значения, она называется **беззнаковой** (unsigned). Если допустимы как положительные, так и отрицательные значения — это переменная **со знаком** (signed).

Наиболее известны и распространены следующие три способа представления целых в памяти компьютера:

* [**Прямой код**](https://ru.wikipedia.org/wiki/Прямой_код) (signed magnitude representation или SMR).
* [**Обратный код**](https://ru.wikipedia.org/wiki/Обратный_код) (ones' complement).
* [**Дополнительный код**](https://ru.wikipedia.org/wiki/Дополнительный_код) (two’s complement).

#### Прямой код

Прямой код может использоваться в двух вариантах:

* Для записи только положительных целых (беззнаковых).
* Для записи как положительных, так и отрицательных целых (со знаком).

В первом варианте все разряды двоичного числа используются для хранения его значения. Примеры хранения беззнаковых целых в прямом коде приведены в таблице 3-12.

{caption: "Таблица 3-12. Представление беззнаковых целых в прямом коде", width: "70%"}
| Десятичное число | Шестнадцатеричный формат | Прямой код |
| --- | --- | --- |
| 0 | 0 | 0000 0000 |
| 5 | 5 | 0000 0101 |
| 60 | 3C | 0011 1100 |
| 110 | 6E | 0110 1110 |
| 255 | FF | 1111 1111 |

В одном байте с помощью представления в прямом коде можно сохранить целые беззнаковые от 0 до 255.

Прямой код можно использовать и для хранения целых со знаком. В этом случае старший бит резервируется для знака числа. Другими словами на значение числа отводится только семь битов из восьми доступных, если для переменной зарезервирован один байт. Таблица 3-13 демонстрирует представление целых со знаком в прямом коде.

{caption: "Таблица 3-13. Представление целых со знаком в прямом коде", width: "70%"}
| Десятичное число | Шестнадцатеричный формат | Прямой код |
| --- | --- | --- |
| -127 | FF | 1111 1111 |
| -110 | EE | 1110 1110 |
| -60 | BC | 1011 1100 |
| -5 | 85 | 1000 0101 |
| -0 | 80 | 1000 0000 |
| 0 | 0 | 0000 0000 |
| 5 | 5 | 0000 0101 |
| 60 | 3C | 0011 1100 |
| 110 | 6E | 0110 1110 |
| 127 | 7F | 0111 1111 |

Обратите внимание, что старший бит всех отрицательных чисел равен единице, а положительных — нулю.

Из-за использования старшего бита для знака, мы больше не можем сохранить числа больше 127 в одном байте. По этой же причине минимальное отрицательное число равно -127.

Прямой код не получил широкого распространения в компьютерной технике по двум причинам:

1. Арифметические операции над отрицательными числами требуют усложнения архитектуры процессора. Модуль для суммирования положительных чисел для этих целей не подходит.

2. Существует два представления нуля: положительное (0000 0000) и отрицательное (1000 0000). Это осложняет арифметические сравнения, поскольку эти значения не равны.

Понимание принципа работы прямого кода пригодится нам при рассмотрении оставшихся двух способов представления целых.

#### Обратный код

Обратный код решает первую проблему прямого кода, связанную с действиями над отрицательными числами. Разберёмся, почему вообще возникла эта сложность.

Предположим, что нам надо сложить 10 и -5. Для начала представим эти числа в прямом коде. Предположим, что на каждому из них отводится один байт в памяти компьютера. Тогда получим следующий результат:
{line-numbers: false}
```
10 = 0000 1010
-5 = 1000 0101
```

Теперь возникает вопрос — как процессору следует складывать эти два числа? У любого современного процессора есть стандартный модуль под названием [**сумматор**](https://ru.wikipedia.org/wiki/Сумматор). Он позволяет побитово складывать числа. Если мы применим его для нашей задачи, то получим следующее:
{line-numbers: false}
```
10 + (-5) = 0000 1010 + 1000 0101 = 1000 1111 = -15
```

Мы получили неправильный результат. Это означает, что сумматор не подходит для арифметических операций над целыми в прямом коде. Вместо него нужен другой модуль процессора, который бы выполнял операцию в зависимости от старшего бита числа.

Вместо того чтобы усложнять процессор, можно изменить способ представления отрицательных целых.

В обратном коде положительные целые представляются точно также, как в прямом коде. Старший бит отводится под знак и равен нулю, а остальные используются для значения числа. Если число отрицательное, старший бит равен единице, а оставшиеся разряды инвертируются. Это означает, что нули становятся единицами и наоборот.

Таблица 3-14 демонстрирует представление некоторых чисел в обратном коде.

{caption: "Таблица 3-14. Представление целых со знаком в обратном коде", width: "70%"}
| Десятичное число | Шестнадцатеричный формат | Обратный код |
| --- | --- | --- |
| -127 | 80 | 1000 0000 |
| -110 | 91 | 1001 0001 |
| -60 | C3 | 1100 0011 |
| -5 | FA | 1111 1010 |
| -0 | FF | 1111 1111 |
| 0 | 0 | 0000 0000 |
| 5 | 5 | 0000 0101 |
| 60 | 3C | 0011 1100 |
| 110 | 6E | 0110 1110 |
| 127 | 7F | 0111 1111 |

В одном байте можно сохранить числа от -127 до 127, как и в прямом коде. Главное отличие заключается в представлении отрицательных чисел.

Что нам дало инвертирование разрядов отрицательных чисел? Попробуем опять выполнить сложение чисел 10 и -5, но на этот раз представим их в обратном коде. Они будут выглядеть следующим образом:
{line-numbers: false}
```
10 = 0000 1010
-5 = 1111 1010
```

Теперь сложим эти два числа с помощью стандартного сумматора. Получим следующее:
{line-numbers: false}
```
10 + (-5) = 0000 1010 + 1111 1010 = 1 0000 0100
```

Обратите внимание, что в результате сложения произошло переполнение. Старшая единица не поместилась в один байт, отведённый под число. В этом случае её надо отбросить. Тогда получим:
{line-numbers: false}
```
0000 0100
```

На втором этапе вычисления надо прибавить отброшенную единицу к результату: 
{line-numbers: false}
```
0000 0100 + 0000 0001 = 0000 0101 = 5 
```

Это правильный результат сложения чисел 10 и -5.

Если в результате сложения получается отрицательное число, второй этап вычисления не нужен. Для примера сложим числа -7 и 2. Сначала представим их в обратном коде:
{line-numbers: false}
```
-7 = 1111 1000
2 = 0000 0010
```

Выполним первый этап сложения:
{line-numbers: false}
```
-7 + 2 = 1111 1000 + 0000 0010 = 1111 1010
```

Мы получили отрицательное число, потому что старший бит равен единице. В этом случае компьютеру больше не нужно совершать никаких действий. Он может использовать полученный результат для дальнейший вычислений.

Для человека будет удобнее перевести отрицательное число из обратного кода в прямой, чтобы проверить корректность результата. Для этого инвертируем все разряды со значением, а знаковый оставляем без изменений. В результате получим следующее: 
{line-numbers: false}
```
1111 1010 -> 1000 0101 = -5
```

Обратный код позволил совершать арифметические действия над отрицательными числами с помощью стандартного сумматора. Однако, эти действия происходят в два этапа, а не в один. Кроме того, проблема с представлением нуля двумя способами осталась нерешённой.

#### Дополнительный код

Дополнительный код решает обе проблемы обратного кода. Во-первых, он позволяет выполнять арифметические действия за одну операцию. Во-вторых, в нём ноль может быть представлен единственным способ.

В дополнительном коде положительные числа соответствуют своему представлению в прямом коде: старший разряд равен нулю, а остальные используются для значения числа. Все разряды отрицательных чисел (включая старший знаковый) инвертируются точно также как и в обратном коде. После этого к результату прибавляет единица.

Представление некоторых чисел в дополнительном коде приведено в таблице 3-15.

{caption: "Таблица 3-15. Представление целых со знаком в дополнительном коде", width: "70%"}
| Десятичное число | Шестнадцатеричный формат | Дополнительный код |
| --- | --- | --- |
| -127 | 81 | 1000 0001 |
| -110 | 92 | 1001 0010 |
| -60 | C4 | 1100 0100 |
| -5 | FB | 1111 1011 |
| 0 | 0 | 0000 0000 |
| 5 | 5 | 0000 0101 |
| 60 | 3C | 0011 1100 |
| 110 | 6E | 0110 1110 |
| 127 | 7F | 0111 1111 |

Диапазон допустимых значений для однобайтового целого такой же, как и для представления числа в обратном коде: от -127 до 127.

Рассмотрим, как стали выглядеть арифметические операции над отрицательными числами в обратном коде. Например, сложим числа 14 и -8. Сначала представим каждое из них в дополнительном коде. Получим:
{line-numbers: false}
```
14 = 0000 1110
-8 = 1111 1000
```

Теперь выполним сложение:
{line-numbers: false}
```
14 + (-8) = 0000 1110 + 1111 1000 = 1 0000 0110
```

В результате сложения произошло переполнение. Старшую единицу надо отбросить. Тогда мы получим конечный результат:
{line-numbers: false}
```
0000 0110 = 6
```

Если результат сложения отрицательный, то отбрасывать старший разряд ненужно. Для примера сложим числа -25 и 10. В дополнительном коде они выглядят так:
{line-numbers: false}
```
-25 = 1110 0111
10 = 0000 1010

-25 + 10 = 1110 0111 0000 1010 = 1111 0001
```

Переведём результат `1111 0001` из дополнительного кода в обратный, а потом в прямой. Для этого выполним следующие преобразования:
{line-numbers: false}
```
1111 0001 - 1 = 1111 0000 -> 1000 1111 = -15
```

При переводе из обратного кода в прямой мы инвертируем все разряды кроме старшего со знаком. В итоге мы получили корректный результат сложения.

Благодаря дополнительному коду стало возможно выполнять арифметические действия с отрицательными числами с помощью стандартного сумматора за один этап. Также решилась проблема с представлением нуля двумя разными способами.

В современных компьютерах целые представляются в дополнительном коде.

{caption: "Упражнение 3-7. Арифметические действия в дополнительном коде", format: text, line-numbers: false}
```
Выполните сложение следующих однобайтовых целых:

* 79 и -46
* -97 и 96

Выполните сложение следующих двухбайтовых целых:

* 12868 и -1219
```

#### Конвертирование чисел

Мы рассмотрели способы представления чисел в памяти компьютера. Может возникнуть вопрос — пригодятся ли эти знания на практике?

Современные языки программирования берут на себя большую часть работы по конвертированию чисел в правильный формат. Например, вы объявляете целую знаковую переменную в десятичной системе счисления для выполнения арифметических операций. Вам не надо заботиться о том, в каком виде она хранится в памяти компьютера. Если переменная примет отрицательное значение, она будет корректно сохранена в дополнительном коде без вашего участия.

Когда вам надо работать с переменной как с набором битов, вы объявляете её положительным целым и работаете с ней в шестнадцатеричной системе счисления. При этом вы используете все её разряды и никогда не переводите её в десятичную систему. Таким образом вы избегаете задачи конвертирования чисел.

Проблема возникает тогда, когда вам необходимо самостоятельно интерпретировать данные. Эта задача часто возникает при разработке встраиваемых систем. Другими словами каждый раз, когда вы читаете данные с периферийного устройства или получаете их по каналу связи, вы сталкиваетесь с задачей их правильной интерпретации. В этом случае вам понадобятся знания о правильном представлении чисел в памяти.

Ещё одна важная задача с которой сталкивается каждый программист — это [**отладка**](https://ru.wikipedia.org/wiki/Отладка_программы). Отладкой программы называется поиск и устранение в ней ошибок. Проверяя корректность выполнения арифметических выражений, вы легко сможете обнаружить ошибку переполнения, если знаете о знаковом разряде числа.


### Оператор ((

Целочисленная арифметика в Bash выполняет в так называемом **математическом контексте** (math context). В нём применяется синтаксис, напоминающий язык C для целочисленной арифметики.

Предположим, что вам необходимо сохранить результат сложения двух чисел в переменной `var`. Вы можете объявить её с целочисленным атрибутом `-i` и сразу же присвоить ей значение. Например так:
{line-numbers: false, format: Bash}
```
declare -i var=12+7
```

Если переменная объявлена с атрибутом `-i`, любое присваиваемое ей выражение будет вычисляться в математическом контексте. Другими словами присвоение значения такой переменной будет выполняться так, как будто перед ним стоит встроенная команда `let`. Поэтому следующие команды будут эквивалентны:
{line-numbers: true, format: Bash}
```
let var=5*7
var=5*7
```

Такое неявное применение математического контекста может стать источником ошибок. Поэтому рекомендуется избегать атрибута `-i` при объявлении переменных. Независимо от наличия атрибута, её значение в памяти будет храниться в виде строки. Конвертирование строки в число и обратно будет происходить каждый раз во время подстановки.

Если переменная объявлена как строковая, ей можно присвоить результат арифметического выражения с помощью встроенной команды `let`. Например, одним из следующих способов:
{line-numbers: true, format: Bash}
```
let var=12+7
let var="12 + 7"
let "var = 12 + 7"
let 'var = 12 + 7'
```

Все четыре команды дадут один и тот же результат: переменной `var` будет присвоено значение 19.

Обратите внимание, что каждый параметр команды `let` должен быть корректным арифметическим выражением. Если в выражении встречаются пробелы, оно будет разделено ими на части в результате word splitting. Тогда `let` попытается вычислить каждую часть по отдельности, что может привести к ошибке. Это значит, что следующая команда некорректна:
{line-numbers: false, format: Bash}
```
let var=12 + 7
```

В этом случае `let` попытается вычислить по отдельности три выражения: `var=12`, `+` и `7`. Проблема возникнет с вычислением `+`. Это арифметическое действие требует операндов, но их нет. Если все переданные в `let`выражения корректны, они будут вычислены друг за другом. Например:
{line-numbers: true, format: Bash}
```
let a=1+1 b=5+1
let "a = 1 + 1" "b = 5 + 1"
let 'a = 1 + 1' 'b = 5 + 1'
```

Чтобы предотвратить word splitting, необходимо заключать арифметические выражения в одинарные или двойные кавычки.

У встроенной команды `let` есть синоним — оператор `((`. Внутри него word splitting не выполняется, и поэтому указанные в нём выражения не требуют кавычек. Всегда предпочитайте использовать оператор `((` вместо `let`, чтобы избежать ошибок.

I> Отношения оператора `((` и команды `let` напоминают `test` и `[[`. В обоих случаях лучше использовать операторы, а не команды.

Оператор `((` имеет две формы. Первая форма называется **арифметическая оценка** ([arithmetic evaluation](https://wiki.bash-hackers.org/syntax/ccmd/arithmetic_eval)) и является полным аналогом команды `let`. Она выглядит следующим образом:
{line-numbers: false, format: Bash}
```
((var = 12 + 7))
```

В этой конструкции команда `let` заменяется на открывающие скобки `((`, а в конце добавляются закрывающие — `))`. Как и любая команда, такая форма оператора возвращает 0 в случае успешного выполнения и 1 в случае ошибки.

Вторая форма оператора `((` называется **арифметическая подстановка** ([arithmetic expansion](https://wiki.bash-hackers.org/syntax/expansion/arith)) и выглядит следующим образом:
{line-numbers: false, format: Bash}
```
var=$((12 + 7))
```

В ней перед оператором ставится знак доллара `$`. Встретив такую форму, интерпретатор вычислит выражение и подставит его результат, а не код возврата.

I> Вторая форма оператора `((` со знаком `$` является частью POSIX-стандарта. Её можно использовать для написания переносимого кода. Первая же форма `((` без `$` доступна только в интерпретаторах Bash, ksh и zsh.

Внутри оператора `((` можно использовать имена переменных без знака доллар `$`. В этом случае интерпретатор будет выполнять корректную подстановку их значений. Например, следующие два выражения для вычисления переменной `result` будут эквивалентны:
{line-numbers: true, format: Bash}
```
a=5 b=10
result=$(($a + $b))
result=$((a + b))
```

Предпочтительнее опускать знак `$` перед именами переменных в арифметических выражениях. Это делает код более удобным для чтения.

I> У команды `let` есть устаревший синоним — оператор `$[ ]`. Не используйте его. Также для расчёта арифметических выражений есть GNU утилита `expr`. Она нужна для совместимости со скриптами, написанными на Bourne Shell. Её никогда не следует применять при разработке новых скриптов.

Таблица 3-16 демонстрирует операции, допустимые в арифметических выражениях.

{caption: "Таблица 3-16. Операции в арифметических выражениях", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| | **Вычисления** | |
|  | | |
| `*` | Умножение | `echo "$((2 * 9)) = 18"` |
| `/` | Деление | `echo "$((25 / 5)) = 5"` |
| `%` | Остаток от деления | `echo "$((8 % 3)) = 2"` |
| `+` | Сложение | `echo "$((7 + 3)) = 10"` |
| `-` | Вычитание | `echo "$((8 - 5)) = 3"` |
| `**` | Возведение в степень | `echo "$((4**3)) = 64"` |
|  | | |
| | **Битовые операции** | |
|  | | |
| `~` | Побитовое НЕ | `echo "$((~5)) = -6"` |
| `<<` | Битовый сдвиг влево | `echo "$((5 << 1)) = 10"` |
| `>>` | Битовый сдвиг вправо | `echo "$((5 >> 1)) = 2"` |
| `&` | Побитовое И | `echo "$((5 & 4)) = 4"` |
| `|` | Побитовое ИЛИ | `echo "$((5 | 2)) = 7"` |
| `^` | Побитовое исключающее ИЛИ | `echo "$((5 ^ 4)) = 1"` |
|  | | |
| | **Присваивания** | |
|  | | |
| `=` | Обычное присваивание | `echo "$((num = 5)) = 5"` |
| `*=` | Умножение и присваивание результата | `echo "$((num += 5)) = 10"` |
| `/=` | Деление и присваивание результата | `echo "$((num /= 2)) = 5"` |
| `%=` | Остаток от деления и присваивание результата | `echo "$((num %= 2)) = 1"` |
| `+=` | Сложение и присваивание результата | `echo "$((num += 7)) = 8"` |
| `-=` | Вычитание и присваивание результата | `echo "$((num -= 3)) = 5"` |
| `<<=` | Битовый сдвиг влево и присваивание результата | `echo "$((num <<= 1)) = 10` |
| `>>=` | Битовый сдвиг вправо и присваивание результата | `echo "$((num >>= 2)) = 2"` |
| `&=` | Побитовое И (AND), затем присваивание результата | `echo "$((num &= 3)) = 2"` |
| `^=` | Побитовое [исключающее ИЛИ](https://ru.wikipedia.org/wiki/Исключающее_«или») (XOR), затем присваивание результата | `echo "$((num^=7)) = 5"` |
| `|=` | Побитовое ИЛИ (OR), затем присваивание результата | `echo "$((num |= 7)) = 7"` |
|  | | |
| | **Сравнения** | |
|  | | |
| `<` | Меньше | `((num < 5)) && echo "переменная num меньше 5"` |
| `>` | Больше | `((num > 5)) && echo "переменная num больше 3"` |
| `<=` | Меньше или равно | `((num <= 20)) && echo "переменная num меньше или равна 20"` |
| `>=` | Больше или равно | `((num >= 15)) && echo "переменная num больше или равна 15"` |
| `==` | Равно | `((num == 3)) && echo "переменная num равна 3"` |
| `!=` | Не равно | `((num != 3)) && echo "переменная num не равна 3"` |
|  | | |
| | **Логические операции** | |
|  | | |
| `!` | Логическое НЕ | `(( ! num )) && echo "переменная num имеет значение ЛОЖЬ"` |
| `&&` | Логическое И | `(( 3 < num && num < 5 )) && echo "переменная num больше 3, но меньше 5"` |
| `||` | Логическое ИЛИ | `(( num < 3 || 5 < num )) && echo "переменная num меньше 3 или больше 5"` |
|  | | |
| | **Другие операции** | |
|  | | |
| `num++` | Постфикс-инкремент | `echo "$((num++))"` |
| `num--` | Постфикс-декремент | `echo "$((num--))"` |
| `++num` | Префикс-инкремент | `echo "$((++num))"` |
| `--num` | Префикс-декремент | `echo "$((--num))"` |
| `+num` | Унарный плюс или умножение числа на 1 | `a=$((+num))"` |
| `-num` | Унарный минус или умножение числа на -1 | `a=$((-num))"`|
| `УСЛОВИЕ ? ДЕЙСТВИЕ1 : ДЕЙСТВИЕ2` | [Тернарная условная операция](https://ru.wikipedia.org/wiki/Тернарная_условная_операция) | `a=$(( b < c ? b : c ))` |
| `ДЕЙСТВИЕ1, ДЕЙСТВИЕ2` | Список выражений | `((a = 4 + 5, b = 16 - 7))` |
| `( ДЕЙСТВИЕ1 )` | Группирование выражений (подвыражение) | `a=$(( (4 + 5) * 2 ))`|

Порядок выполнения математических операций приведён в таблице 3-17.

{caption: "Таблица 3-17. Порядок выполнения математических операций", width: "100%"}
| Порядок выполнения | Операция | Описание |
| --- | --- | --- |
| 1 | `( ДЕЙСТВИЕ1 )` | Группирование выражений |
| 2 | `num++, num--` | Постфиксный инкремент и декремент |
| 3 | `++num, --num` | Префиксный инкремент и декремент |
| 4 | `+num, -num` | Унарный плюс и минус |
| 5 | `~, !` | Побитовое и логическое отрицание |
| 6 | `**` | Возведение в степень |
| 7 | `*, /, %` | Умножение, деление, нахождение остатка |
| 8 | `+, -` | Сложение и вычитание |
| 9 | `<<, >>` | Битовые сдвиги |
| 10 | `<, <=, >, >=` | Сравнения |
| 11 | `==, !=` | Равенство и неравенство |
| 12 | `&` | Побитовое И |
| 13 | `^` | Побитовое исключающее ИЛИ |
| 14 | `|` | Побитовое ИЛИ |
| 15 | `&&` | Логическое И |
| 16 | `||` | Логическое ИЛИ |
| 17 | `УСЛОВИЕ ? ДЕЙСТВИЕ1 : ДЕЙСТВИЕ2` | Тернарная условная операция |
| 18 | `=, *=, /=, %=, +=, -=, <<=, >>=, &=, ^=, |=` | Присваивания |
| 19 | `ДЕЙСТВИЕ1, ДЕЙСТВИЕ2` | Список выражений |

Порядок выполнения может быть изменён с помощью скобок `( )`. Они создают подвыражение (subexpression), которое интерпретатор рассчитывает в первую очередь. Если подвыражений несколько, они будут выполнены в порядке их следования.

С помощью префикса можно указать систему счисления числовой константы. Если префикс не указан, будет использоваться десятичная система. Список допустимых префиксов приведён в таблице 3-18.

{caption: "Таблица 3-18. Префиксы для систем счисления", width: "100%"}
| Префикс | Система счисления | Пример |
| --- | --- | --- |
| `0` | Восьмеричная | `echo "$((071)) = 57"` |
| `0x` | Шестнадцатеричная | `echo "$((0xFF)) = 255"` |
| `0X` | Шестнадцатеричная | `echo "$((0XFF)) = 255"` |
| `<основание>#` | Система с указанным основанием от 2 до 64 | `echo "$((16#FF)) = 255"` |
| | | `echo "$((2#101)) = 5"` |

При выводе значений переменных и констант в файл или на экран интерпретатор будет переводить их в десятичную систему. Менять формат вывода можно с помощью встроенной команды `printf`. Например, следующая команда выведет число на экран в шестнадцатеричной системе:
{line-numbers: false, format: Bash}
```
printf "%x\n" 250
```

Аналогично можно вывести и значение переменной:
{line-numbers: false, format: Bash}
```
printf "%x\n" $var
```

### Арифметические действия

Начнём с самых простых математических операций — арифметических. В языках программирования они обозначаются привычными символами:

* `+` сложение
* `-` вычитание
* `/` деление
* `*` умножение

В программировании помимо перечисленных часто используются ещё два действия: возведение в степень и вычисление [остатка от деления](https://ru.wikipedia.org/wiki/Деление_с_остатком).

Возведение в степень принято записывать в виде a^b^, где `a` является основанием, а `b` — показателем. Например, два в степени семь записывается как 2^7^. В Bash это арифметическое действие обозначается двумя символа звёздочки `*`:
{line-numbers: false}
```
2**7
```

Вычисление остатка от деления — более сложная операция. В чём она заключается и для чего применяется?

Если в результате деления одного целого числа на другое получается дробное, возникает остаток. Например, разделим 10 (делимое) на 3 (делитель). В результате с округлением получится 3,33333 (частное). В этом случае остаток от деления будет равен 1. Чтобы его вычислить, необходимо делитель 3 умножить на целую часть частного (или неполное частное) 3. Затем получившиеся число 9 вычтем из делимого 10 и получим 1.

Обозначим делимое буквой `a`, делитель — `b`, неполное частное — `q`, а остаток как `r`. Тогда формулу нахождения делимого `a` можно записать так:
{line-numbers: false}
```
a = b * q + r
```

Отсюда можно вывести формулу для нахождения остатка:
{line-numbers: false}
```
r = a - b * q
```

Выбор неполного частного `q` вызывает вопросы. Может показаться, что в качестве него можно использовать любое число. Но для выбора частного есть важное ограничение. Оно должно быть таким, чтобы остаток от деления `r` по абсолютной величине оказался меньше делителя `b`. Другими словами должно выполняться неравенство `|r| < |b|`.

Вычисление остатка в Bash обозначается знаком `%`. Обратите внимание, что в некоторых языках этим же символом обозначается операция [**modulo**](https://en.wikipedia.org/wiki/Modulo_operation). В общем случае это [два разных действия](https://habr.com/ru/post/421071). Но они дают одинаковый результат, когда знаки делимого и делителя совпадают.

Например вычислим остаток и modulo для следующих случаев:
{line-numbers: false}
```
19 % 12 = 19 - 12 * 1 = 7
19 modulo 12 = 19 - 12 * 1 = 7

-19 % -12 = -19 - (-12) * 1 = -7
-19 modulo -12 = -19 - (-12) * 1 = -7
```

Если знаки делимого и делителя различаются, остаток и modulo — разные:
{line-numbers: false}
```
19 % -12 = 19 - (-12) * (-1) = 7
19 modulo -12 = 19 - (-12) * (-2) = -5

-19 % 12 = -19 - 12 * (-1) = -7
-19 modulo 12 = -19 - 12 * (-2) = 5
```

Обратите внимание, что для расчёта modulo используется та же формула, что и для остатка, но выбирается другое неполное частное `q`. Для нахождения остатка, оно вычисляется по следующей формуле:
{line-numbers: false}
```
a / b = q
```

Результат следует округлить к меньшему по модулю. То есть отбросить все знаки после запятой. Неполное частное для modulo считается так же, но только когда `a` и `b` имеют одинаковые знаки. Если знаки разные, формула выглядит так:
{line-numbers: false}
```
a / b = q - 1
```

Результат также надо округлить к меньшему по модулю.

Обычно когда говорят об остатке `r`, подразумевают, что делимое `a` и делитель `b` положительны. Поэтому в справочниках часто можно встретить следующее условие: `0 ≤ r < |b|`. Но в случае деления чисел с разными знаками остаток может быть отрицательным. Запомните простое правило: у остатка всегда такой же знак, что и у делимого. Если знаки различаются, значит вы нашли modulo.

Всегда помните о различии остатка от деления и modulo при программировании на любом языке. Если вы сомневаетесь в своих вычисления, вы можете их проверить. Предположим, что вам нужно найти остаток деления 32 на -7. Для этого выполните следующую команду в Bash:
{line-numbers: false, format: Bash}
```
echo $((32 % -7))
```

Результат будет равен четырём.

Чтобы найти modulo для этой же пары чисел, наберите в поисковике Google следующую строку:
{line-numbers: false, format: Bash}
```
32 % -7
```

В результате на странице браузера будет выведен калькулятор с ответом -3.

Для чего используется вычисление остатка от деления? Одна из самых распространённых задач — проверка числа на чётность. Она возникает в коммуникациях, чтобы проверить корректность принятых данных. Этот подход известен как [**бит контроля чётности**](https://ru.wikipedia.org/wiki/Бит_чётности).

Чтобы проверить число на чётность, достаточно вычислить остаток его деления на 2. Если остаток равен нулю, значит число чётное. В противном случае — нечётное.

Другая распространённая задача в которой не обойтись без вычисления остатка — это преобразование единиц времени. Рассмотрим пример. Предположим, что нам надо перевести 128 секунд в минуты. Для этого нам надо подсчитать целое число минут и приписать к нему остаток. Чтобы найти минуты, разделим 128 на 60. Получим неполный остаток 2. Для нахождения оставшихся минут вычислим остаток от деления 128 на 60 — получим 8. Следовательно, 128 секунд равны двум минутам и восьми секундам.

Операция modulo активно используется в [криптографии](https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities)).

{caption: "Упражнение 3-6. Вычисление остатка от деления и modulo", format: text, line-numbers: false}
```
Вычислите остаток от деления и modulo:

* 1697 % 13
* 1697 modulo 13

* 772 % -45
* 772 modulo -45

* -568 % 12
* -568 modulo 12

* -5437 % -17
* -5437 modulo -17
```

### Битовые операции

Ещё один тип математических действий, который активно используется в программировании, — это [**битовые операции**](https://ru.wikipedia.org/wiki/Битовая_операция). Своё название они получили потому, что совершаются над каждым битом числа по отдельности. Другими словами, чтобы выполнить такую операцию, вам необходимо сначала представить число в двоичном виде, а затем выполнить действие над каждым его разрядом.

#### Побитовое отрицание

Начнём с самой простой битовой операции — отрицания. В компьютерной литературе она иногда обозначается как НЕ или NOT, а в Bash — знаком тильда `~`.

Чтобы выполнить побитовое отрицание, необходимо заменить каждый разряд в двоичном представлении числа на противоположный. То есть каждая единица заменяется на ноль и наоборот. Например, выполним побитовое отрицание числа 5:
{line-numbers: false}
```
5 = 101
~5 = 010
```

Это действие достаточно простое, если мы ограничимся только математикой. В программировании с ним возникает несколько сложностей. Прежде всего сразу возникает вопрос: сколько байтов отводится под число? Предположим, что число 5 в нашем примере хранится в двухбайтовой переменной. Тогда в памяти в двоичном виде оно будет выглядеть так:
{line-numbers: false}
```
00000000 00000101
```

После побитового отрицания содержимое переменной станет таким:
{line-numbers: false}
```
11111111 11111010
```

Теперь возникает другой вопрос: как интерпретировать полученный результат? Если переменная была объявлена как беззнаковое целое, нашим результатом будет число 65530 в прямом коде. Если же переменная знаковая, её значение необходимо представить в дополнительном коде. В этом случае мы получим -6.

Разные команды и операторы Bash представляют целые по-разному. Например, `echo` всегда выводит числа как знаковые. В команде `printf` есть возможность указать формат выводимых целых: знаковые или беззнаковые. 

Поскольку Bash явно не имеет типов, все скалярные переменные хранятся в виде строк. Следовательно, интерпретация целых происходит в момент их подстановки в арифметические выражения. В зависимости от контекста они могут быть подставлены как знаковые и как беззнаковые.

Независимо от наличия знака под целые в Bash отводится 64 бита. Это значит, что максимальное положительное знаковое число в Bash равно 7FFFFFFFFFFFFFFF в HEX или 9223372036854775807 в DEC. Минимальное отрицательное число равно 8000000000000000 в HEX или -9223372036854775808 в DEC. Максимальное беззнаковое целое равно FFFFFFFFFFFFFFFF в HEX или 18446744073709551615 в DEC.

Следующие команды демонстрируют различные интерпретации целых в Bash:
{line-numbers: true, format: Bash}
```
$ echo $((16#FFFFFFFFFFFFFFFF))
-1

$ printf "%llu\n" $((16#FFFFFFFFFFFFFFFF))
18446744073709551615

if ((18446744073709551615 == 16#FFFFFFFFFFFFFFFF)); then echo "ok"; fi
ok

if ((-1 == 16#FFFFFFFFFFFFFFFF)); then echo "ok"; fi
ok

$ if ((18446744073709551615 == -1)); then echo "ok"; fi
ok
```

Последний пример с конструкцией `if` показывает, что знаковые и беззнаковые целые хранятся в памяти одинаковым способом. Однако, они интерпретируются по-разному в зависимости от контекста.

Вернёмся к нашему примеру с побитовым отрицанием числа 5. Результат будет зависеть от способа его вывода:
{line-numbers: true, format: Bash}
```
$ echo $((~5))
-6

$ printf "%llu\n" $((~5))
18446744073709551610
```

Оба результата равны 0xFFFFFFFFFFFFFFFA в шестнадцатеричной системе и являются правильными с точки зрения операции побитового отрицания.

#### Побитовое И и ИЛИ

Операция побитового И выполняется над двумя числами. Она очень похожа на логическое И.

Как вы помните, в логическом И результат выражения истеннен только в том случае, когда оба операнда истинны. Для всех остальных значений операндов результатом будет ложь.

Чтобы выполнить побитовое И необходимо выполнить следующие действия:

1. Представить оба операнда операции в двоичном виде.

2. Если число разрядов в одном операнде меньше чем в другом, дополнить его слева нулями.

3. Применить логическое И к каждой паре битов, которые стоят на одинаковых позициях в двоичном представлении операндов.

Рассмотрим пример. Вычислим побитовое И для чисел 5 и 3. В двоичном виде эти числа представляются следующим образом:
{line-numbers: false}
```
5 = 101
3 = 11
```

У числа 3 оказалось меньше разрядов, чем у 5. Поэтому дополним двоичное представление 3 нулём слева:
{line-numbers: false}
```
3 = 011
```

Теперь выполним операцию логического И для каждой пары битов чисел 5 и 3. Для удобства запишем двоичное представление чисел в столбик и получим:
{line-numbers: false}
```
101
011
---
001
```

Переведём результат в десятичную систему:
{line-numbers: false}
```
001 = 1
```

В Bash операция побитового И обозначается знаком амперсанд `&`. Результат рассчитанного нами выражения можно вывести следующим образом:
{line-numbers: false, format: Bash}
```
echo $((5 & 3))
```

Операция побитового ИЛИ выполняется аналогично побитовому И. Только вместо логического И над каждой парой битов операндов надо выполнять логическое ИЛИ.

Рассмотрим пример выполнения побитового ИЛИ для чисел 10 и 6. В двоичном виде числа представляются следующим образом:
{line-numbers: false}
```
10 = 1010
6 = 110
```

Число 6 надо дополнть нулём до четырёх разрядов:
{line-numbers: false}
```
6 = 0110
```

Теперь выполним логическое ИЛИ над каждой парой битов чисел 10 и 6:
{line-numbers: false}
```
1010
0110
----
1110
```

Переведём результат в десятичную систему:
{line-numbers: false}
```
1110 = 14
```

В Bash побитовое или обозначается знаком `|`. Чтобы вывести результат расчёта нашего примера, выполните следующую команду:
{line-numbers: false, format: Bash}
```
echo $((10 | 6))
```

#### Побитовое исключающее ИЛИ

// TODO: Упражнение

### Логические операции

### Инкремент и декремент

### Тернарная условная операция
## Переменные и параметры

Мы уже сталкивались с переменными, когда говорили о `PATH`, хранящем список системных путей, и доступе к позиционным параметрам Bash-скрипта по именам `$1`, `$2` и т.д. Теперь рассмотрим тему переменных подробнее.

Что представляет собой переменная в контексте программирования? Это некоторая область памяти (обычно оперативной), в которой хранится значение. В первых языках программирования (например, [**ассемблере**](https://ru.wikipedia.org/wiki/Язык_ассемблера)) обращение к переменным происходит по их адресу. То есть, чтобы записать новое значение или прочитать текущее, вы должны указывать адрес памяти. В 32-разрядных архитектурах длина адреса 4 байта (число от 0 до 4294967295), а в 64-разрядных он в два раза больше. Очевидно, что запоминать и оперировать такими большими числами неудобно. Поэтому современные языки программирования позволяют вместо адресов работать с именами переменных. Эти имена в процессе компиляции или интерпретации программы транслируются в адреса памяти. Таким образом всю работу по "запоминанию" больших чисел берёт на себя компилятор или интерпретатор.

### Классификация переменных

Интерпретатор Bash может работать в двух основных режимах: интерактивном (командная оболочка) и неинтерактивном (исполнение скриптов). Переменные активно используются в каждом из них. Задачи решаемые переменными в этих режимах различаются. Это привело к появлению нескольких классификаций переменных в Bash.

Для удобства рассмотрения сделаем небольшое упрощение в терминологии, которое в общем не совсем правильно. При обсуждении скриптов, будем использовать тремин "переменная" (variable). Когда же обсуждается командная оболчка и аргументы командной строки, будем использовать термин "параметр" (parameter). Это позволит избежать путанницы. В английской литературе эти термины часто используются как синонимы.

Какие же классификации переменных есть в Bash? Таблица 3-1 демонстрирует их в кратком виде.

{caption: "Таблица 3-1. Классификация переменных в Bash", width: "100%"}
| Признак классификации | Типы | Определение | Примеры |
| --- | --- |  --- |
| Доступность в shell | Глобальные переменные или переменные окружения | Доступны в любом экземпляре запущенного интерпретатора. Выводятся утилитой `env`, запущенной без параметров. | `echo $PATH` |
|                     | Локальные переменные | Доступны только в конкретном экземпляре запущенного интерпретатора. | `filename="README.txt" ; echo "$filename"` |
|  | | | |
| Тип хранимого значения | Строковые | Хранят строки. | `filename="README.txt"` |
|                     | Целочисленные | Хранят целые числа. | `declare -i number=10/2 ; echo "$number"` |
|                     | Константные | Хранят неизменяемые значения или константы. | `readonly CONSTANT="ABC" ; echo "$CONSTANT"` |
|                     | | | `declare -r CONSTANT="ABC" ; echo "$CONSTANT"` |
|                     | Массивы | | |
|  | | | |
| Кем устанавливаются? | Зарезервированные | | |
|                      | Пользовательские | | |
|  | | | |



-----

Переменные в языке Bash делятся на два типа: пользовательские (variables) и специальные (**special parameters**). К первому типу относятся все объявления пользователя. Ко второму — переменные, устанавливаемые самим интерпретатором. Они доступны только для чтения.


### Переменные

Пользовательские переменные вы можете объявлять следующим образом:
{line-numbers: false, format: Bash}
```
FILENAME="README.txt"
```

Обратите внимание, что пробел до и после знака равно не ставится. То есть следующее объявление завершится с ошибкой:
{line-numbers: false, format: Bash}
```
FILENAME = "README.txt"
```

В этом случае Bash обработает эту строку как вызов команды с именем `FILENAME` и двумя параметрами: `=` и `"README.txt"`

I> В именах переменных можно использовать только символы латинского алфавита, числа и знак подчёркивания. Имена не должно начинаться с числа. Регистр букв важен, т.е. `filename` и `FILENAME` — это две разные переменные.

При объявлении переменной `FILENAME` в памяти процесса интерпретатора выделяется область памяти, в которой сохраняется строка `README.txt`. Чтобы её прочитать, следует обратиться к ней по имени. Но интерпретатор должен понять, что речь идёт не о команде или строке, а о переменной. Чтобы сообщить ему эту информацию, необходимо поставить знак доллара `$` перед именем:
{line-numbers: false, format: Bash}
```
$FILENAME
```

Что означает знак доллара? Встретив его в команде, Bash запускает механизм подстановки параметров (**parameter expansion**). Он заключается в подстановке значения переменной вместо её имени. Рассмотрим следующую команду:
{line-numbers: false, format: Bash}
```
cp $FILENAME ~
```

Bash развернёт её так:
{line-numbers: false, format: Bash}
```
cp README.txt ~
```

Учтите, что при подстановке параметров, Bash может совершать дополнительные действия. Например, объявим нашу переменную так:
{line-numbers: false, format: Bash}
```
FILENAME="my file.txt"
```

Тогда вызов утилиты `cp` будет развёрнут следующим образом:
{line-numbers: false, format: Bash}
```
cp my file.txt ~
```

В этом случае после подстановки имени переменной Bash выполнил word splitting и мы получили вместо одного параметра два. Очевидно, что такой вызов `cp` завершится ошибкой, потому что файлов `my` и `file.txt` не существует.

Проблема возникнет и в том случае, если в значении переменной встречается символ подстановки. Например:
{line-numbers: false, format: Bash}
```
FILENAME="*file.txt"
rm $FILENAME
```

В результате этой команды будут удалены все файлы, заканчивающиеся на `file.txt`. В таком поведении виноват механизм globbing, который отработает после подстановки параметра. В результате его работы в команду `rm` будут переданы все файлы из текущего каталога, имена которых соответствуют шаблону поиска `*file.txt`. Например:
{line-numbers: false, format: Bash}
```
rm report_file.txt myfile.txt msg_file.txt
```

Чтобы избежать манипуляций Bash над подставленным значением переменной, заключайте обращение к ней в кавычки:
{line-numbers: true, format: Bash}
```
FILENAME1="my file.txt"
cp "$FILENAME1" ~

FILENAME2="*file.txt"
rm "$FILENAME2"
```

Благодаря этому, значение будет использовано без каких-либо изменений:
{line-numbers: false, format: Bash}
```
cp "my file.txt" ~
rm "*file.txt"
```

Запись имени переменной со знаком `$` вначале является сокращенной формой. В полном виде запись выглядит так:
{line-numbers: false, format: Bash}
```
${FILENAME}
```

Такая форма поможет избежать неоднозначности, если сразу за именем переменной следует текст. Например
{line-numbers: true, format: Bash}
```
PREFIX="my"
NAME="file.txt"
cp "$PREFIX_$NAME" ~
```

В этом случае при подстановке параметров интерпретатор будет искать переменную с именем `PREFIX_`. То есть он приклеит подчёркивание к имени. Чтобы избежать этой проблемы можно воспользоваться полной формой записи:
{line-numbers: false, format: Bash}
```
cp "${PREFIX}_${NAME}" ~
```

Альтернативное решение — заключить каждое имя переменной в кавычки:
{line-numbers: false, format: Bash}
```
cp "$PREFIX"_"$NAME" ~
```

Устранение неоднозначности — не единственный случай, когда пригодится полная форма записи подстановки. Также она будет полезна, когда переменная не определена. В этом случае вместо её значения можно подставить некоторое значение по умолчанию. Например:
{line-numbers: false, format: Bash}
```
cp file.txt "${DIRECTORY:-~}"
```

При обработке этой команды Bash проверит, определена ли переменная с именем `DIRECTORY` и имеет ли она непустое значение. Если это так, произойдёт обычная подстановка. В противном случае будет использовано значение, следующее за символом `-`. В нашем примере это домашний каталог пользователя `~`.

Все варианты задания значения по умолчанию при подстановке приведены в таблице 3-1.

{caption: "Таблица 3-1. Задание значения по умолчанию при подстановке", width: "100%"}
| Форма записи | Описание|
| --- | --- |
| ${parameter:-word} | Если переменная `parameter` не объявлена или имеет пустое значение, будет подставлено значение по умолчанию `word`. В противном случае подставляется значение переменной. |
|  | |
| ${parameter:=word} | Если переменная не объявлена или имеет пустое значение, ей будет присвоено значение по умолчанию, которое затем будет подставлено. В противном случае подставляется значение переменной. Переопределение позиционных и специальных параметров таким способом не допустимо. |
|  | |
| ${parameter:?word} | Если переменная не объявлена или имеет пустое значение, значение по умолчанию будет выведено в стандартный поток ошибок. После этого выполнение скрипта будет завершено с кодом возврата отличным от 0. В противном случае подставляется значение переменной. |
|  | |
| ${parameter:+word} | Если переменная не объявлена или имеет пустое значение, ничего не будет подставлено. В противном случае подставляется значение по умолчанию. |

{caption: "Упражнение 3-1. Использование полной формы подстановки параметров", format: text, line-numbers: false}
```
Напишите скрипт, который ищет файлы с расширением TXT в текущем каталоге, исключая его подкаталоги. Все найденные файлы должны быть скопированы или перемещены в домашний каталог пользователя. При вызове скрипта требуемая операция передаётся в первом позиционном параметре. Если она не указана, выполняется копирование.
```

### Специальные параметры

### Типы
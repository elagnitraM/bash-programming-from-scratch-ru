## Переменные и параметры

В этой книге не раз упоминались переменные в Bash. Нам уже знаком список системных путей в переменной `PATH`. Мы использовали позиционные параметры в скрипте для резервного копирования. Настало время хорошо разобраться в этой теме.

Сначала выясним, что называется переменной в программировании. Это область памяти (обычно оперативной), в которой хранится значение. В первых языках программирования (например, [**ассемблере**](https://ru.wikipedia.org/wiki/Язык_ассемблера)) обращение к переменным происходит по их адресу. То есть, чтобы записать новое значение или прочитать текущее, надо указать адрес памяти. В 32-разрядных процессорах длина адреса 4 байта (число от 0 до 4294967295), а в 64-разрядных она в два раза больше. Запоминать и оперировать такими большими числами неудобно. Поэтому современные языки программирования позволяют заменять адреса переменных на их имена. Эти имена в процессе компиляции или интерпретации программы транслируются в адреса памяти. Таким образом всю работу по "запоминанию" больших чисел берёт на себя компилятор или интерпретатор.

Зачем нужны переменные? Наш опыт работы с `PATH` и позиционными параметрами показал, что переменные хранят какие-то данные. Это нужно для одной из следующих целей:

1. Передать информацию из одной части программы или системы в другую.

2. Сохранить промежуточный результат вычислений для дальнейшего использования.

3. Сохранить текущее состояние программы или системы. Это состояние может определять дальнейшее поведение.

4. Задать константное значение, которое позже будет многократно использоваться.

Для каждой цели в языках программирования вводится специальный тип переменной. Язык Bash не исключение.

### Классификация переменных

У интерпретатора Bash есть два режима работы: интерактивный (командная оболочка) и неинтерактивном (исполнение скриптов). В каждом режиме переменные решают сходные задачи. Но контексты этих задач различаются. Поэтому признаков для классификации переменных в Bash больше, чем в других интерпретируемых языках.

Упростим терминологию для удобства. Это не совсем правильно, но позволит избежать путаницы. Когда говорим о скриптах, будем использовать термин "переменная" (variable). Когда речь о командной оболочке и аргументах командной строки, будем применять термин "параметр" (parameter). В английской литературе эти термины часто используют как синонимы.

Для классификации переменных в Bash есть четыре признака. Они приведены в таблице 3-1.

{caption: "Таблица 3-1. Классификация переменных в Bash", width: "100%"}
| Признак классификации | Типы | Определение | Примеры |
| --- | --- | --- | --- |
| Механизм установки | Пользовательские переменные | Устанавливаются пользователем. | `filename="README.txt" ; echo "$filename"` |
|  | | | |
|                    | Зарезервированные (системные) переменные | Устанавливаются интерпретатором и нужны для его корректной работы. | `echo "$PATH"` |
|  | | | |
|                    | Специальные параметры | Устанавливаются интерпретатором и доступны только для чтения. | `echo "$?"` |
|  | | | |
| [Область видимости](https://ru.wikipedia.org/wiki/Область_видимости) | Переменные окружения (или глобальные) | Доступны в любом экземпляре интерпретатора. Выводятся утилитой `env`, запущенной без параметров. | `echo "$PATH"` |
|  | | | |
|                     | Локальные переменные | Доступны только в конкретном экземпляре интерпретатора. | `filename="README.txt" ; echo "$filename"` |
|  | | | |
| Содержимое | Строка | Хранит строку. | `filename="README.txt"` |
|  | | | |
|            | Число | Хранит целое число. | `declare -i number=10/2 ; echo "$number"` |
|  | | | |
|            | Индексируемый массив | Хранит нумерованный список строк. | `cities=("London" "New York" "Berlin") ; echo "${cities[1]}"` |
|  | | | `cities[0]="London" ; cities[1]="New York" ; cities[2]="Berlin" ; echo "${cities[1]}"` |
|  | | | |
|            | [**Ассоциативный массив**](https://ru.wikipedia.org/wiki/Ассоциативный_массив) | Структура данных, каждый элемент которой — это пара ключ-значение. Ключом и значением являются строки. | `declare -A cities=( ["Alice"]="London" ["Bob"]="New York" ["Eve"]="Berlin" ) ; echo "${cities[Bob]}"` |
|  | | | |
| Возможность изменения | Константны | Не могут быть удалены. Хранят значения, которые нельзя переопределить. | `readonly CONSTANT="ABC" ; echo "$CONSTANT"` |
|                     | | | `declare -r CONSTANT="ABC" ; echo "$CONSTANT"` |
|  | | | |
|                     | Переменные | Могут быть удалены. Их значения можно переопределить. | `filename="README.txt"` |

Рассмотрим каждый тип переменных.

### Механизм установки

#### Пользовательские переменные

Назначение пользовательских переменных очевидно из названия. Их объявляет пользователь для своих целей. Такие переменные обычно хранят промежуточные результаты работы скрипта, его состояние и часто используемые константы.

Чтобы объявить пользовательскую переменную, укажите её имя, поставьте знак равно и наберите значение переменной. Пробелов в объявлении быть не должно. 

Рассмотрим пример. Объявим переменную с именем `filename`. В ней хранится имя файла `README.txt`. Объявление переменной выглядит так:
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

Пробелы до и после знака равно не ставятся. Другие языки программирования это допускают, но не Bash. Это значит, что интерпретатор не сможет обработать следующее объявление:
{line-numbers: false, format: Bash}
```
filename = "README.txt"
```

Bash интерпретируют эту строку как вызов команды `filename` с двумя параметрами `=` и `"README.txt"`

В именах переменных допустимы только символы латинского алфавита, числа и знак подчёркивания `_`. Имя не должно начинаться с числа. Регистр букв важен. Это значит, что `filename` и `FILENAME` — две разные переменные.

Предположим, что мы объявили переменную `filename`. В результате для неё выделилась область в памяти процесса интерпретатора. В этой области сохранилась строка `README.txt`. Чтобы прочитать строку из памяти, к переменной надо обратиться по имени. При этом интерпретатор Bash должен понять, что вы имеете в виду. Если поставить знак доллара $ перед словом `filename`, Bash обработает его как имя переменной.

Обращение к переменной в команде или скрипте должно выглядеть так:
{line-numbers: false, format: Bash}
```
$filename
```

Bash обрабатывает слова со знаком доллара по-особенному. Встретив такое слово в команде, интерпретатор запускает механизм подстановки переменных (**parameter expansion**). Этот механизм заменяет все вхождения имени переменной на её значение. Рассмотрим следующую команду:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

После подстановки переменных она будет выглядеть так:
{line-numbers: false, format: Bash}
```
cp README.txt ~
```

Всего интерпретатор совершает девять видов подстановок. Порядок их выполнения важен. Если его не учесть, могут возникнуть ошибки. Рассмотрим пример такой ошибки. Предположим, что в скрипте мы работаем с файлом "my file.txt". Для удобства поместим его имя в переменную. Её объявление выглядит так:
{line-numbers: false, format: Bash}
```
filename="my file.txt"
```

Далее переменная используется в вызове утилиты cp. Команда её вызова выглядит так:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

После подстановки переменных Bash выполняет word splitting. Это другой механизм подстановки. После него вызов утилиты cp станет таким:
{line-numbers: false, format: Bash}
```
cp my file.txt ~
```

Эта команда завершится с ошибкой. Вместо одного параметра с именем файла, в утилиту cp передаются два: `my` и `file.txt`. Таких файлов не существует.

Если в значении переменной встречается специальный символ, опять возникнет проблема. Например:
{line-numbers: false, format: Bash}
```
filename="*file.txt"
rm $filename
```

В результате вызова утилиты rm будут удалены все файлы, заканчивающиеся на `file.txt`. В этом виноват механизм globbing. Он тоже выполняется после подстановки переменных. После globbing в утилиту rm будут переданы все файлы из текущего каталога, имена которых соответствуют шаблону поиска `*file.txt`. Это может привести к неожиданному результату. Например, такому:
{line-numbers: false, format: Bash}
```
rm report_file.txt myfile.txt msg_file.txt
```

Чтобы избежать нежелательных подстановок Bash, заключайте все обращения к переменным в двойные кавычки ". Например, так:
{line-numbers: true, format: Bash}
```
filename1="my file.txt"
cp "$filename1" ~

filename2="*file.txt"
rm "$filename2"
```

Благодаря кавычкам, значение переменной будет подставлено без дальнейших изменений:
{line-numbers: true, format: Bash}
```
cp "my file.txt" ~
rm "*file.txt"
```

Мы уже знаем несколько [подстановок](http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Expansions), которые выполняет Bash. Таблица 3-2 приводит их полный список и порядок выполнения. 

{caption: "Таблица 3-2. Подстановки Bash", width: "100%"}
| Порядок выполнения | Подстановка | Комментарий | Пример |
| --- | --- | --- | --- |
| 1 | Brace Expansion | Подстановка фигурных скобок { и }. | `echo a{d,c,b}e` |
|  | | | |
| 2 | Tilde Expansion | Подстановка символа тильда ~. | `cd ~` |
|  | | | |
| 3 | Parameter Expansion | Подстановка параметров и переменных. | `echo "$PATH"` |
|  | | | |
| 4 | Arithmetic Expansion | Подстановка вместо арифметических выражений их значений. | `echo $((4+3))` |
|  | | | |
| 5 | Command Substitution | Подстановка вместо команды её вывода. | `echo $(< README.txt)` |
|  | | | |
| 6 | Process Substitution | Подстановка вместо команды её вывода. В отличие от Command Substitution эта подстановка выполняется [асинхронно](https://ru.wikipedia.org/wiki/Асинхронность#Асинхронность_в_информатике). Ввод и вывод команды привязаны к временному файлу. | `diff <(sort file1.txt) <(sort file2.txt)` |
|  | | | |
| 7 | Word Splitting | Разделение аргументов командной строки на слова и передача их в качестве отдельных параметров. | `cp file1.txt file2.txt ~` |
|  | | | |
| 8 | Filename Expansion (globbing) | Подстановка имён файлов вместо шаблонов. | `rm ~/delete/*` |
|  | | | |
| 9 | Quote Removal | Удаление всех неэкранированных символов \, ' и ", которые не были получены в результате одной из предыдущих подстановок. | `cp "my file.txt" ~` |

{caption: "Упражнение 3-1. Тестирование подстановок Bash", format: text, line-numbers: false}
```
Выполните в терминале пример каждой подстановки Bash из таблицы 3-2. Разберитесь, как получилась конечная команда. Придумайте свои примеры.
```

Знак $ перед именем переменной — это сокращенная форма подстановки переменных. В полном виде она выглядит так:
{line-numbers: false, format: Bash}
```
${filename}
```

Используйте полную форму, чтобы избежать неоднозначности. Например, если сразу за именем переменной следует текст:
{line-numbers: true, format: Bash}
```
prefix="my"
name="file.txt"
cp "$prefix_$name" ~
```

Тогда интерпретатор ищет переменную с именем `prefix_`. То есть он приклеит символ подчёркивания к имени переменной. Полная форма записи подстановки переменных решит эту проблему:
{line-numbers: false, format: Bash}
```
cp "${prefix}_${name}" ~
```

Альтернативное решение — заключить каждое имя переменной в кавычки. Например, так:
{line-numbers: false, format: Bash}
```
cp "$prefix"_"$name" ~
```

Полная форма записи подстановки переменных устраняет неоднозначности. Кроме этого она поможет, когда переменная не была определена. В этом случае можно подставить некоторое значение по умолчанию. Например:
{line-numbers: false, format: Bash}
```
cp file.txt "${directory:-~}"
```

При обработке этой команды Bash проверит, определена ли переменная `directory` и имеет ли она непустое значение. Если это так, выполнится обычная подстановка. В противном случае Bash подставит значение, следующее за символом минус -. В нашем примере — это домашний каталог пользователя ~.

Задать значение по умолчанию можно несколькими способами. Все они приведены в таблице 3-3.

{caption: "Таблица 3-3. Задание значения по умолчанию при подстановке", width: "100%"}
| Форма записи | Описание|
| --- | --- |
| `${parameter:-word}` | Если переменная `parameter` не объявлена или имеет пустое значение, будет подставлено значение по умолчанию `word`. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:=word}` | Если переменная не объявлена или имеет пустое значение, ей будет присвоено значение по умолчанию. Затем она будет подставлена. В противном случае подставляется значение переменной. Переопределение позиционных и специальных параметров таким способом недопустимо. |
|  | |
| `${parameter:?word}` | Если переменная не объявлена или имеет пустое значение, значение по умолчанию будет выведено в стандартный поток ошибок. После этого выполнение скрипта будет завершено с кодом возврата отличным от 0. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:+word}` | Если переменная не объявлена или имеет пустое значение, подстановки не будет. В противном случае подставляется значение по умолчанию. |

{caption: "Упражнение 3-2. Использование полной формы подстановки параметров", format: text, line-numbers: false}
```
Напишите скрипт, который ищет файлы с расширением TXT в текущем каталоге. Скрипт игнорирует подкаталоги. Все найденные файлы копируются или перемещаются в домашний каталог пользователя. При вызове скрипта можно выбрать действие: копировать или перемещать файлы. Если действие не указано, выполняется копирование.
```

#### Зарезервированные переменные

Переменные может объявлять не только пользователь, но и сам интерпретатор. В этом случае они называются **зарезервированными** (reserved) или **переменными оболочки** (shell variables). Интерпретатор присваивает им значение по умолчанию. Значение некоторых переменных оболочки можно изменить.

Зарезервированные переменные исполняют две функции:

1. Передача информации от командного интерпретатора в запускаемое им приложение.

2. Хранение текущего состояния самого интерпретатора.

Переменные оболочки делятся на две группы:

1. Переменные Bourne Shell.

2. Переменные Bash.

Первая группа унаследована из Bourne Shell и нужна Bash для POSIX-совместимости. Часто используемые из этих переменных представлены в таблице 3-4.

{caption: "Таблица 3-4. Зарезервированные переменные Bourne Shell", width: "100%"}
| Имя | Значение |
| --- | --- |
| `HOME` | Домашний каталог текущего пользователя. Значение переменной используется при вызове встроенной команды `cd` без параметров и подстановке символа тильда `~`. |
|  | |
| [`IFS`](http://mywiki.wooledge.org/IFS) | Список следующих друг за другом символов-разделителей. Вводимые строки будут разделены этими символами на слова (например, при word splitting). По умолчанию разделители такие: пробел, [табуляция](https://ru.wikipedia.org/wiki/Табуляция), перевод строки. |
|  | |
| `PATH` | Список путей, по которым интерпретатор ищет вызываемые утилиты и программы. Пути в списке разделены двоеточиями. |
|  | |
| `PS1` | Приглашение командной строки. Может включать [управляющие символы](https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html#Controlling-the-Prompt). Перед выводом на экран они заменятся на конкретные значения (например, имя текущего пользователя). |

Кроме унаследованных переменных оболочки Bourne Shell в Bash появились новые. Они приведены в таблице 3-5. Кроме перечисленных есть и другие переменные Bash, но они используются редко.

{caption: "Таблица 3-5. Зарезервированные переменные Bash", width: "100%"}
| Имя | Значение |
| --- | --- |
| `BASH` | Полный путь до исполняемого файла Bash. Этот файл соответствует текущему процессу Bash. |
|  | |
| `BASHOPTS` | Список [дополнительных опций](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin) текущего процесса Bash. Опции в списке разделены двоеточиями. |
|  | |
| `BASH_VERSION` | Версия запущенного Bash интерпретатора. |
|  | |
| `GROUPS` | Список групп, к которым относится текущий пользователь. |
|  | |
| `HISTCMD` | Номер текущей команды в истории команд. |
|  | |
| `HISTFILE` | Файл, в котором сохраняется история команд. По умолчанию это `~/.bash_history`. |
|  | |
| `HISTFILESIZE` | Максимально допустимое число строк в файле истории команд. Значение по умолчанию 500. |
|  | |
| `HISTSIZE` | Максимально допустимое число команд в файле истории команд. Значение по умолчанию 500. |
|  | |
| `HOSTNAME` | Имя текущего компьютера как узла вычислительной сети. |
|  | |
| `HOSTTYPE` | Строка с описанием аппаратной платформы, на которой запущен Bash. |
|  | |
| `LANG` | [Региональные настройки](https://ru.wikipedia.org/wiki/Региональные_настройки_(программирование)) пользовательского интерфейса. Некоторые из них переопределяются переменными `LC_ALL`, `LC_COLLATE`, `LC_CTYPE`, `LC_MESSAGES`, `LC_NUMERIC`, `LC_TYPE`. |
|  | |
| `MACHTYPE` | Строка с описанием системы, на которой запущен Bash. Включает в себя информацию из переменных `HOSTTYPE` и `OSTYPE`. |
|  | |
| `OLDPWD` | Предыдущий рабочий каталог, который устанавливала встроенная команда `cd`. |
|  | |
| `OSTYPE` | Строка с описанием ОС, на которой запущен Bash. |
|  | |
| `POSIXLY_CORRECT` | Если эта переменная определена, Bash работает в режиме [POSIX-совместимости](https://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html#Bash-POSIX-Mode). |
|  | |
| `PWD` | Текущий каталог, который установила встроенная команда `cd`. |
|  | |
| `RANDOM` | Каждый раз при чтении этой переменной возвращается случайное число от 0 до 32767. При записи переменной назначается инициализирующее число ([seed](https://en.wikipedia.org/wiki/Random_seed)) для [генератора псевдослучайных чисел](https://ru.wikipedia.org/wiki/Генератор_псевдослучайных_чисел). |
|  | |
| `SECONDS` | Количество секунд, прошедших с момента запуска текущего процесса Bash. |
|  | |
| `SHELL` | Полный путь к исполняемому файлу командного интерпретатора для текущего пользователя. |
|  | |
| `SHELLOPTS` | Список [дополнительных опций](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin) комндного интерпретатора. Опции в списке разделены двоеточиями. |
|  | |
| `SHLVL` | Уровень вложенности текущего экземпляра Bash. Эта переменная увеличивается на единицу каждый раз при запуске Bash из командного интерпретатора. |
|  | |
| `UID` | Идентификатор текущего пользователя. |

Зарезервированные переменные делятся на три группы в зависимости от допустимых над ними действий:

1. При запуске интерпретатор назначает переменной значение. В течении всей сессии оно остаётся неизменным. Пользователь может его прочитать, но не изменить. Примеры: `BASHOPTS`, `GROUPS`, `SHELLOPTS`, `UID`.

2. При запуске интерпретатор назначает переменной значение по умолчанию. Оно меняется в результате выполнения пользователем команд или иных событий. Значение некоторых переменных можно переобъявить явно, но это может нарушить работу интерпретатора. Примеры: `HISTCMD`, `OLDPWD`, `PWD`, `SECONDS`, `SHLVL`.

3. При запуске интерпретатор назначает переменной значение по умолчанию. Единственный способ его изменить — это переобъявить. Примеры: `HISTFILESIZE`, `HISTSIZE`

#### Специальные параметры

Специальные параметры назначаются интерпретатором, как и переменные оболочки. Некоторые параметры хранят состояние запущенного экземпляра Bash (например, PID). Другие нужны для передачи параметров командной строки в вызываемые приложения и чтения их кода возврата. Все позиционные параметры относятся к специальным.

Часто используемые специальные параметры приведены в таблице 3-6.

{caption: "Таблица 3-6. Специальные параметры Bash", width: "100%"}
| Имя | Значение |
| --- | --- |
| `$*` | Содержит все позиционные параметры, переданные в скрипт. Параметры начинаются не с нулевого (`$0`), а с первого (`$1`). Если применяется без двойных кавычек (`$*`), каждый позиционный параметр заменяется на отдельное слово. Если указан в двойных кавычках (`"$*"`), будет подставлено одно слово, содержащее все параметры. Они разделяются первым символом зарезервированной переменной `IFS`. |
|  | |
| `$@` | Содержит все позиционные параметры, переданные в скрипт. Параметры начинаются с первого (`$1`). При применении без двойных кавычек и с ними, каждый позиционный параметр заменяется на отдельное слово (как в случае `$*` без кавычек). |
|  | |
| `$1`,`$2`... | Содержит значение соответствующего позиционного параметра. `$1` соответствует первому параметру, `$2` — второму и т.д. Номера указываются в десятичной системе. |
|  | |
| `$?` | Код возврата последней выполненной команды в активном режиме (foreground). Если команды выполнялись в конвейере, параметр хранит код возврата последней из них. |
|  | |
| `$-` | Содержит опции текущего экземпляра интерпретатора. |
|  | |
| `$$` | Идентификатор процесса текущего экземпляра интерпретатора. При подстановке в subshell, возвращает PID вызвавшего его интерпретатора. |
|  | |
| `$!` | Идентификатор процесса PID последней команды, запущенной в фоновом режиме. |
|  | |
| `$0` | Имя текущего командного интерпретатора или выполняемого в данный момент скрипта. |
|  | |

Все рассмотренные специальные параметры доступны в режиме POSIX-совместимости.

### Область видимости

#### Переменные окружения

В любой программе и программной системе переменные разделены по **областям видимости** (scope). Область видимости — это часть программы или системы, в которой имя переменной остаётся связанным с её значением. Другими словами конвертировать имя переменной в её адрес можно только в области видимости этой переменной. За пределами области видимости то же самое имя может быть связано с другой переменной.

Область видимости называется **глобальной** (global scope), если распространяется на всю систему. То есть переменные этой области видимости доступны из любой части программы или системы.

Все зарезервированные переменные Bash находятся в **глобальной области видимости** (global scope). Переменные в этой области видимости называются **переменными окружения** (environment variables). Получается, что все зарезервированные переменные являются переменными окружения. Пользовательские переменные также можно объявлять в глобальной области видимости. Тогда они станут переменными окружения.

Зачем интерпретатор хранит переменные в глобальной области видимости? Дело в том, что в Unix есть специальный набор настроек и переменных. Они влияют на поведение запускаемых пользователем приложений. Например, региональные настройки. Согласно им каждое запущенное приложение адаптирует свой интерфейс. Именно такие настройки передаются через переменные окружения.

Предположим, что один процесс порождает дочерний процесс. В этом случае дочерний процесс копирует все переменные окружения родителя. Таким образом все утилиты и приложения, запущенные из командного интерпретатора, наследуют его переменные окружения. Так глобальные настройки передаются во все запускаемые пользователем программы.

Дочерние процессы могут изменять свои переменные окружения. В результате порождённые ими процессы унаследуют эти изменения. Однако, это никак не отразится на соответствующих переменных родительского процесса.

Чтобы объявить переменную окружения, используйте встроенную команду export. Например:
{line-numbers: false, format: Bash}
```
export BROWSER_PATH="/opt/firefox/bin"
```

Переменную можно сначала объявить, а потом поместить в глобальную область видимости. Например:
{line-numbers: true, format: Bash}
```
BROWSER_PATH="/opt/firefox/bin"
export BROWSER_PATH
```

Переменные окружения можно объявлять и переопределять для каждого запускаемого приложения отдельно. Для этого в команде вызова программы перечислите их имена и значения через пробел. Например, следующим образом:
{line-numbers: false, format: Bash}
```
MOZ_WEBRENDER=1 LANG="en_US.UTF-8" /opt/firefox/bin/firefox
```

Такое решение работает для интерпретатора Bash. Для других интерпретаторов (например, Bourne Shell) придётся использовать утилиту env. Вызовите утилиту, перечислите через пробел переменные окружения и добавьте команду запуска приложения. Например, так:
{line-numbers: false, format: Bash}
```
env MOZ_WEBRENDER=1 LANG="en_US.UTF-8" /opt/firefox/bin/firefox
```

Вызовите утилиту env без параметров. Она выведет все объявленные переменные окружения для текущего экземпляра интерпретатора. Попробуйте получить этот вывод в своём терминале:
{line-numbers: false, format: Bash}
```
env
```

Команда export и утилита env выводят одно и то же, если вызвать их без параметров. Предпочтительней использовать export. Во-первых, вывод команды отсортирован. Во-вторых, все значения переменных заключены в двойные кавычки. Это убережёт вас от ошибки, если в значении переменной встретится перевод строки.

Исторически сложилось так, что имена переменных окружения пишутся буквами в верхнем регистре. Поэтому давать имена локальным переменным в нижнем регистре считается хорошей практикой. Таким образом вы предотвратите случайное использование одной переменной вместо другой.

#### Локальные переменные

Мы познакомились с пользовательскими переменными. В зависимости от способа их объявления они могут быть **локальными** или переменными окружения (глобальными).

Добавить переменную в глобальную область видимости можно одним из следующих способов:

1. Добавить команду export в объявление переменной.

2. Передать переменную при запуске программы. Это можно сделать как с помощью утилиты env, так и без неё.

Если вы не сделали ничего из перечисленного, переменная будет локальной. Она будет доступна только в текущем экземпляре интерпретатора. Говорят, что локальная переменная имеет **ограниченную область видимости** (local scope). При этом никакие дочерние процессы (кроме subshell) её не наследуют.

Рассмотрим пример. Предположим, что вы объявили переменную в окне терминала MSYS2 следующим образом: 
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

Теперь в этом же окне терминала вы можете вывести её значение:
{line-numbers: false, format: Bash}
```
echo "$filename"
```

Та же самая команда отработает корректно, если выполнить её в subshell:
{line-numbers: false, format: Bash}
```
(echo "$filename")
```

Однако, если прочитать значение переменной из дочернего процесса, получится пустое значение. Чтобы запустить дочерний процесс, вызовите новый экземпляр интерпретатора в окне терминала. Например, так:
{line-numbers: false, format: Bash}
```
bash -c 'echo "$filename"'
```

В опции `-c` передаётся команда, которая выполнится дочерним процессом Bash. Аналогичный вызов Bash происходит неявно при запуске скрипта из командного интерпретатора.

Обратите внимание на одинарные кавычки ', в которые мы поместили вызов echo. Они отключают все подстановки для строки в них. У двойных кавычек поведение отличается. Они разрешают только подстановку команд и параметров. Если в нашем вызове `bash` использовать двойные кавычки, то произойдёт подстановка параметров. В результате команда запуска дочернего процесса Bash станет такой:
{line-numbers: false, format: Bash}
```
bash -c "echo README.txt"
```

Это совсем не то, что нам нужно. Мы проверяем, как дочерний процесс прочитает значение локальной переменной. В данном случае родительский процесс уже подставил это значение в вызов `bash`.

При изменении локальной переменной в subshell, её значение в родительском процессе не изменится. Например, в результате следующих команд напечатается строка "README.txt":
{line-numbers: true, format: Bash}
```
filename="README.txt"
(filename="CHANGELOG.txt")
echo "$filename"
```

То есть присвоение переменной `filename` нового значения в subshell никак не отразилось на родительском процессе.

После объявления локальной переменной она попадает в список **переменных оболочки** (shell variables). К ним относятся все локальные переменные и переменные окружения, доступные в текущем экземпляре интерпретатора. Их можно вывести встроенной командой set, если запустить её без параметров. Попробуйте найти нашу переменную `filename` следующим образом:
{line-numbers: false, format: Bash}
```
set | grep filename=
```

В выводе этой команды вы увидите следующую строку:
{line-numbers: false, format: Bash}
```
filename=README.txt
```

Это значит, что переменная `filename` попала в список переменных оболочки.

### Содержимое переменной

#### Типы переменных

В компилируемых языках программирования (например, C) принято использовать [**статическую типизацию**](https://ru.wikipedia.org/wiki/Статическая_типизация). Это означает, что при объявлении переменной указывается способ хранения её значения в памяти. Рассмотрим пример, чтобы лучше понять о чём речь.

Предположим, что вы объявляете переменную с именем `number`. В объявлении обязательно надо указать её тип. Например, целое беззнаковое (положительное) число размером два байта. В результате на эту переменную в памяти будет отведено ровно два байта. Далее вы присваиваете переменной значение 203 или 0xCB в шестнадцатеричной системе. В памяти это значение сохранится в следующем виде:
{line-numbers: false, format: Bash}
```
00 CB
```

I> На самом деле в памяти современного компьютера вся информация хранится в двоичном виде. Вместо двоичного мы используем шестнадцатеричный формат для наглядности.

Чтобы хранить значение 203, достаточно одного байта. Но при объявлении переменной мы зарезервировали два. Неиспользуемый байт в нашем случае останется равным нулю. Во всей области видимости переменной `number` никто не сможет использовать этот байт. Если переменная находится в глобальной области видимости, на протяжении работы программы этот байт будет зарезервирован и не использован.

Если переменной присвоить значение 14037 или 0x36D5, в отведённую ей область памяти запишутся следующие два байта:
{line-numbers: false, format: Bash}
```
36 D5
```

I> [**Порядок байтов**](https://ru.wikipedia.org/wiki/Порядок_байтов) при хранении чисел в памяти определяется свойствами CPU. В нашем примере порядок байтов от старшего к младшему. Альтернативный порядок — от младшего к старшему.

Теперь предположим, что в переменной нужно сохранить значение 107981 или 0x1A5CD. Это число не помещается в два байта. Размер переменной определён при её объявлении и не может быть автоматически расширен. Поэтому записываемое значение будет обрезано до двух байтов. В результате в память окажется следующее:
{line-numbers: false, format: Bash}
```
A5 CD
```

Старшая единица была отброшена. Теперь если вы прочитаете значение переменной `number`, то получите 42445 или 0xA5CD. Другими словами записанное в `number` число 107981 потеряно и его невозможно восстановить. Эта проблема называется [**переполнением**](https://ru.wikipedia.org/wiki/Целочисленное_переполнение).

Рассмотрим другой пример статической типизации. Предположим, что вам нужно сохранить имя пользователя в переменной `username`. Для этого вы объявляете переменную строкового типа. Во многих компилируемых языках программирования при объявлении строки надо указать её допустимую длину. Для примера длина составляет десять символов. После объявления переменной вы присваиваете ей значение "Alice" в ASCII-кодировке. Если вы используете компилятор языка C, строка будет сохранена в памяти так:
{line-numbers: false, format: Bash}
```
41 6C 69 63 65 00 00 00 00 00
```

I> Вы можете проверить ASCII-коды букв в шестнадцатеричной системе по [таблице](https://ru.wikipedia.org/wiki/ASCII).

Для хранения этой строки было бы достаточно шести байтов: пять для каждой буквы плюс один для нуль-терминатора (00) на конце. Однако, мы зарезервировали десять байтов, поэтому неиспользуемая память будет заполнена нулями или случайными значениями.

[**Динамическая типизация**](https://ru.wikipedia.org/wiki/Динамическая_типизация) — это альтернатива статической типизации. При динамической типизации способ хранения переменной выбирается иначе. Это происходит не в момент объявления переменной, а в момент присваивания ей нового значения. При присваивании переменной назначается [**метаинформация**](https://ru.wikipedia.org/wiki/Метаданные) о её текущем типе. Пока программа исполняется, значение переменной и соответствующая метаинформация могут меняться. Таким образом представление переменной в памяти также будет меняться. Динамическая типизация обычно применяется в интерпретируемых языках программирования (например, Python и Bash).

I> Метаинформация — это дополнительная информация о каком-либо объекте или данных. [Библиотечный каталог](https://ru.wikipedia.org/wiki/Библиотечный_каталог) — хороший пример метаинформации. В нём для каждой книги заведена карточка. В карточке указывается автор, название произведения, издательство, год издания и количество страниц.

В языке Bash все [**скалярные переменные**](https://en.wikipedia.org/wiki/Variable_(computer_science)) являются строками. Скалярной называется переменная, которая хранит данные [**примитивного типа**](https://ru.wikipedia.org/wiki/Примитивный_тип). Они являются минимальными строительными блоками из которых собираются данные более сложных [**составных типов**](https://en.wikipedia.org/wiki/Composite_data_type). Как правило, скалярная переменная — это просто синонимом для адреса памяти, по которому хранится её значение.

Теперь рассмотрим, как Bash представляет свои скалярные переменные в памяти. Предположим, что вы сделали следующее объявление:
{line-numbers: false, format: Bash}
```
declare -i number=42
```

В памяти переменная `number` будет сохранена как такая строка:
{line-numbers: false, format: Bash}
```
34 32 00
```

Обратите внимание, что в строго типизированном языке для хранения этого числа было бы достаточно одного байта. Но в Bash нам потребовалось три: по байту для каждого символа (4 и 2) плюс нуль-терминатор на конце.

В Bourne Shell доступны только скалярные переменные. В Bash появились два новых составных типа: индексируемый [**массив**](https://ru.wikipedia.org/wiki/Массив_(тип_данных)) и ассоциативный массив. Первый из них представляет собой пронумерованный набор строк. В нём каждой строке соответствует порядковый номер. Массивы этого типа хранятся в памяти в виде [**связанного списка**](https://ru.wikipedia.org/wiki/Связный_список). Связанный список — это структура данных, состоящая из узлов. Каждый узел содержит данные (в нашем случае строку) и адрес в памяти следующего узла.

Ассоциативный массив устроен сложнее. Он представляет собой набор элементов. Каждый элемент состоит из двух строк. Первая из них называется ключом, а вторая — значением. Чтобы прочитать или записать строку в массив, нужно указать соответствующий ей ключ. Точно так же в индексируемом массиве для доступа к строке указывается её порядковый номер. Очевидно, что под одним номером может храниться только одна строка. Аналогично один ключ в ассоциативном массиве соответствует только одной строке. В памяти такой массив хранится в виде [**хеш-таблицы**](https://ru.wikipedia.org/wiki/Хеш-таблица).

Почему массивы в Bash называются массивами? Ведь фактически они представляют собой связанные списки и хэш-таблицы. Массив — это структура данных, элементы которой хранятся в памяти последовательно друг за другом. У каждого элемента есть порядковый номер, называемый **индексом** или идентификатором. Элементы массивов в Bash хранятся в памяти не последовательно. Значит согласно определению, это не массивы.

Рассмотрим, как элементы настоящего массива хранятся в памяти. Предположим, что нам надо сохранить числа от 5 до 9 в массиве. Каждый его элемент занимает один байт. Тогда размер массива равен пяти байтам. В памяти он будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
05 06 07 08 09
```

Индексы начинаются с нуля. Тогда элемент с порядковым номером ноль равен пяти, а с номером три — восьми. Элементы в памяти следуют друг за другом. Индекс представляет собой смещение в памяти относительно начала массива.

Вернёмся к вопросу о названиях структур данных в Bash. Ответ на него знает только автор языка. Однако, можно сделать предположение. Название "массив" даёт пользователю подсказку о том, как следует работать с этой структурой. Имея опыт в других языках (например, C) пользователь знает, что читать и писать отдельные элементы массива надо по индексу. Поэтому он сможет использовать уже знакомый ему синтаксис языка C в Bash. При этом пользователю совсем необязательно знать, как на самом деле "массив" Bash хранится в памяти.

#### Атрибуты

Bash позволяет указывать дополнительные атрибуты переменной при объявлении. Они определяют её тип, константность и области видимости.

Для указания атрибутов используется встроенная команда `declare`. При вызове без параметров она выводит все объявленные в данный момент переменные: локальные и окружения. По сути то же самое делает команда `set`.

Вы можете вызвать `declare` с опцией `-p`. Тогда помимо имён и значений переменных будут выведены их атрибуты. Можно ограничить вывод команды `declare` только интересующей вас переменной. Для этого передайте её имя в качестве параметра следующим образом:
{line-numbers: false, format: Bash}
```
declare -p PATH
```

Команда `declare` позволяет получить информацию не только об объявленных переменных, но и о доступных вам [**подпрограммах**](https://ru.wikipedia.org/wiki/Функция_(программирование)). В Bash они называются **функциями**. Подпрограмма — это фрагмент программы или самостоятельный блок кода, который выполняет определённую задачу. Например, чтобы получить информацию о функции `quote`, вызовите команду `declare` следующим образом:
{line-numbers: false, format: Bash}
```
declare -f quote
```

I> Функция `quote` заключает переданную ей строку в одинарные кавычки. Если кавычки встречаются в строке, то они будут экранированы. Вызов функции происходит точно так же, как и любой встроенной команды Bash. Например:
{line-numbers: false, format: Bash}
```
quote "this is a 'test' string"
```

Мы рассмотрели опции команды `declare` для получения информации об уже объявленных переменных и функциях. Теперь рассмотрим, как с её помощью устанавливать атрибуты новых переменных. Наиболее часто используемые опции `declare` приведены в таблице 3-7.

{caption: "Таблица 3-7. Атрибуты переменных в Bash", width: "100%"}
| Опция | Значение |
| --- | --- |
| `-a` | Объявленная переменная является индексируемым [**массивом**](https://ru.wikipedia.org/wiki/Массив_(тип_данных)). В этом случае элементы массива доступны по целочисленным номерам. |
|  | |
| `-A` | Объявленная переменная является ассоциативным массивом. В этом случае каждому элементу массива соответствует ключ-строка. |
|  | |
| `-g` | Объявление переменной в глобальной области видимости скрипта. При этом переменная не попадает в окружение. |
|  | |
| `-i` | Объявление целочисленной переменной. Присваиваемое ей значение будет обработано, как арифметическое выражение. |
|  | |
| `-r` | Объявление константы. Это означает, что указанному имени переменной не может быть присвоено другое значение. |
|  | |
| `-x` | Объявление переменной окружения. |

Рассмотрим примеры объявлений с атрибутами. Начнём с целочисленных и строковых переменных. Выполним два следующих объявления:
{line-numbers: true, format: Bash}
```
declare -i sum=11+2
text=11+2
```

В результате первая переменная, объявленная как целочисленная, будет иметь значение 13, то есть суммы чисел 11 и 2. Вторая будет равна тексту "11+2". Обратите внимание, что и `sum`, и `text` хранятся в памяти в виде строк. Таким образом опция `-i` не задаёт тип переменной, а ограничивает её допустимые значения. Если вы попробуете присвоить `sum` строковое значение, она станет равна нулю. Например в результате следующего объявления:
{line-numbers: false, format: Bash}
```
declare -i sum="test"
```

Опция `-i` позволяет выполнять арифметические операции над переменной без подстановки арифметических выражений. Например:
{line-numbers: true, format: Bash}
```
sum=sum+1       # 13 + 1 = 14
sum+=1          # 14 + 1 = 15
sum+=sum+1      # 15 + 15 + 1 = 31
```

Если выполнить те же самые операции со строковой переменной, результат будет отличаться:
{line-numbers: true, format: Bash}
```
text=text+1     # "text+1"
text+=1         # "text+1" + "1" = "text+11"
text+=text+1    # "text+11" + "text" + "1" = "text+11text+1"
```

Вместо арифметических операций над числами произошло добавление суффикса к строке. Чтобы выполнить эти операции корректно над текстовой переменной, нужно применить подстановку:
{line-numbers: true, format: Bash}
```
text=11
text=$(($text + 2))  # 11 + 2 = 13
```

Опция `-r` команды `declare` позволяет объявить переменную константой. Например так:
{line-numbers: false, format: Bash}
```
declare -r filename="README.txt"
```

Теперь Bash вернёт сообщение об ошибке при попытке переобъявить или удалить переменную с именем `filename`. То есть следующие команды завершаться с ошибкой:
{line-numbers: true, format: Bash}
```
filename="123.txt"
unset filename
```

I> Для удаления переменной любого типа, кроме константы, используйте встроенную команду `unset`.

Команда `declare`, вызванная с опцией `-x`, объявляет переменную окружения. То же самое делает команда `export`. Это означает, что следующие два
объявления переменной `BROWSER_PATH` полностью эквивалентны:
{line-numbers: true, format: Bash}
```
export BROWSER_PATH="/opt/firefox/bin"
declare -x BROWSER_PATH="/opt/firefox/bin"
```

Хорошей практикой считается использовать команду `export` вместо `declare -x`. Это улучшает читаемость кода, потому что не приходится вспоминать значения опций `declare`. По этой же причине предпочитайте использовать команду `readonly` вместо `declare -r`. Она делает то же самое, но её проще запомнить.

Обратите внимание, что команда `readonly` объявляет переменную в глобальной области видимости скрипта. Если вы используете `declare -r` в теле функции, будет объявлена локальная переменная, доступная только в функции. В этом случае чтобы добиться такого же эффекта как от `readonly`, используйте опцию `-g`. Например так:
{line-numbers: false, format: Bash}
```
declare -gr filename="README.txt"
```

#### Индексируемые массивы

В Bourne Shell есть только переменные строкового типа. В Bash по просьбам пользователей были добавлены массивы. В каком случае они могут понадобиться и вам?

У строкового типа в Bash есть серьёзное ограничение. Когда вы помещаете в переменную какое-то значение, логически это один элемент. Например, вы сохранили в переменной с именем `files` список файлов, разделённых пробелами. В результате `files` хранит одну строку с точки зрения Bash. Это может привести к ошибкам.

Как мы выяснили, стандарт POSIX разрешает любые символы в именах файлов, кроме нуль-терминатора (NUL). NUL означает конец имени файла. Этот же самый символ в Bash означает конец строки. Следовательно, строковая переменная может содержать NUL не в произвольном месте, а только в конце. К чему это приводит? Если вы сохраняете список имён файлов в строке, у вас нет надёжного способа его восстановить. Любой символ-разделитель, потенциально может встречаться в этих именах.

Надёжная обработка вывода утилиты `ls` невозможна именно из-за проблемы разделителя. `ls` не позволяет разделять имена файлов и каталогов NUL символом в отличие от утилиты `find`. Но никакой другой символ не будет достаточно надёжным. Поэтому следует избегать объявления переменных, подобные следующему:
{line-numbers: false, format: Bash}
```
files=$(ls Documents/*.txt)
```

Массивы были добавлены в Bash для решения этой проблемы. Они позволяют сохранить список логически отдельных элементов и восстановить его в исходном виде. Вместо присваивания переменной вывода утилиты `ls` используйте массив:
{line-numbers: false, format: Bash}
```
declare -a files=(Documents/*.txt)
```

Когда Bash может вывести тип переменной исходя из присваиваемого ей значения, вы можете опустить команду `declare`. Следующее объявление даст тот же самый результат:
{line-numbers: false, format: Bash}
```
files=(Documents/*.txt)
```

Если все элементы массива вам известны, вы можете указать их явно при объявлении:
{line-numbers: false, format: Bash}
```
files=("/usr/share/doc/bash/README" "/usr/share/doc/flex/README.md" "/usr/share/doc/xz/README")
```

В качестве элементов массива можно использовать другие переменные. Например так:
{line-numbers: true, format: Bash}
```
bash_doc="/usr/share/doc/bash/README"
flex_doc="/usr/share/doc/flex/README.md"
xz_doc="/usr/share/doc/xz/README"
files=("$bash_doc" "$flex_doc" "$xz_doc")
```

Также вы можете явно задавать порядковые номера (индексы) для каждого элемента. Например, с учётом объявленных выше переменных `bash_doc` и `flex_doc` можно создать следующий массив `files`:
{line-numbers: false, format: Bash}
```
files=([0]="$bash_doc" [1]="$flex_doc" [5]="/usr/share/doc/xz/README")
```

Обратите внимание на отсутствие пробелов до и после каждого знака равно `=`. Запомните простое правило: в Bash при объявлении переменных пробелы до и после `=` никогда не ставятся.

Вместо объявления всего массива за раз, вы можете устанавливать его элементы по отдельности. Например так:
{line-numbers: true, format: Bash}
```
files[0]="$bash_doc"
files[1]="$flex_doc"
files[5]="/usr/share/doc/xz/README"
```

Наверное, вы обратили внимание, что в последних двух объявлениях массива `files` нумерация индексов идёт не по порядку. Bash допускает массивы с пропусками (sparse arrays). В этом случае может быть полезно вывести только индексы. Для этого поставьте символ `!` перед именем массива следующим образом:
{line-numbers: true, format: Bash}
```
$ echo "${!files[@]}"
0 1 5
```

Вместо индекса элемента в квадратных скобках вы можете указать арифметическое выражение для его вычисления. Например так:
{line-numbers: true, format: Bash}
```
echo "${files[4+1]}"
files[4+1]="/usr/share/doc/xz/README"
```

В арифметическом выражении можно использовать переменные. Причём они не обязательно должны быть объявлены как целочисленные. Например:
{line-numbers: true, format: Bash}
```
i=4
echo "${files[i+1]}"
files[i+1]="/usr/share/doc/xz/README"
```

Если вас интересуют несколько следующих подряд элементов, вы можете подставить их одной командой. Для этого после двоеточия укажите стартовый индекс и число элементов. Например так:
{line-numbers: true, format: Bash}
```
$ echo "${files[@]:1:2}"
/usr/share/doc/flex/README.md /usr/share/doc/xz/README
```

Эта команда выведет два элемента начиная с первого. Обратите внимание, что индексы элементов в данном случае не важны. Мы прочитали имена файлов под номерами 1 и 5.

Bash, начиная с версии 4, предоставляет встроенную команду `readarray` (также известную как `mapfile`). Она позволяет прочитать содержимое текстового файла в массив. Рассмотрим пример её использования.

Предположим, что у нас есть файл с именем `names.txt` и следующим содержимым:
{line-numbers: true, format: Bash}
```
Alice
Bob
Eve
Mallory
```

Чтобы создать массив, каждый элемент которого соответствует строке файла `names.txt`, достаточно выполнить следующую команду:
{line-numbers: false, format: Bash}
```
readarray -t names_array < names.txt
```

В результате содержимое файла будет записано в массив с именем `names_array`.

{caption: "Упражнение 3-3. Объявление массивов", format: text, line-numbers: false}
```
Выполните самостоятельно все рассмотренные нами способы объявления массивов:

1. С помощью команды declare.

2. Без использования команды declare.

3. Все элементы массива подставляются в результате globbing.

4. Все элементы массива указываются явно при объявлении.

5. Каждый элемент массива задаётся отдельно.

6. В качестве элементов массива используются значения объявленных ранее переменных.

7. Элементы массива читаются из текстового файла.

Выведите содержимое массива с помощью команды echo для каждого случая. Убедитесь, что объявления выполнились корректно.
```

Мы научились объявлять индексируемые массивы. Теперь разберёмся, как их использовать. Предположим, что массив `files` содержит список имён файлов. Если вам надо скопировать только первый из них, вызов утилиты `cp` будет выглядеть так:
{line-numbers: false, format: Bash}
```
cp "${files[0]}" ~/Documents
```

W> В Bash, как и в большинстве языков программирования, принято нумеровать элементы массивов и строк с нуля, а не с единицы.

Для доступа к элементу массива используется полная форма подстановки с фигурными скобками. После имени переменной в квадратных скобках указывается номер элемента, который Bash должен подставить. Если вам необходимо подставить все элементы массива, используйте символ `@`. Например так:
{line-numbers: false, format: Bash}
```
cp "${files[@]}" ~/Documents
```

Чтобы получить размер массива, поставьте символ решётка `#` перед его именем. Например:
{line-numbers: false, format: Bash}
```
echo "${#files[@]}"
```

При подстановке элементов массива всегда используйте двойные кавычки, чтобы предотвратить word splitting.

Чтобы удалить элемент массива, используйте встроенную команду `unset`. Например, удаление четвёртого элемента (не забывайте про нумерацию с нуля) выглядит следующим образом:
{line-numbers: false, format: Bash}
```
unset 'files[3]'
```

Обратите внимание на обязательные одинарные кавычки. Они позволят избежать любых подстановок интерпретатора.

С помощью команды `unset` можно также очистить весь массив:
{line-numbers: false, format: Bash}
```
unset files
```

#### Ассоциативные массивы

Мы рассмотрели индексируемые массивы. В них элементами являются строки, а индексами целые положительные числа. Можно сказать, что массивы этого типа позволяют по указанному числу получить соответствующую ему строку.

В Bash версии 4 появился новый тип переменных — ассоциативные массивы. В них в качестве индексов допускаются строки. То есть благодаря такому массиву вы сможете по известной строке получить другую, соответствующую ей. Рассмотрим пример.

Предположим, что вам нужен скрипт для хранения списка своих контактов. У него должна быть возможность добавлять имена людей (для простоты опустим фамилии), а также их email или телефон. Также скрипт должен выводить контактные данные для указанного человека. Вопрос заключается в том, как хранить данные?

Если использовать индексируемый массив, поиск нужного человека будет долгим и неэффективным. Придётся перебирать все элементы друг за другом и проверять хранящиеся в них имена. При совпадении имени выводить соответствующие контактные данные.

Использование ассоциативного массива даст более эффективное решение. В этом случае имя человека будет ключом для поиска. Чтобы получить соответствующие контактные данные, достаточно просто получить элемент массива по ключу. Рассмотрим детали реализации этого решения.

Объявление массива выглядит следующим образом:
{line-numbers: false, format: Bash}
```
declare -A contacts=(["Alice"]="alice@gmail.com" ["Bob"]="(697) 955-5984" ["Eve"]="(245) 317-0117" ["Mallory"]="mallory@hotmail.com")
```

Обратите внимание, что ассоциативный массив всегда должен объявляться через вызов команды `declare` с опцией `-A`. Bash не сможет автоматически вывести его тип, даже если указать в качестве индексов строки. Это значит, что в результате следующего объявления вы получите индексируемый массив, а не ассоциативный:
{line-numbers: false, format: Bash}
```
contacts=(["Alice"]="alice@gmail.com" ["Bob"]="(697) 955-5984" ["Eve"]="(245) 317-0117" ["Mallory"]="mallory@hotmail.com")
```

Проверим, чему равна переменная `contacts` в этом случае:
{line-numbers: true, format: Bash}
```
$ declare -p contacts
declare -a contacts='([0]="mallory@hotmail.com")'
```

Элементы массива можно задавать по отдельности. Например так:
{line-numbers: true, format: Bash}
```
declare -A contacts
contacts["Alice"]="alice@gmail.com"
contacts["Bob"]="(697) 955-5984"
contacts["Eve"]="(245) 317-0117"
contacts["Mallory"]="mallory@hotmail.com"
```

Мы объявили ассоциативный массив. Доступ к его элементам происходит по ключу, как и в индексируемом массиве. В нашем случае ключом является имя пользователя. Чтение элемента выглядит следующим образом:
{line-numbers: true, format: Bash}
```
$ echo "${contacts["Bob"]}"
(697) 955-5984
```

Для вывода всех элементов массива просто укажите в качестве индекса символ `@`:
{line-numbers: true, format: Bash}
```
$ echo "${contacts[@]}"
(697) 955-5984 mallory@hotmail.com alice@gmail.com (245) 317-0117
```

Если вам нужно вывести список всех ключей, поставьте символ `!` перед именем массива:
{line-numbers: true, format: Bash}
```
$ echo "${!contacts[@]}"
Bob Mallory Alice Eve
```

Размер массива выводится с помощью символа решётка `#`:
{line-numbers: true, format: Bash}
```
$ echo "${#contacts[@]}"
4
```

Поместим ассоциативный массив с контактами в скрипт. Тогда пользователь сможет передать имя интересующего его человека через параметр командной строки и получить соответствующий email или телефон. Листинг 3-10 демонстрирует получившийся скрипт.

{caption: "Листинг 3-10. Скрипт для хранения контактов", line-numbers: true, format: Bash}
![`contacts.sh`](code/BashScripting/contacts.sh)

Удалять ассоциативный массив и его элементы можно командой `unset`:
{line-numbers: true, format: Bash}
```
unset contacts
unset 'contacts[Bob]'
```

Подстановка нескольких элементов ассоциативного массива выполняется аналогично индексируемому массиву. Например:
{line-numbers: true, format: Bash}
```
$ echo "${contacts[@]:Bob:2}"
(697) 955-5984 mallory@hotmail.com
```

В этом случае будет подставлено два элемента: соответствующий ключу `Bob` и следующий за ним в памяти. Проблема в том, что порядок следования элементов в памяти не соответствует порядку, в котором вы их присвоили. Индекс каждого элемента рассчитывается [**хеш-функцией**](https://ru.wikipedia.org/wiki/Хеш-функция). На вход она принимает строку-ключ, а на выходе возвращает уникальное целое число. Из-за этой особенности подстановка нескольких элементов ассоциативного массива мало полезна на практике.
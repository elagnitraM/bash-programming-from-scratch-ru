## Переменные и параметры

Мы уже сталкивались с переменными, когда говорили о `PATH`, хранящем список системных путей, и доступе к позиционным параметрам Bash-скрипта по именам `$1`, `$2` и т.д. Теперь рассмотрим тему переменных подробнее.

Что представляет собой переменная в контексте программирования? Это некоторая область памяти (обычно оперативной), в которой хранится значение. В первых языках программирования (например, [**ассемблере**](https://ru.wikipedia.org/wiki/Язык_ассемблера)) обращение к переменным происходит по их адресу. То есть, чтобы записать новое значение или прочитать текущее, вы должны указывать адрес памяти. В 32-разрядных архитектурах длина адреса 4 байта (число от 0 до 4294967295), а в 64-разрядных он в два раза больше. Очевидно, что запоминать и оперировать такими большими числами неудобно. Поэтому современные языки программирования позволяют вместо адресов работать с именами переменных. Эти имена в процессе компиляции или интерпретации программы транслируются в адреса памяти. Таким образом всю работу по "запоминанию" больших чисел берёт на себя компилятор или интерпретатор.

Зачем нужны переменные? Из предыдущих примеров очевидно, что переменные используются для хранения каких-то значений. Обычно при этом преследуется одна из следующих целей:

1. Передать информацию из одной части программы или системы в другую.

2. Сохранить промежуточный результат вычислений для дальнейшего использования.

3. Сохранить текущее состояние программы или системы. Состояние может определять поведение.

4. Задать константное значение, которое будет многократно использоваться в дальнейшем.

Для каждой из целей в языках программирования вводится специальный тип переменной. Язык Bash не является исключением.

### Классификация переменных

Интерпретатор Bash может работать в двух основных режимах: интерактивном (командная оболочка) и неинтерактивном (исполнение скриптов). В каждом из них переменные решают сходные задачи, но контексты их использования различаются. Из-за этого в Bash больше признаков для классификации переменных, чем в большинстве других языков.

Для удобства рассмотрения сделаем сразу небольшое упрощение в терминологии, которое в общем не совсем правильно. При обсуждении скриптов, будем использовать термин "переменная" (variable). Когда же обсуждается командная оболочка и аргументы командной строки, будем использовать термин "параметр" (parameter). Это позволит избежать путаницы. В английской литературе эти термины часто используются как синонимы.

Какие же классификации переменных есть в Bash? Таблица 3-1 демонстрирует их в кратком виде.

{caption: "Таблица 3-1. Классификация переменных в Bash", width: "100%"}
| Признак классификации | Типы | Определение | Примеры |
| --- | --- | --- | --- |
| Механизм установки | Пользовательские переменные | Устанавливаются пользователем. | `filename="README.txt" ; echo "$filename"` |
|  | | | |
|                    | Зарезервированные (системные) переменные | Устанавливаются интерпретатором и нужны для его корректной работы. | `echo "$PATH"` |
|  | | | |
|                    | Специальные параметры | Устанавливаются интерпретатором и доступны только для чтения. | `echo "$?"` |
|  | | | |
| [Область видимости](https://ru.wikipedia.org/wiki/Область_видимости) | Переменные окружения (или глобальные) | Доступны в любом экземпляре запущенного интерпретатора. Выводятся утилитой `env`, запущенной без параметров. | `echo "$PATH"` |
|  | | | |
|                     | Локальные переменные | Доступны только в конкретном экземпляре запущенного интерпретатора. | `filename="README.txt" ; echo "$filename"` |
|  | | | |
| Содержимое | Строка | Хранит строку. | `filename="README.txt"` |
|  | | | |
|            | Число | Хранит целое число. | `declare -i number=10/2 ; echo "$number"` |
|  | | | |
|            | Индексируемый массив | Хранит нумерованный список строк. | `cities=("London" "New York" "Berlin") ; echo "${cities[1]}"` |
|  | | | `cities[0]="London" ; cities[1]="New York" ; cities[2]="Berlin" ; echo "${cities[1]}"` |
|  | | | |
|            | [**Ассоциативный массив**](https://ru.wikipedia.org/wiki/Ассоциативный_массив) | Структура данных, каждый элемент которой представляет собой пару ключ-значение. Ключём и значением являются строки. | `declare -A cities=( ["Alice"]="London" ["Bob"]="New York" ["Eve"]="Berlin" ) ; echo "${cities[Bob]}"` |
| Возможность изменения | Константны | Не могут быть удалены. Хранят значения, которые нельзя переопределить. | `readonly CONSTANT="ABC" ; echo "$CONSTANT"` |
|                     | | | `declare -r CONSTANT="ABC" ; echo "$CONSTANT"` |
|  | | | |
|                     | Переменные | Могут быть удалены. Их значения можно переопределить. | `filename="README.txt"` |

Рассмотрим каждый из приведённых типов переменных.

### Механизм установки

#### Пользовательские переменные

Начнём наше знакомство с пользовательских переменных. Как следует из названия, они задаются пользователем для хранения промежуточных результатов работы скрипта, его состояния или константных значений.

Чтобы объявить переменную, укажите её имя, знак равно и значение без пробелов. Например, следующая строка объявляет переменную с именем `filename`, значение которой равно `README.txt`:
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

Обратите внимание, что пробел до и после знака равно не ставится. То есть следующее объявление завершится с ошибкой:
{line-numbers: false, format: Bash}
```
filename = "README.txt"
```

Bash обработает такую строку как вызов команды с именем `filename` и двумя параметрами: `=` и `"README.txt"`

В именах переменных можно использовать только символы латинского алфавита, числа и знак подчёркивания. Имя не должно начинаться с числа. Регистр букв важен, т.е. `filename` и `FILENAME` — это две разные переменные.

При объявлении переменной `filename` в памяти процесса интерпретатора выделяется область памяти, в которой сохраняется строка `README.txt`. Чтобы её прочитать, следует обратиться к ней по имени. Но интерпретатор должен понять, что речь идёт не о команде или строке, а о переменной. Чтобы сообщить ему эту информацию, необходимо поставить знак доллара `$` перед именем:
{line-numbers: false, format: Bash}
```
$filename
```

Что означает знак доллара? Встретив его в команде, Bash запускает механизм подстановки переменных (**parameter expansion**). Этот механизм заменяет все вхождения имени переменной на её значение. Рассмотрим следующую команду:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

После подстановки она будет выглядеть так:
{line-numbers: false, format: Bash}
```
cp README.txt ~
```

Учтите, что интерпретатор выполняет и другие подстановки. Невнимательное отношение к их порядку может привести к ошибкам. Рассмотрим пример. Предположим, что нам нужно оперировать файлом, в имени которого встречается пробел. Тогда объявление переменной `filename` с его именем будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
filename="my file.txt"
```

Далее эта переменная используется в вызове утилиты `cp`, как и раньше:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

После подстановки переменных Bash выполняет word splitting. В результате получится следующий вызов утилиты `cp`:
{line-numbers: false, format: Bash}
```
cp my file.txt ~
```

Такой вызов завершится с ошибкой, потому что вместо одного параметра с именем файла, мы получили два: `my` и `file.txt`. Таких файлов не существует.

Проблема возникнет и в том случае, если в значении переменной встречается символ подстановки. Например:
{line-numbers: false, format: Bash}
```
filename="*file.txt"
rm $filename
```

В результате этой команды будут удалены все файлы, заканчивающиеся на `file.txt`. В таком поведении виноват механизм globbing, который также выполняется после подстановки переменных. Из-за него в утилиту `rm` будут переданы все файлы из текущего каталога, имена которых соответствуют шаблону поиска `*file.txt`. После всех подстановок мы можем получить совершенно неожиданный вызов `rm`. Например такой:
{line-numbers: false, format: Bash}
```
rm report_file.txt myfile.txt msg_file.txt
```

Чтобы избежать нежелательных подстановок Bash, заключайте все обращения к переменным в двойные кавычки `"`. Например, следующим образом:
{line-numbers: true, format: Bash}
```
filename1="my file.txt"
cp "$filename1" ~

filename2="*file.txt"
rm "$filename2"
```

Благодаря этому, значение переменной будет подставлено без дальнейших изменений:
{line-numbers: false, format: Bash}
```
cp "my file.txt" ~
rm "*file.txt"
```

Мы уже познакомились с несколькими [подстановками](http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Expansions), выполняемыми Bash. В таблице 3-2 приведены остальные, а также указан их порядок выполнения. 

{caption: "Таблица 3-2. Подстановки Bash", width: "100%"}
| Порядок выполнения | Подстановка | Комментарий | Пример |
| --- | --- | --- | --- |
| 1 | Brace Expansion | Подстановка фигурных скобок `{` и `}`. | `echo a{d,c,b}e` |
|  | | | |
| 2 | Tilde Expansion | Подстановка символа тильда `~`. | `cd ~` |
|  | | | |
| 3 | Parameter Expansion | Подстановка параметров и переменных. | `echo "$PATH"` |
|  | | | |
| 4 | Arithmetic Expansion | Подстановка вместо арифметических выражений их значений. | `echo $((4+3))` |
|  | | | |
| 5 | Command Substitution | Подстановка вместо команды её вывода. | `echo $(< README.txt)` |
|  | | | |
| 6 | Process Substitution | Подстановка вместо команды её вывода. В отличие от Command Substitution выполняется [асинхронно](https://ru.wikipedia.org/wiki/Асинхронность#Асинхронность_в_информатике), а ввод и вывод команды привязаны к временному файлу. | `diff <(sort file1.txt) <(sort file2.txt)` |
|  | | | |
| 7 | Word Splitting | Разделение аргументов командной строки на слова и передача их в качестве отдельных параметров. | `cp file1.txt file2.txt ~` |
|  | | | |
| 8 | Filename Expansion (globbing) | Подстановка имён файлов вместо шаблонов. | `rm ~/delete/*` |
|  | | | |
| 9 | Quote Removal | Удаление всех неэкранированных символов `\`, `'` и `"`, которые не были получены в результате одной из предыдущих подстановок | `cp "my file.txt" ~` |

{caption: "Упражнение 3-1. Тестирование подстановок Bash", format: text, line-numbers: false}
```
Выполните примеры каждой из подстановок Bash, приведённые в таблице 3-2. Удостоверьтесь, что поняли как был получен результат в каждом случае. Придумайте свои примеры.
```

Запись имени переменной со знаком `$` в начале является сокращенной формой подстановки. В полном виде она выглядит так:
{line-numbers: false, format: Bash}
```
${filename}
```

Такая форма поможет избежать неоднозначности, если сразу за именем переменной следует текст. Например в следующем случае:
{line-numbers: true, format: Bash}
```
prefix="my"
name="file.txt"
cp "$prefix_$name" ~
```

Здесь при подстановке параметров интерпретатор будет искать переменную с именем `prefix_`. То есть он приклеит символ подчёркивания к имени переменной. Чтобы избежать этой проблемы можно воспользоваться полной формой записи:
{line-numbers: false, format: Bash}
```
cp "${prefix}_${name}" ~
```

Альтернативное решение — заключить каждое имя переменной в кавычки:
{line-numbers: false, format: Bash}
```
cp "$prefix"_"$name" ~
```

Устранение неоднозначности — не единственный случай, когда пригодится полная форма записи подстановки. Также она будет полезна, когда переменная не определена. В этом случае вместо неё можно подставить некоторое значение по умолчанию. Например:
{line-numbers: false, format: Bash}
```
cp file.txt "${directory:-~}"
```

При обработке этой команды Bash проверит, определена ли переменная с именем `directory` и имеет ли она непустое значение. Если это так, произойдёт обычная подстановка. В противном случае будет использовано значение, следующее за символом `-`. В нашем примере это домашний каталог пользователя `~`.

Все варианты задания значения по умолчанию при подстановке приведены в таблице 3-3.

{caption: "Таблица 3-3. Задание значения по умолчанию при подстановке", width: "100%"}
| Форма записи | Описание|
| --- | --- |
| `${parameter:-word}` | Если переменная `parameter` не объявлена или имеет пустое значение, будет подставлено значение по умолчанию `word`. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:=word}` | Если переменная не объявлена или имеет пустое значение, ей будет присвоено значение по умолчанию, которое затем будет подставлено. В противном случае подставляется значение переменной. Переопределение позиционных и специальных параметров таким способом не допустимо. |
|  | |
| `${parameter:?word}` | Если переменная не объявлена или имеет пустое значение, значение по умолчанию будет выведено в стандартный поток ошибок. После этого выполнение скрипта будет завершено с кодом возврата отличным от 0. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:+word}` | Если переменная не объявлена или имеет пустое значение, подстановки не будет. В противном случае подставляется значение по умолчанию. |

{caption: "Упражнение 3-2. Использование полной формы подстановки параметров", format: text, line-numbers: false}
```
Напишите скрипт, который ищет файлы с расширением TXT в текущем каталоге, исключая его подкаталоги. Все найденные файлы должны быть скопированы или перемещены в домашний каталог пользователя. При вызове скрипта требуемая операция передаётся в первом позиционном параметре. Если она не указана, выполняется копирование.
```

#### Зарезервированные переменные

Кроме пользователя переменные может объявлять сам интерпретатор. В этом случае они называются **зарезервированными** (reserved) или **переменными оболочки** (shell variables). Как правило, интерпретатор присваивает им значение по умолчанию, которое в некоторых случаях может меняться пользователем.

Большая часть зарезервированных переменных используется для передачи информации в запускаемые из командного интерпретатора приложения. Некоторые из них нужны для хранения текущего состояния самого интерпретатора.

Зарезервированные переменные Bash делятся на две группы:

1. Переменные Bourne Shell.
2. Переменные Bash.

Первая группа была унаследована из Bourne Shell и нужна для обеспечения POSIX-совместимости. Наиболее часто используемые из этих переменных представлены в таблице 3-4.

{caption: "Таблица 3-4. Зарезервированные переменные Bourne Shell", width: "100%"}
| Имя | Значение |
| --- | --- |
| `HOME` | Домашний каталог текущего пользователя. Значение переменной используется при вызове встроенной команды `cd` без параметров и подстановке символа тильда `~`. |
|  | |
| `IFS` | Список следующих друг за другом символов, которые используются в качестве разделителей при обработке вводимых строк (в том числе и для word splitting). По умолчанию это символы пробела, [табуляции](https://ru.wikipedia.org/wiki/Табуляция) и перевода строки. |
|  | |
| `PATH` | Список путей, разделённый двоеточиями, по которым интерпретатор ищет вызываемые утилиты и программы. |
|  | |
| `PS1` | Приглашение командной строки. Может состоять из набора [управляющих символов](https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html#Controlling-the-Prompt), которые будут заменены перед выводом на конкретные значения (например, имя текущего пользователя). |

В Bash были добавлены новые зарезервированные переменные. В таблице 3-5 приведены наиболее часто используемые из них.

{caption: "Таблица 3-5. Зарезервированные переменные Bash", width: "100%"}
| Имя | Значение |
| --- | --- |
| `BASH` | Полный путь, который использовался для запуска текущего экземпляра Bash. |
|  | |
| `BASHOPTS` | Список [дополнительных опций](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin) текущего экземпляра Bash, разделённых двоеточиями. |
|  | |
| `BASH_VERSION` | Номер версии текущего экземпляра Bash. |
|  | |
| `GROUPS` | Список групп, к которым относится текущий пользователь. |
|  | |
| `HISTCMD` | Номер текущей команды в истории команд. |
|  | |
| `HISTFILE` | Файл, в котором сохраняется история команд. Значение по умолчанию равно `~/.bash_history`. |
|  | |
| `HISTFILESIZE` | Максимально допустимое число строк в файле истории команд. Значение по умолчанию 500. |
|  | |
| `HISTSIZE` | Максимально допустимое число команд в файле истории команд. Значение по умолчанию 500. |
|  | |
| `HOSTNAME` | Имя текущего компьютера как узла вычислительной сети. |
|  | |
| `HOSTTYPE` | Строка, описывающая аппаратную платформу, на которой запущен Bash. |
|  | |
| `LANG` | [Региональные настройки](https://ru.wikipedia.org/wiki/Региональные_настройки_(программирование)) пользовательского интерфейса. Некоторые из них переопределяться переменными `LC_ALL`, `LC_COLLATE`, `LC_CTYPE`, `LC_MESSAGES`, `LC_NUMERIC`, `LC_TYPE`. |
|  | |
| `MACHTYPE` | Строка, полностью описывающая систему, на которой запущен Bash. Включает в себя информацию из `HOSTTYPE` и `OSTYPE`. |
|  | |
| `OLDPWD` | Предыдущий рабочий каталог, который был установлен встроенной командой `cd`. |
|  | |
| `OSTYPE` | Строка, описывающая ОС, на которой запущен Bash. |
|  | |
| `POSIXLY_CORRECT` | Если эта переменная определена, Bash работает в режиме [POSIX-совместимости](https://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html#Bash-POSIX-Mode). |
|  | |
| `PWD` | Текущий рабочий каталог, который был установлен встроенной командой `cd`. |
|  | |
| `RANDOM` | Каждый раз при чтении этой переменной возвращается случайное число от 0 до 32767. В случае записи переменной назначается инициализирующее число ([seed](https://en.wikipedia.org/wiki/Random_seed)) для [генератора псевдослучайных чисел](https://ru.wikipedia.org/wiki/Генератор_псевдослучайных_чисел). |
|  | |
| `SECONDS` | Количество секунд, прошедших с запуска текущего экземпляра Bash. |
|  | |
| `SHELL` | Полный путь к командному интерпретатору, установленному для текущего пользователя. |
|  | |
| `SHELLOPTS` | Список [дополнительных опций](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin) комндного интерпретатора, разделённых двоеточиями. |
|  | |
| `SHLVL` | Уровень вложенности текущего экземпляра Bash. Эта переменная увеличивается на единицу каждый раз, когда вы запускаете Bash из командного интерпретатора. |
|  | |
| `UID` | Идентификатор текущего пользователя. |

Обратите внимание, что есть несколько механизмов работы с зарезервированными переменными:

1. При запуске интерпретатор назначает переменной значение. В течении всей сессии оно остаётся неизменным. Пользователь может его прочитать, но не изменить. Примеры: `BASHOPTS`, `GROUPS`, `SHELLOPTS`, `UID`.

2. При запуске интерпретатор назначает переменной значение по умолчанию. Оно меняется в результате выполнения пользователем команд или иных событий. Некоторые переменные могут быть изменены непосредственно, хоть и не предназначены для этого. Примеры: `HISTCMD`, `OLDPWD`, `PWD`, `SECONDS`, `SHLVL`.

3. При запуске интерпретатор назначает переменной значение по умолчанию. Оно может быть изменено только непосредственно пользователем. Примеры: `HISTFILESIZE`, `HISTSIZE`

#### Специальные параметры

Специальные параметры всегда назначаются интерпретатором. Некоторые из них хранят состояние его запущенного экземпляра (например, PID). Другие служат для передачи параметров командной строки в вызываемые утилиты и приложения, а также чтения их кода возврата. Все позиционные параметры относятся к специальным.

Наиболее часто используемые специальные параметры представлены в таблице 3-6.

{caption: "Таблица 3-6. Специальные параметры Bash", width: "100%"}
| Имя | Значение |
| --- | --- |
| `$*` | Используется для подстановки позиционных параметров, начиная с первого (`$1`). Если применяется без двойных кавычек, каждый позиционный параметр заменяется на отдельное слово. Если указан в двойных кавычках, вместо него будет подставлено одно слово, содержащее все параметры. Они будут разделены первым символом зарезервированной переменной `IFS`. |
|  | |
| `$@` | Используется для подстановки позиционных параметров, начиная с первого (`$1`). При применении без двойных кавычек и с ними, каждый позиционный параметр заменяется на отдельное слово (как в случае `$*` без кавычек). |
|  | |
| `$1`,`$2`... | Используется для подстановки позиционного параметра, порядковый номер которого в десятичной системе соответствует указанному. |
|  | |
| `$?` | Подстановка кода возврата последней выполненной команды в активном режиме (foreground). Если команды выполнялись в конвейере, параметр хранит код возврата последней из них. |
|  | |
| `$-` | Подстановка опций текущего экземпляра интерпретатора. |
|  | |
| `$$` | Подстановка идентификатора процесса текущего экземпляра интерпретатора. В случае подстановки в subshell, запущенного в скобках `()`, возвращает PID вызвавшего его интерпретатора. |
|  | |
| `$!` | Подстановка идентификатора процесса последней команды, запущенной в фоновом режиме. |
|  | |
| `$0` | Подстановка имени текущего командного интерпретатора или выполняемого в данный момент скрипта. |
|  | |

Все рассмотренные нами специальные параметры доступны в режиме POSIX-совместимости.

### Область видимости

#### Переменные окружения

Все зарезервированные переменные Bash находятся в **глобальной области видимости** и называются **переменными окружения**.

Сначала разберёмся с тем, что означает **область видимости**? Это часть программы или в нашем случае системы, в которой имя переменной остаётся связанным с её значением. Другими словами имя корректно конвертируется в адрес памяти, по которому хранится значение переменной. За пределами области видимости то же самое имя может быть связано уже с другой переменной.

Область видимости называется глобальной, если распространяется на всю систему. Другими словами переменные этой области видимости доступны из любой части программы или системы.

Зачем интерпретатору понадобилось хранить переменные в глобальной области видимости? Дело в том, что в Unix есть набор настроек и переменных, которые влияют на поведение каждого приложения, запускаемого пользователем. Например, региональные настройки. Учитывая их, каждое запущенное приложение может адаптировать свой интерфейс. Именно для таких целей используются переменные окружения.

Когда один процесс порождает другой, дочерний процесс наследует все переменные окружения от родительского. В данном случае наследование означает создание собственной копии. Таким образом все утилиты и приложения, запущенные из командного интерпретатора, по умолчанию наследуют его переменные окружения. Это позволяет решить проблему передачи глобальных параметров во все приложения, запускаемые пользователем.

Важно заметить, что дочерние процессы могут изменять свои переменные окружения. В результате порождённые ими процессы будут наследовать эти изменения. Однако, это никак не отразится на соответствующих переменных родительского процесса.

Для создания новой переменной окружения используется зарезервированное слово `export`. Пример объявления такой переменной:
{line-numbers: false, format: Bash}
```
export BROWSER_PATH="/opt/firefox/bin"
```

Также вы можете поместить переменную в окружение после её объявления:
{line-numbers: true, format: Bash}
```
BROWSER_PATH="/opt/firefox/bin"
export BROWSER_PATH
```

Можно добавить или переопределить переменные окружения для одного конкретного запускаемого приложения. Если вы работаете в Bash, просто перечислите их имена и значения, разделённые пробелом, перед вызовом программы. Например, следующим образом:
{line-numbers: false, format: Bash}
```
MOZ_WEBRENDER=1 LANG="en_US.UTF-8" /opt/firefox/bin/firefox
```

Для других интерпретаторов (например, Bourne Shell) вам придётся использовать утилиту `env`. Вызовите утилиту, перечислите через пробел переменные окружения и вызовите нужное вам приложение. Например так:
{line-numbers: false, format: Bash}
```
env MOZ_WEBRENDER=1 LANG="en_US.UTF-8" /opt/firefox/bin/firefox
```

Если вызвать утилиту `env` без параметров, она выведет список всех определённых в данный момент переменных окружения текущего экземпляра интерпретатора. Попробуйте выполнить следующую команду в своём терминале:
{line-numbers: false, format: Bash}
```
env
```

Вызов встроенной команды `export` без параметров делает то же самое, что и `env`. В большинстве случаев предпочтительней использовать `export`. Во-первых, вывод этой команды отсортирован. Во-вторых, все значения переменных заключены в двойные кавычки, что позволяет избежать неоднозначностей, когда в значении встречается перевод строки.

Исторически сложилось так, что имена переменных окружения пишутся буквами в верхнем регистре. Поэтому хорошей практикой считается давать имена всем локальным переменным в нижнем регистре. Таким образом вы гарантированно избежите случайного использования одной переменной вместо другой.

#### Локальные переменные

Мы рассмотрели примеры объявления пользовательских переменных. Они могут быть как локальными, так и переменными окружения.

Если вы не использовали служебное слово `export` при объявлении переменной и не передавали её при вызове приложения, то она будет локальной. Это означает, что переменная будет доступна только в текущем экземпляре интерпретатора. Говорят, что она имеет **ограниченную область видимости**. При этом никакие дочерние процессы (кроме subshell) её не наследуют.

Рассмотрим пример. Предположим, что вы объявили переменную в окне терминала MSYS следующим образом: 
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

Теперь в этом же окне терминала вы можете распечатать её значение:
{line-numbers: false, format: Bash}
```
echo "$filename"
```

Та же самая команда отработает корректно, если выполнить её в subshell:
{line-numbers: false, format: Bash}
```
(echo "$filename")
```

Однако, если вы попытаетесь получить доступ к переменной из дочернего процесса, то получите пустое значение. Чтобы это сделать, создайте и выполните скрипт с выводом переменной через `echo` или запустите новый экземпляр интерпретатора в окне терминала. Например так:
{line-numbers: false, format: Bash}
```
bash -c 'echo "$filename"'
```

В опции `-c` передаётся команда, которая будет выполнена запущенным экземпляром `bash`. Аналогичный вызов `bash` происходит неявно при запуске скрипта из командного интерпретатора.

Обратите внимание на одинарные кавычки `'`, в которые мы поместили команду `echo`. Они отключают все подстановки для заключённой в них строки. В отличие от них двойные кавычки разрешают подстановки команд и параметров. Если в нашем вызове `bash` использовать двойные кавычки, то в результате подстановки параметров, получим следующее:
{line-numbers: false, format: Bash}
```
bash -c "echo README.txt"
```

Тогда значение переменной `filename` корректно напечатается из дочернего процесса `bash`. Но причина этого не в том, что переменная была передана в дочерний процесс, а в том что её значение попало в параметр команды вызова `bash`.

При изменении локальной переменной в subshell, её значение в родительском процессе не изменится. Например, в результате следующих команд напечатается строка "README.txt":
{line-numbers: true, format: Bash}
```
filename="README.txt"
(filename="CHANGELOG.txt")
echo "$filename"
```

То есть присвоение переменной `filename` нового значения в subshell никак не отразилось на родительском процессе.

После объявления локальной переменной она попадает в список **переменных оболочки** (shell variables). К ним относятся все локальные и переменные окружения, доступные в текущем экземпляре интерпретатора. Их можно вывести встроенной командой `set`, вызванной без параметров. Попробуйте найти нашу переменную `filename` следующим образом:
{line-numbers: false, format: Bash}
```
set | grep filename=
```

В выводе этой команды вы увидите следующую строчку:
{line-numbers: false, format: Bash}
```
filename=README.txt
```

### Содержимое переменной

#### Типы переменных

В компилируемых языках программирования (например, C) обычно используется [**статическая типизация**](https://ru.wikipedia.org/wiki/Статическая_типизация). Это означает, что способ хранения переменной в памяти определяется в момент её объявления. Рассмотрим конкретный пример, чтобы лучше разобраться в этом подходе.

Предположим, что вы объявляете переменную с именем `number` и указываете её тип — целое беззнаковое (положительное) число размером два байта. В результате на эту переменную в памяти будет отведено ровно два байта. Далее вы присваиваете переменной значение 203 или 0xCB в шестнадцатеричной системе. В памяти она будет храниться в следующем виде:
{line-numbers: false, format: Bash}
```
00 CB
```

I> На самом деле в памяти современного компьютера информация хранится в двоичном виде. В нашем примере используется шестнадцатеричный формат для наглядности.

Обратите внимание, что для хранения значения 203 было бы достаточно одного байта. Но при объявлении переменной было зарезервировано два. Поэтому первый байт, который в нашем случае равен нулю, не будет использоваться никакими другими переменными на протяжении всей работы программы.

Если вы решаете присвоить переменной значение 14037 или 0x36D5, в отведённую переменной память будут записаны следующие два байта:
{line-numbers: false, format: Bash}
```
36 D5
```

I> [**Порядок байтов**](https://ru.wikipedia.org/wiki/Порядок_байтов) при хранении чисел в памяти определяется свойствами CPU. В нашем примере мы использовали порядок от старшего к младшему. Альтернатива ему — от младшего к старшему.

Теперь предположим, что вам нужно сохранить значение 107981 или 0x1A5CD, которое не помещается в два байта. В этом случае отведённая под переменную память не будет расширена до необходимого размера. Вместо этого записываемое значение будет обрезано до двух байтов. В результате в нашем случае будет записано следующее:
{line-numbers: false, format: Bash}
```
A5 CD
```

Старшая единица была отброшена. Теперь если вы прочитаете значение переменной `number`, то получите 42445 или 0xA5CD. Другими словами, записанное в `number` число 107981 потеряно и его невозможно восстановить. Эта проблема называется [**переполнением**](https://ru.wikipedia.org/wiki/Целочисленное_переполнение).

Рассмотрим другой пример статической типизации. Предположим, что вам нужно сохранить имя пользователя в переменной `username`. Для этого вы объявляете переменную строкового типа. Во многих компилируемых языках программирования необходимо указать максимально допустимую длину строки при её объявлении. Предположим, в нашем случае длина составляет десять символов. Затем вы присваиваете переменной значение `Alice` в ASCII-кодировке. Тогда если вы используете компилятор языка C, строка будет сохранена в памяти так:
{line-numbers: false, format: Bash}
```
41 6C 69 63 65 00 00 00 00 00
```

I> Вы можете проверить ASCII-коды букв в шестнадцатеричной системе по [таблице](https://ru.wikipedia.org/wiki/ASCII).

Для хранения этой строки было бы достаточно шести байтов: пять байтов для каждой буквы плюс один для нуль-терминатора на конце, который равен 00. Однако, мы зарезервировали десять байтов, поэтому неиспользуемая память может быть заполнена нулями или случайными значениями.

[**Динамическая типизация**](https://ru.wikipedia.org/wiki/Динамическая_типизация) является альтернативным подходом. В нём способ хранения переменной определяется не в момент её объявления, а в момент присваивания ей нового значения. Вместе с этим присваиванием переменной назначается [**метаинформация**](https://ru.wikipedia.org/wiki/Метаданные) о её текущем типе. В ходе исполнения программы значение и соответствующая ему метаинформация могут меняться. Таким образом представление переменной в памяти также будет меняться. Динамическая типизация обычно применяется в интерпретируемых языках программирования (например, Python).

I> Метаинформация — это дополнительная информация о каком-либо объекте или данных. [Библиотечный каталог](https://ru.wikipedia.org/wiki/Библиотечный_каталог) является хорошим примером метаинформации. В нём для каждой книги заведена карточка. В ней обычно указывается автор, название произведения, издательство, год издания и количество страниц.

В языке Bash все [**скалярные переменные**](https://en.wikipedia.org/wiki/Variable_(computer_science)) являются строками. Что это значит? Прежде всего уточним определение скалярной переменной. Под этим термином понимаются данные [**примитивного типа**](https://ru.wikipedia.org/wiki/Примитивный_тип). В языке программирования они являются минимальными строительными блоками из которых собираются данные более сложных [**составных типов**](https://en.wikipedia.org/wiki/Composite_data_type). Как правило, скалярная переменная является просто синонимом для адреса памяти, по которому хранится её значение.

Теперь рассмотрим, как Bash представляет свои скалярные переменные в памяти. Предположим, что вы сделали следующее объявление:
{line-numbers: false, format: Bash}
```
declare -i number=42
```

В памяти переменная `number` будет сохранена как строка следующим образом:
{line-numbers: false, format: Bash}
```
34 32 00
```

Обратите внимание, что в строго типизированном языке для хранения этого числа было бы достаточно одного байта. Но в Bash нам потребовалось три: по байту для каждого числа плюс нуль-терминатор на конце.

В Bourne Shell доступны только скалярные переменные. В Bash было добавлено два новых составных типа: индексируемый и ассоциативный [**массивы**](https://ru.wikipedia.org/wiki/Массив_(тип_данных)). Первый из них представляет собой пронумерованный набор строк. В нём каждой строке соответствует порядковый номер. Массивы этого типа хранятся в памяти в виде [**связанного списка**](https://ru.wikipedia.org/wiki/Связный_список). Связанный список — это структура данных, состоящая их узлов. Каждый из них содержит данные (в нашем случае строку) и адрес в памяти следующего узла.

Ассоциативный массив устроен сложнее. Он представляет собой набор элементов. Каждый элемент состоит из двух строк. Первая из них называется ключом, а вторая — значением. Чтобы прочитать или записать строку в массив, вам нужно указать соответствующий ей ключ. Точно так же в индексируемом массиве для доступа к строке следует указать её порядковый номер. Очевидно, что под одним номером может хранится только одна строка. Аналогично один ключ в ассоциативном массиве может соответствовать только одной строке. В памяти эти массивы хранятся в виде [**хеш-таблиц**](https://ru.wikipedia.org/wiki/Хеш-таблица).

Может возникнуть вопрос: почему массивы в Bash называются массивами? Ведь фактически они представляют собой связанные списки и хэш-таблицы. Массив — это структура данных, элементы которой хранятся в памяти последовательно друг за другом. У каждого элемента есть порядковый номер, называемый индексом или идентификатором.

Рассмотрим простейший пример массива. Предположим, что нам надо сохранить числа от 5 до 9 в массиве, каждый элемент которого занимает один байт. Тогда его размер будет равен пяти байтам. В памяти такой массив будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
05 06 07 08 09
```

Индексы начинаются с нуля. Тогда элемент с порядковым номером ноль равен пяти, а с номером три — восьми.

Вернёмся к нашему вопросу с названиями структур данных в Bash. Ответ на него знает только автор языка. Но можно предположить, что эти названия были выбраны для того, чтобы дать пользователю подсказку — как ему следует работать с этими структурами. Имея опыт в других языках (например, C) пользователь знает, как читать и писать отдельные элементы массивов. Поэтому он сможет использовать уже знакомый ему синтаксис и в Bash. Информация же о том, как на самом деле эти структуры хранятся в памяти, необязательна для пользователя.

#### Атрибуты


Bash позволяет указывать дополнительные атрибуты переменной при объявлении. Они определяют её тип, константность и области видимости.

Для указания атрибутов используется встроенная команда `declare`. При вызове без параметров она выводит все объявленные в данный момент переменные: локальные и окружения. По сути то же самое делает команда `set`.

Вы можете вызвать `declare` с опцией `-p`. Тогда помимо имён и значений переменных будут выведены их атрибуты. Можно ограничить вывод команды `declare` только интересующей вас переменной. Для этого передайте её имя в качестве параметра следующим образом:
{line-numbers: false, format: Bash}
```
declare -p PATH
```

Команда `declare` позволяет получить информацию не только об объявленных переменных, но и о доступных вам [**подпрограммах**](https://ru.wikipedia.org/wiki/Функция_(программирование)). В Bash они называются **функциями**. Подпрограмма — это фрагмент программы или самостоятельный блок кода, который выполняет определённую задачу. Например, чтобы получить информацию о функции `quote`, вызовите команду `declare` следующим образом:
{line-numbers: false, format: Bash}
```
declare -f quote
```

I> Функция `quote` заключает переданную ей строку в одинарные кавычки. Если кавычки встречаются в строке, то они будут экранированы. Вызов функции происходит точно так же, как и любой встроенной команды Bash. Например:
{line-numbers: false, format: Bash}
```
quote "this is a 'test' string"
```

Мы рассмотрели опции команды `declare` для получения информации об уже объявленных переменных и функциях. Теперь рассмотрим, как с её помощью устанавливать атрибуты новых переменных. Наиболее часто используемые опции `declare` приведены в таблице 3-7.

{caption: "Таблица 3-7. Атрибуты переменных в Bash", width: "100%"}
| Опция | Значение |
| --- | --- |
| `-a` | Объявленная переменная является индексируемым [**массивом**](https://ru.wikipedia.org/wiki/Массив_(тип_данных)). В этом случае элементы массива доступны по целочисленным номерам. |
|  | |
| `-A` | Объявленная переменная является ассоциативным массивом. В этом случае каждому элементу массива соответствует ключ-строка. |
|  | |
| `-g` | Объявление переменной в глобальной области видимости скрипта. При этом переменная не попадает в окружение. |
|  | |
| `-i` | Объявление целочисленной переменной. Присваиваемое ей значение будет обработано, как арифметическое выражение. |
|  | |
| `-r` | Объявление константы. Это означает, что указанному имени переменной не может быть присвоено другое значение. |
|  | |
| `-x` | Объявление переменной окружения. |

Рассмотрим примеры объявлений с атрибутами. Начнём с целочисленных и строковых переменных. Выполним два следующих объявления:
{line-numbers: true, format: Bash}
```
declare -i sum=11+2
text=11+2
```

В результате первая переменная, объявленная как целочисленная, будет иметь значение 13, то есть суммы чисел 11 и 2. Вторая будет равна тексту "11+2". Обратите внимание, что и `sum`, и `text` хранятся в памяти в виде строк. Таким образом опция `-i` не задаёт тип переменной, а ограничивает её допустимые значения. Если вы попробуете присвоить `sum` строковое значение, она станет равна нулю. Например в результате следующего объявления:
{line-numbers: false, format: Bash}
```
declare -i sum="test"
```

Опция `-i` позволяет выполнять арифметические операции над переменной без подстановки арифметических выражений. Например:
{line-numbers: true, format: Bash}
```
sum=sum+1       # 13 + 1 = 14
sum+=1          # 14 + 1 = 15
sum+=sum+1      # 15 + 15 + 1 = 31
```

Если выполнить те же самые операции со строковой переменной, результат будет отличаться:
{line-numbers: true, format: Bash}
```
text=text+1     # "text+1"
text+=1         # "text+1" + "1" = "text+11"
text+=text+1    # "text+11" + "text" + "1" = "text+11text+1"
```

Вместо арифметических операций над числами произошло добавление суффикса к строке. Чтобы выполнить эти операции корректно над текстовой переменной, нужно применить подстановку:
{line-numbers: true, format: Bash}
```
text=11
text=$(($text + 2))  # 11 + 2 = 13
```

Опция `-r` команды `declare` позволяет объявить переменную константой. Например так:
{line-numbers: false, format: Bash}
```
declare -r filename="README.txt"
```

Теперь Bash вернёт сообщение об ошибке при попытке переобъявить или удалить переменную с именем `filename`. То есть следующие команды завершаться с ошибкой:
{line-numbers: true, format: Bash}
```
filename="123.txt"
unset filename
```

I> Для удаления переменной любого типа, кроме константы, используйте встроенную команду `unset`.

Команда `declare`, вызванная с опцией `-x`, объявляет переменную окружения. То же самое делает команда `export`. Это означает, что следующие два
объявления переменной `BROWSER_PATH` полностью эквивалентны:
{line-numbers: true, format: Bash}
```
export BROWSER_PATH="/opt/firefox/bin"
declare -x BROWSER_PATH="/opt/firefox/bin"
```

Хорошей практикой считается использовать команду `export` вместо `declare -x`. Это улучшает читаемость кода, потому что не приходится вспоминать значения опций `declare`. По этой же причине предпочитайте использовать команду `readonly` вместо `declare -r`. Она делает то же самое, но её проще запомнить.

Обратите внимание, что команда `readonly` объявляет переменную в глобальной области видимости скрипта. Если вы используете `declare -r` в теле функции, будет объявлена локальная переменная, доступная только в функции. В этом случае чтобы добиться такого же эффекта как от `readonly`, используйте опцию `-g`. Например так:
{line-numbers: false, format: Bash}
```
declare -gr filename="README.txt"
```

#### Индексируемые массивы

В Bourne Shell есть только переменные строкового типа. В Bash по просьбам пользователей были добавлены массивы. В каком случае они могут понадобиться и вам?

У строкового типа в Bash есть серьёзное ограничение. Когда вы помещаете в переменную какое-то значение, логически это один элемент. Например, вы сохранили в переменной с именем `files` список файлов, разделённых пробелами. В результате `files` хранит одну строку с точки зрения Bash. Это может привести к ошибкам.

Как мы выяснили, стандарт POSIX разрешает любые символы в именах файлов, кроме нуль-терминатора (NUL). NUL означает конец имени файла. Этот же самый символ в Bash означает конец строки. Следовательно, строковая переменная может содержать NUL не в произвольном месте, а только в конце. К чему это приводит? Если вы сохраняете список имён файлов в строке, у вас нет надёжного способа его восстановить. Любой символ-разделитель, потенциально может встречаться в этих именах.

Надёжная обработка вывода утилиты `ls` невозможна именно из-за проблемы разделителя. `ls` не позволяет разделять имена файлов и каталогов NUL символом в отличие от утилиты `find`. Но никакой другой символ не будет достаточно надёжным. Поэтому следует избегать объявления переменных, подобные следующему:
{line-numbers: false, format: Bash}
```
files=$(ls Documents/*.txt)
```

Массивы были добавлены в Bash для решения этой проблемы. Они позволяют сохранить список логически отдельных элементов и восстановить его в исходном виде. Вместо присваивания переменной вывода утилиты `ls` используйте массив:
{line-numbers: false, format: Bash}
```
declare -a files=(Documents/*.txt)
```

Когда Bash может вывести тип переменной исходя из присваиваемого ей значения, вы можете опустить команду `declare`. Следующее объявление даст тот же самый результат:
{line-numbers: false, format: Bash}
```
files=(Documents/*.txt)
```

Если все элементы массива вам известны, вы можете указать их явно при объявлении:
{line-numbers: false, format: Bash}
```
files=("/usr/share/doc/bash/README" "/usr/share/doc/flex/README.md" "/usr/share/doc/xz/README")
```

В качестве элементов массива можно использовать другие переменные. Например так:
{line-numbers: true, format: Bash}
```
bash_doc="/usr/share/doc/bash/README"
flex_doc="/usr/share/doc/flex/README.md"
xz_doc="/usr/share/doc/xz/README"
files=("$bash_doc" "$flex_doc" "$xz_doc")
```

Также вы можете явно задавать порядковые номера (индексы) для каждого элемента. Например, с учётом объявленных выше переменных `bash_doc` и `flex_doc` можно создать следующий массив `files`:
{line-numbers: false, format: Bash}
```
files=([0]="$bash_doc" [1]="$flex_doc" [5]="/usr/share/doc/xz/README")
```

Обратите внимание на отсутствие пробелов до и после каждого знака равно `=`. Запомните простое правило: в Bash при объявлении переменных пробелы до и после `=` никогда не ставятся.

Вместо объявления всего массива за раз, вы можете устанавливать его элементы по отдельности. Например так:
{line-numbers: true, format: Bash}
```
files[0]="$bash_doc"
files[1]="$flex_doc"
files[5]="/usr/share/doc/xz/README"
```

Наверное, вы обратили внимание, что в последних двух объявлениях массива `files` нумерация индексов идёт не по порядку. Bash допускает массивы с пропусками (sparse arrays). В этом случае может быть полезно вывести только индексы. Для этого поставьте символ `!` перед именем массива следующим образом:
{line-numbers: true, format: Bash}
```
$ echo "${!files[@]}"
0 1 5
```

Вместо индекса элемента в квадратных скобках вы можете указать арифметическое выражение для его вычисления. Например так:
{line-numbers: true, format: Bash}
```
echo "${files[4+1]}"
files[4+1]="/usr/share/doc/xz/README"
```

В арифметическом выражении можно использовать переменные. Причём они не обязательно должны быть объявлены как целочисленные. Например:
{line-numbers: true, format: Bash}
```
i=4
echo "${files[i+1]}"
files[i+1]="/usr/share/doc/xz/README"
```

Если вас интересуют несколько следующих подряд элементов, вы можете подставить их одной командой. Для этого после двоеточия укажите стартовый индекс и число элементов. Например так:
{line-numbers: true, format: Bash}
```
$ echo "${files[@]:1:2}"
/usr/share/doc/flex/README.md /usr/share/doc/xz/README
```

Эта команда выведет два элемента начиная с первого. Обратите внимание, что индексы элементов в данном случае не важны. Мы прочитали имена файлов под номерами 1 и 5.

Bash, начиная с версии 4, предоставляет встроенную команду `readarray` (также известную как `mapfile`). Она позволяет прочитать содержимое текстового файла в массив. Рассмотрим пример её использования.

Предположим, что у нас есть файл с именем `names.txt` и следующим содержимым:
{line-numbers: true, format: Bash}
```
Alice
Bob
Eve
Mallory
```

Чтобы создать массив, каждый элемент которого соответствует строке файла `names.txt`, достаточно выполнить следующую команду:
{line-numbers: false, format: Bash}
```
readarray -t names_array < names.txt
```

В результате содержимое файла будет записано в массив с именем `names_array`.

{caption: "Упражнение 3-3. Объявление массивов", format: text, line-numbers: false}
```
Выполните самостоятельно все рассмотренные нами способы объявления массивов:

1. С помощью команды declare.

2. Без использования команды declare.

3. Все элементы массива подставляются в результате globbing.

4. Все элементы массива указываются явно при объявлении.

5. Каждый элемент массива задаётся отдельно.

6. В качестве элементов массива используются значения объявленных ранее переменных.

7. Элементы массива читаются из текстового файла.

Выведите содержимое массива с помощью команды echo для каждого случая. Убедитесь, что объявления выполнились корректно.
```

Мы научились объявлять индексируемые массивы. Теперь разберёмся, как их использовать. Предположим, что массив `files` содержит список имён файлов. Если вам надо скопировать только первый из них, вызов утилиты `cp` будет выглядеть так:
{line-numbers: false, format: Bash}
```
cp "${files[0]}" ~/Documents
```

W> В Bash, как и в большинстве языков программирования, принято нумеровать элементы массивов и строк с нуля, а не с единицы.

Для доступа к элементу массива используется полная форма подстановки с фигурными скобками. После имени переменной в квадратных скобках указывается номер элемента, который Bash должен подставить. Если вам необходимо подставить все элементы массива, используйте символ `@`. Например так:
{line-numbers: false, format: Bash}
```
cp "${files[@]}" ~/Documents
```

Чтобы получить размер массива, поставьте символ решётка `#` перед его именем. Например:
{line-numbers: false, format: Bash}
```
echo "${#files[@]}"
```

При подстановке элементов массива всегда используйте двойные кавычки, чтобы предотвратить word splitting.

Чтобы удалить элемент массива, используйте встроенную команду `unset`. Например, удаление четвёртого элемента (не забывайте про нумерацию с нуля) выглядит следующим образом:
{line-numbers: false, format: Bash}
```
unset 'files[3]'
```

Обратите внимание на обязательные одинарные кавычки. Они позволят избежать любых подстановок интерпретатора.

С помощью команды `unset` можно также очистить весь массив:
{line-numbers: false, format: Bash}
```
unset files
```

#### Ассоциативные массивы

Мы рассмотрели индексируемые массивы. В них элементами являются строки, а индексами целые положительные числа. Можно сказать, что массивы этого типа позволяют по указанному числу получить соответствующую ему строку.

В Bash версии 4 появился новый тип переменных — ассоциативные массивы. В них в качестве индексов допускаются строки. То есть благодаря такому массиву вы сможете по известной строке получить другую, соответствующую ей. Рассмотрим пример.

Предположим, что вам нужен скрипт для хранения списка своих контактов. У него должна быть возможность добавлять имена людей (для простоты опустим фамилии), а также их email или телефон. Также скрипт должен выводить контактные данные для указанного человека. Вопрос заключается в том, как хранить данные?

Если использовать индексируемый массив, поиск нужного человека будет долгим и неэффективным. Придётся перебирать все элементы друг за другом и проверять хранящиеся в них имена. При совпадении имени выводить соответствующие контактные данные.

Использование ассоциативного массива даст более эффективное решение. В этом случае имя человека будет ключом для поиска. Чтобы получить соответствующие контактные данные, достаточно просто получить элемент массива по ключу. Рассмотрим детали реализации этого решения.

Объявление массива выглядит следующим образом:
{line-numbers: false, format: Bash}
```
declare -A contacts=(["Alice"]="alice@gmail.com" ["Bob"]="(697) 955-5984" ["Eve"]="(245) 317-0117" ["Mallory"]="mallory@hotmail.com")
```

Обратите внимание, что ассоциативный массив всегда должен объявляться через вызов команды `declare` с опцией `-A`. Bash не сможет автоматически вывести его тип, даже если указать в качестве индексов строки. Это значит, что в результате следующего объявления вы получите индексируемый массив, а не ассоциативный:
{line-numbers: false, format: Bash}
```
contacts=(["Alice"]="alice@gmail.com" ["Bob"]="(697) 955-5984" ["Eve"]="(245) 317-0117" ["Mallory"]="mallory@hotmail.com")
```

Проверим, чему равна переменная `contacts` в этом случае:
{line-numbers: true, format: Bash}
```
$ declare -p contacts
declare -a contacts='([0]="mallory@hotmail.com")'
```

Элементы массива можно задавать по отдельности. Например так:
{line-numbers: true, format: Bash}
```
declare -A contacts
contacts["Alice"]="alice@gmail.com"
contacts["Bob"]="(697) 955-5984"
contacts["Eve"]="(245) 317-0117"
contacts["Mallory"]="mallory@hotmail.com"
```

Мы объявили ассоциативный массив. Доступ к его элементам происходит по ключу, как и в индексируемом массиве. В нашем случае ключом является имя пользователя. Чтение элемента выглядит следующим образом:
{line-numbers: true, format: Bash}
```
$ echo "${contacts["Bob"]}"
(697) 955-5984
```

Для вывода всех элементов массива просто укажите в качестве индекса символ `@`:
{line-numbers: true, format: Bash}
```
$ echo "${contacts[@]}"
(697) 955-5984 mallory@hotmail.com alice@gmail.com (245) 317-0117
```

Если вам нужно вывести список всех ключей, поставьте символ `!` перед именем массива:
{line-numbers: true, format: Bash}
```
$ echo "${!contacts[@]}"
Bob Mallory Alice Eve
```

Размер массива выводится с помощью символа решётка `#`:
{line-numbers: true, format: Bash}
```
$ echo "${contacts[@]}"
4
```

Поместим ассоциативный массив с контактами в скрипт. Тогда пользователь сможет передать имя интересующего его человека через параметр командной строки и получить соответствующий email или телефон. Листинг 3-10 демонстрирует получившийся скрипт.

{caption: "Листинг 3-10. Скрипт для хранения контактов", line-numbers: true, format: Bash}
![`contacts.sh`](code/BashScripting/contacts.sh)

Удалять ассоциативный массив и его элементы можно командой `unset`:
{line-numbers: true, format: Bash}
```
unset contacts
unset 'contacts[Bob]'
```

Подстановка нескольких элементов ассоциативного массива выполняется аналогично индексируемому массиву. Например:
{line-numbers: true, format: Bash}
```
$ echo "${contacts[@]:Bob:2}"
(697) 955-5984 mallory@hotmail.com
```

В этом случае будет подставлено два элемента: соответствующий ключу `Bob` и следующий за ним в памяти. Проблема в том, что порядок следования элементов в памяти не соответствует порядку, в котором вы их присвоили. Индекс каждого элемента рассчитывается [**хеш-функцией**](https://ru.wikipedia.org/wiki/Хеш-функция). На вход она принимает строку-ключ, а на выходе возвращает уникальное целое число. Из-за этой особенности подстановка нескольких элементов ассоциативного массива мало полезна на практике.
## Переменные и параметры

Мы уже сталкивались с переменными, когда говорили о `PATH`, хранящем список системных путей, и доступе к позиционным параметрам Bash-скрипта по именам `$1`, `$2` и т.д. Теперь рассмотрим тему переменных подробнее.

Что представляет собой переменная в контексте программирования? Это некоторая область памяти (обычно оперативной), в которой хранится значение. В первых языках программирования (например, [**ассемблере**](https://ru.wikipedia.org/wiki/Язык_ассемблера)) обращение к переменным происходит по их адресу. То есть, чтобы записать новое значение или прочитать текущее, вы должны указывать адрес памяти. В 32-разрядных архитектурах длина адреса 4 байта (число от 0 до 4294967295), а в 64-разрядных он в два раза больше. Очевидно, что запоминать и оперировать такими большими числами неудобно. Поэтому современные языки программирования позволяют вместо адресов работать с именами переменных. Эти имена в процессе компиляции или интерпретации программы транслируются в адреса памяти. Таким образом всю работу по "запоминанию" больших чисел берёт на себя компилятор или интерпретатор.

### Классификация переменных

Интерпретатор Bash может работать в двух основных режимах: интерактивном (командная оболочка) и неинтерактивном (исполнение скриптов). Переменные активно используются в каждом из них. Задачи решаемые переменными в этих режимах различаются. Это привело к появлению нескольких классификаций переменных в Bash.

Для удобства рассмотрения сделаем небольшое упрощение в терминологии, которое в общем не совсем правильно. При обсуждении скриптов, будем использовать тремин "переменная" (variable). Когда же обсуждается командная оболчка и аргументы командной строки, будем использовать термин "параметр" (parameter). Это позволит избежать путанницы. В английской литературе эти термины часто используются как синонимы.

Какие же классификации переменных есть в Bash? Таблица 3-1 демонстрирует их в кратком виде.

{caption: "Таблица 3-1. Классификация переменных в Bash", width: "100%"}
| Признак классификации | Типы | Определение | Примеры |
| --- | --- | --- | --- |
| Доступность в shell | Глобальные переменные (переменные окружения) | Доступны в любом экземпляре запущенного интерпретатора. Выводятся утилитой `env`, запущенной без параметров. | `echo "$PATH"` |
|                     | Локальные переменные | Доступны только в конкретном экземпляре запущенного интерпретатора. | `filename="README.txt" ; echo "$filename"` |
|  | | | |
| Тип хранимого значения | Строковые | Хранят строки. | `filename="README.txt"` |
|                     | Целочисленные | Хранят целые числа. | `declare -i number=10/2 ; echo "$number"` |
|                     | Константные | Хранят неизменяемые значения или константы. | `readonly CONSTANT="ABC" ; echo "$CONSTANT"` |
|                     | | | `declare -r CONSTANT="ABC" ; echo "$CONSTANT"` |
|                     | Массивы | Хранят нумерованные списки строк. | `cities=("London" "New York" "Berlin") ; echo "${cities[1]}"` |
|  | | | `cities[0]="London" ; cities[1]="New York" ; cities[2]="Berlin" ; echo "${cities[1]}"` |
|  | | | |
| Механизм установки | Системные (зарезервированные) | Устанавливаются интерпретатором и нужны для его корректной работы. | `echo "$PATH"` |
|                      | Пользовательские | Устанавливаются пользователем. | `filename="README.txt" ; echo "$filename"` |

Рассмотрим каждый из приведённых типов переменных.

### Пользовательские переменные

Начнём наше знакомство с пользовательских переменных. Как следует из названия, они задаются пользователем для хранения промежуточных результатов работы скрипта. 

Чтобы объявить переменную, укажите её имя, знак равно и значение. Например, следующая строка объявляет переменную с именем `filename`, значение которой равно `README.txt`:
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

Обратите внимание, что пробел до и после знака равно не ставится. То есть следующее объявление завершится с ошибкой:
{line-numbers: false, format: Bash}
```
filename = "README.txt"
```

Bash обработает такую строку как вызов команды с именем `filename` и двумя параметрами: `=` и `"README.txt"`

I> В именах переменных можно использовать только символы латинского алфавита, числа и знак подчёркивания. Имя не должно начинаться с числа. Регистр букв важен, т.е. `filename` и `FILENAME` — это две разные переменные.

При объявлении переменной `filename` в памяти процесса интерпретатора выделяется область памяти, в которой сохраняется строка `README.txt`. Чтобы её прочитать, следует обратиться к ней по имени. Но интерпретатор должен понять, что речь идёт не о команде или строке, а о переменной. Чтобы сообщить ему эту информацию, необходимо поставить знак доллара `$` перед именем:
{line-numbers: false, format: Bash}
```
$filename
```

Что означает знак доллара? Встретив его в команде, Bash запускает механизм подстановки переменных (**parameter expansion**). Этот механизм заменяет все вхождения имени переменной на её значение. Рассмотрим следующую команду:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

Bash развернёт её так:
{line-numbers: false, format: Bash}
```
cp README.txt ~
```

Учтите, что подстановка переменных не единственная. После неё Bash выполняет другие подстановки, что может привести к ошибкам. Рассмотрим пример. Предположим, что нам нужно оперировать файлом, в имени которого встречается пробел. Тогда объявление переменной `filename` будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
filename="my file.txt"
```

Наша переменная используется в вызове утилиты `cp`:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

После подстановки переменных Bash выполняет word splitting. В результате получится следующий вызов утилиты `cp`:
{line-numbers: false, format: Bash}
```
cp my file.txt ~
```

Такой вызов завершится с ошибкой, потому что вместо одного параметра с именем файла, мы получили два: `my` и `file.txt`. Таких файлов не существует.

Проблема возникнет и в том случае, если в значении переменной встречается символ подстановки. Например:
{line-numbers: false, format: Bash}
```
filename="*file.txt"
rm $filename
```

В результате этой команды будут удалены все файлы, заканчивающиеся на `file.txt`. В таком поведении виноват механизм globbing, который также выполняется после подстановки переменных. В результате его работы в утилиту `rm` будут переданы все файлы из текущего каталога, имена которых соответствуют шаблону поиска `*file.txt`. Например, мы можем получить следующий вызов `rm`:
{line-numbers: false, format: Bash}
```
rm report_file.txt myfile.txt msg_file.txt
```

Чтобы избежать нежелательных подстановок Bash, заключайте все обращения к переменным в двойные кавычки `"`. Например, следующим образом:
{line-numbers: true, format: Bash}
```
filename1="my file.txt"
cp "$filename1" ~

filename2="*file.txt"
rm "$filename2"
```

Благодаря этому, значение переменной будет подставлено без дальнейших изменений:
{line-numbers: false, format: Bash}
```
cp "my file.txt" ~
rm "*file.txt"
```

Мы уже познакомились с несколькими [подстановками](http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Expansions), выполняемыми Bash. В таблице 3-2 приведены остальные, а также указан их порядок выполнения. 

{caption: "Таблица 3-2. Подстановки Bash", width: "100%"}
| Приоритет | Подстановка | Комментарий | Пример |
| --- | --- | --- | --- |
| 1 | Brace Expansion | Подстановка фигурных скобок `{` и `}`. | `echo a{d,c,b}e` |
|  | | | |
| 2 | Tilde Expansion | Подстановка символа тильда `~`. | `cd ~` |
|  | | | |
| 3 | Parameter Expansion | Подстановка параметров и переменных. | `echo "$PATH"` |
|  | | | |
| 4 | Arithmetic Expansion | Подстановка вместо арифметических выражений их значений. | `echo $((4+3))` |
|  | | | |
| 5 | Command Substitution | Подстановка вместо команды её вывода. | `echo $(cat README.txt)` |
|  | | | |
| 6 | Process Substitution | Подстановка вместо команды её вывода. В отличие от Command Substitution выполняется [асинхронно](https://ru.wikipedia.org/wiki/Асинхронность#Асинхронность_в_информатике), а ввод и вывод команды привязаны к временному файлу. | `diff <(sort file1.txt) <(sort file2.txt)` |
|  | | | |
| 7 | Word Splitting | Разделение аргументов командной строки на слова и передача их в качестве отдельных параметров. | `cp file1.txt file2.txt ~` |
|  | | | |
| 8 | Filename Expansion (globbing) | Подстановка имён файлов вместо шаблонов. | `rm -rf *` |
|  | | | |
| 9 | Quote Removal | Удаление всех неэкранированных символов `\`, `'` и `"`, которые не были получены в результате одной из предыдущих подстановок | `cp "my file.txt" ~` |

Запись имени переменной со знаком `$` вначале является сокращенной формой. В полном виде запись выглядит так:
{line-numbers: false, format: Bash}
```
${filename}
```

Такая форма поможет избежать неоднозначности, если сразу за именем переменной следует текст. Например
{line-numbers: true, format: Bash}
```
prefix="my"
name="file.txt"
cp "$prefix_$name" ~
```

В этом случае при подстановке параметров интерпретатор будет искать переменную с именем `prefix_`. То есть он приклеит подчёркивание к имени. Чтобы избежать этой проблемы можно воспользоваться полной формой записи:
{line-numbers: false, format: Bash}
```
cp "${prefix}_${name}" ~
```

Альтернативное решение — заключить каждое имя переменной в кавычки:
{line-numbers: false, format: Bash}
```
cp "$prefix"_"$name" ~
```

Устранение неоднозначности — не единственный случай, когда пригодится полная форма записи подстановки. Также она будет полезна, когда переменная не определена. В этом случае вместо её значения можно подставить некоторое значение по умолчанию. Например:
{line-numbers: false, format: Bash}
```
cp file.txt "${directory:-~}"
```

При обработке этой команды Bash проверит, определена ли переменная с именем `directory` и имеет ли она непустое значение. Если это так, произойдёт обычная подстановка. В противном случае будет использовано значение, следующее за символом `-`. В нашем примере это домашний каталог пользователя `~`.

Все варианты задания значения по умолчанию при подстановке приведены в таблице 3-3.

{caption: "Таблица 3-3. Задание значения по умолчанию при подстановке", width: "100%"}
| Форма записи | Описание|
| --- | --- |
| `${parameter:-word}` | Если переменная `parameter` не объявлена или имеет пустое значение, будет подставлено значение по умолчанию `word`. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:=word}` | Если переменная не объявлена или имеет пустое значение, ей будет присвоено значение по умолчанию, которое затем будет подставлено. В противном случае подставляется значение переменной. Переопределение позиционных и специальных параметров таким способом не допустимо. |
|  | |
| `${parameter:?word}` | Если переменная не объявлена или имеет пустое значение, значение по умолчанию будет выведено в стандартный поток ошибок. После этого выполнение скрипта будет завершено с кодом возврата отличным от 0. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:+word}` | Если переменная не объявлена или имеет пустое значение, ничего не будет подставлено. В противном случае подставляется значение по умолчанию. |

{caption: "Упражнение 3-1. Использование полной формы подстановки параметров", format: text, line-numbers: false}
```
Напишите скрипт, который ищет файлы с расширением TXT в текущем каталоге, исключая его подкаталоги. Все найденные файлы должны быть скопированы или перемещены в домашний каталог пользователя. При вызове скрипта требуемая операция передаётся в первом позиционном параметре. Если она не указана, выполняется копирование.
```

### Локальные и глобальные переменные

Рассмотренные нами пользовательские переменные являются локальными. Это значит, что после их определения они не будут доступны в другом экземпляря командного интерпретатора, если вы его запустите. Другими словами вы можете объявить переменную в окне терминала MSYS, например, так:
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

После этого переменная `filename` попадёт в список **переменных оболочки** (shell variables), которые выводятся встроенной командой `set`, вызванной без параметров. Выполните следующую команду:
{line-numbers: false, format: Bash}
```
set | grep filename=
```

В её выводе вы увидите следующую строчку:
{line-numbers: false, format: Bash}
```
filename=README.txt
```

Вы получите корректное значение переменной, если попробуйте её вывести с помощью команды `echo`, набранной в том же терминале, в котором её определили:
{line-numbers: false, format: Bash}
```
echo "$filename"
```

Однако, если сделать точно такой же вывод из скрипта, напечатается пустая строка. То же самое произойдёт, если запустить новый экземпляр интерпретатора и выполнить `echo` в нём. Например, так:
{line-numbers: false, format: Bash}
```
filename="README.txt" ; bash -c 'echo $filename'
```

Именно такой вызов `bash` происходит неявно при запуске скрипта из командного интерпретатора.

I> Обратите внимание на одинарные кавычки `'`. Они отключают все подстановки для заключённой в них строки. В отличие от них двойные кавычки разрешают подстановки команд и параметров. Если в нашем примере использовать двойные кавычки, то в результате подстановки получится следующая команда вызова `bash`:
{line-numbers: false, format: Bash}
```
bash -c "echo README.txt"
```

// TODO: Таблица

### Специальные параметры

## Переменные и параметры

Мы уже сталкивались с переменными, когда говорили о `PATH`, хранящем список системных путей, и доступе к позиционным параметрам Bash-скрипта по именам `$1`, `$2` и т.д. Теперь рассмотрим тему переменных подробнее.

Что представляет собой переменная в контексте программирования? Это некоторая область памяти (обычно оперативной), в которой хранится значение. В первых языках программирования (например, [**ассемблере**](https://ru.wikipedia.org/wiki/Язык_ассемблера)) обращение к переменным происходит по их адресу. То есть, чтобы записать новое значение или прочитать текущее, вы должны указывать адрес памяти. В 32-разрядных архитектурах длина адреса 4 байта (число от 0 до 4294967295), а в 64-разрядных он в два раза больше. Очевидно, что запоминать и оперировать такими большими числами неудобно. Поэтому современные языки программирования позволяют вместо адресов работать с именами переменных. Эти имена в процессе компиляции или интерпретации программы транслируются в адреса памяти. Таким образом всю работу по "запоминанию" больших чисел берёт на себя компилятор или интерпретатор.

Зачем нужны переменные? Из предыдущих примеров очевидно, что переменные используются для хранения каких-то значений. Обычно при этом преследуется одна из следующих целей:

1. Передать информацию из одной части программы или системы в другую.

2. Сохранить промежуточный результат вычислений для дальнейшего использования.

3. Задать константное значение, которое будет многократно использоваться в дальнейшем.

Для каждой из целей в языках программирования вводится специальный тип переменной. Язык Bash не является исключением.

### Классификация переменных

Интерпретатор Bash может работать в двух основных режимах: интерактивном (командная оболочка) и неинтерактивном (исполнение скриптов). В каждом из них переменные решают сходные задачи, но контексты их использования различаются. Из-за этого в Bash больше признаков для классификации переменных, чем в большинстве других языков.

Для удобства рассмотрения сделаем сразу небольшое упрощение в терминологии, которое в общем не совсем правильно. При обсуждении скриптов, будем использовать термин "переменная" (variable). Когда же обсуждается командная оболчка и аргументы командной строки, будем использовать термин "параметр" (parameter). Это позволит избежать путанницы. В английской литературе эти термины часто используются как синонимы.

Какие же классификации переменных есть в Bash? Таблица 3-1 демонстрирует их в кратком виде.

{caption: "Таблица 3-1. Классификация переменных в Bash", width: "100%"}
| Признак классификации | Типы | Определение | Примеры |
| --- | --- | --- | --- |
| Механизм установки | Пользовательские переменные | Устанавливаются пользователем. | `filename="README.txt" ; echo "$filename"` |
|                    | Зарезервированные (системные) переменные | Устанавливаются интерпретатором и нужны для его корректной работы. | `echo "$PATH"` |
|                    | Специальные параметры | Устанавливаются интерпретатором и доступны только для чтения. | `echo "$?"` |
|  | | | |
| [Область видимости](https://ru.wikipedia.org/wiki/Область_видимости) | Переменные окружения (или глобальные) | Доступны в любом экземпляре запущенного интерпретатора. Выводятся утилитой `env`, запущенной без параметров. | `echo "$PATH"` |
|                     | Локальные переменные | Доступны только в конкретном экземпляре запущенного интерпретатора. | `filename="README.txt" ; echo "$filename"` |
|  | | | |
| Тип хранимого значения | Строковые | Хранят строки. | `filename="README.txt"` |
|                     | Целочисленные | Хранят целые числа. | `declare -i number=10/2 ; echo "$number"` |
|                     | Константные | Хранят неизменяемые значения или константы. | `readonly CONSTANT="ABC" ; echo "$CONSTANT"` |
|                     | | | `declare -r CONSTANT="ABC" ; echo "$CONSTANT"` |
|                     | Массивы | Хранят нумерованные списки строк. | `cities=("London" "New York" "Berlin") ; echo "${cities[1]}"` |
|  | | | `cities[0]="London" ; cities[1]="New York" ; cities[2]="Berlin" ; echo "${cities[1]}"` |

Рассмотрим каждый из приведённых типов переменных.

## Механизм установки

### Пользовательские переменные

Начнём наше знакомство с пользовательских переменных. Как следует из названия, они задаются пользователем для хранения промежуточных результатов работы скрипта или константных значений.

Чтобы объявить переменную, укажите её имя, знак равно и значение. Например, следующая строка объявляет переменную с именем `filename`, значение которой равно `README.txt`:
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

Обратите внимание, что пробел до и после знака равно не ставится. То есть следующее объявление завершится с ошибкой:
{line-numbers: false, format: Bash}
```
filename = "README.txt"
```

Bash обработает такую строку как вызов команды с именем `filename` и двумя параметрами: `=` и `"README.txt"`

I> В именах переменных можно использовать только символы латинского алфавита, числа и знак подчёркивания. Имя не должно начинаться с числа. Регистр букв важен, т.е. `filename` и `FILENAME` — это две разные переменные.

При объявлении переменной `filename` в памяти процесса интерпретатора выделяется область памяти, в которой сохраняется строка `README.txt`. Чтобы её прочитать, следует обратиться к ней по имени. Но интерпретатор должен понять, что речь идёт не о команде или строке, а о переменной. Чтобы сообщить ему эту информацию, необходимо поставить знак доллара `$` перед именем:
{line-numbers: false, format: Bash}
```
$filename
```

Что означает знак доллара? Встретив его в команде, Bash запускает механизм подстановки переменных (**parameter expansion**). Этот механизм заменяет все вхождения имени переменной на её значение. Рассмотрим следующую команду:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

После подстановки она будет выглядеть так:
{line-numbers: false, format: Bash}
```
cp README.txt ~
```

Учтите, что подстановка переменных не единственная. За ней следуют другие, что может привести к ошибкам. Рассмотрим пример. Предположим, что нам нужно оперировать файлом, в имени которого встречается пробел. Тогда объявление переменной `filename` с его именем будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
filename="my file.txt"
```

Далее эта переменная используется в вызове утилиты `cp`, как и раньше:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

После подстановки переменных Bash выполняет word splitting. В результате получится следующий вызов утилиты `cp`:
{line-numbers: false, format: Bash}
```
cp my file.txt ~
```

Такой вызов завершится с ошибкой, потому что вместо одного параметра с именем файла, мы получили два: `my` и `file.txt`. Таких файлов не существует.

Проблема возникнет и в том случае, если в значении переменной встречается символ подстановки. Например:
{line-numbers: false, format: Bash}
```
filename="*file.txt"
rm $filename
```

В результате этой команды будут удалены все файлы, заканчивающиеся на `file.txt`. В таком поведении виноват механизм globbing, который также выполняется после подстановки переменных. Из-за него в утилиту `rm` будут переданы все файлы из текущего каталога, имена которых соответствуют шаблону поиска `*file.txt`. Например, мы можем получить следующий вызов `rm`:
{line-numbers: false, format: Bash}
```
rm report_file.txt myfile.txt msg_file.txt
```

Чтобы избежать нежелательных подстановок Bash, заключайте все обращения к переменным в двойные кавычки `"`. Например, следующим образом:
{line-numbers: true, format: Bash}
```
filename1="my file.txt"
cp "$filename1" ~

filename2="*file.txt"
rm "$filename2"
```

Благодаря этому, значение переменной будет подставлено без дальнейших изменений:
{line-numbers: false, format: Bash}
```
cp "my file.txt" ~
rm "*file.txt"
```

Мы уже познакомились с несколькими [подстановками](http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Expansions), выполняемыми Bash. В таблице 3-2 приведены остальные, а также указан их порядок выполнения. 

{caption: "Таблица 3-2. Подстановки Bash", width: "100%"}
| Порядок выполнения | Подстановка | Комментарий | Пример |
| --- | --- | --- | --- |
| 1 | Brace Expansion | Подстановка фигурных скобок `{` и `}`. | `echo a{d,c,b}e` |
|  | | | |
| 2 | Tilde Expansion | Подстановка символа тильда `~`. | `cd ~` |
|  | | | |
| 3 | Parameter Expansion | Подстановка параметров и переменных. | `echo "$PATH"` |
|  | | | |
| 4 | Arithmetic Expansion | Подстановка вместо арифметических выражений их значений. | `echo $((4+3))` |
|  | | | |
| 5 | Command Substitution | Подстановка вместо команды её вывода. | `echo $(cat README.txt)` |
|  | | | |
| 6 | Process Substitution | Подстановка вместо команды её вывода. В отличие от Command Substitution выполняется [асинхронно](https://ru.wikipedia.org/wiki/Асинхронность#Асинхронность_в_информатике), а ввод и вывод команды привязаны к временному файлу. | `diff <(sort file1.txt) <(sort file2.txt)` |
|  | | | |
| 7 | Word Splitting | Разделение аргументов командной строки на слова и передача их в качестве отдельных параметров. | `cp file1.txt file2.txt ~` |
|  | | | |
| 8 | Filename Expansion (globbing) | Подстановка имён файлов вместо шаблонов. | `rm -rf *` |
|  | | | |
| 9 | Quote Removal | Удаление всех неэкранированных символов `\`, `'` и `"`, которые не были получены в результате одной из предыдущих подстановок | `cp "my file.txt" ~` |

Запись имени переменной со знаком `$` в начале является сокращенной формой подстановки. В полном виде она выглядит так:
{line-numbers: false, format: Bash}
```
${filename}
```

Такая форма поможет избежать неоднозначности, если сразу за именем переменной следует текст. Например в следующем случае:
{line-numbers: true, format: Bash}
```
prefix="my"
name="file.txt"
cp "$prefix_$name" ~
```

Здесь при подстановке параметров интерпретатор будет искать переменную с именем `prefix_`. То есть он приклеит символ подчёркивания к имени переменной. Чтобы избежать этой проблемы можно воспользоваться полной формой записи:
{line-numbers: false, format: Bash}
```
cp "${prefix}_${name}" ~
```

Альтернативное решение — заключить каждое имя переменной в кавычки:
{line-numbers: false, format: Bash}
```
cp "$prefix"_"$name" ~
```

Устранение неоднозначности — не единственный случай, когда пригодится полная форма записи подстановки. Также она будет полезна, когда переменная не определена. В этом случае вместо неё можно подставить некоторое значение по умолчанию. Например:
{line-numbers: false, format: Bash}
```
cp file.txt "${directory:-~}"
```

При обработке этой команды Bash проверит, определена ли переменная с именем `directory` и имеет ли она непустое значение. Если это так, произойдёт обычная подстановка. В противном случае будет использовано значение, следующее за символом `-`. В нашем примере это домашний каталог пользователя `~`.

Все варианты задания значения по умолчанию при подстановке приведены в таблице 3-3.

{caption: "Таблица 3-3. Задание значения по умолчанию при подстановке", width: "100%"}
| Форма записи | Описание|
| --- | --- |
| `${parameter:-word}` | Если переменная `parameter` не объявлена или имеет пустое значение, будет подставлено значение по умолчанию `word`. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:=word}` | Если переменная не объявлена или имеет пустое значение, ей будет присвоено значение по умолчанию, которое затем будет подставлено. В противном случае подставляется значение переменной. Переопределение позиционных и специальных параметров таким способом не допустимо. |
|  | |
| `${parameter:?word}` | Если переменная не объявлена или имеет пустое значение, значение по умолчанию будет выведено в стандартный поток ошибок. После этого выполнение скрипта будет завершено с кодом возврата отличным от 0. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:+word}` | Если переменная не объявлена или имеет пустое значение, подстановки не будет. В противном случае подставляется значение по умолчанию. |

{caption: "Упражнение 3-1. Использование полной формы подстановки параметров", format: text, line-numbers: false}
```
Напишите скрипт, который ищет файлы с расширением TXT в текущем каталоге, исключая его подкаталоги. Все найденные файлы должны быть скопированы или перемещены в домашний каталог пользователя. При вызове скрипта требуемая операция передаётся в первом позиционном параметре. Если она не указана, выполняется копирование.
```

### Зарезервированные переменные

Кроме пользователя переменные может объявлять сам интерпретатор. В этом случае они называются **зарезервированными** (reserved) или **переменными оболчки** (shell variables). Как правило интерпретатор присваивает им значение по умолчанию, которое в некоторых случаях может меняться пользователем.

Большая часть зарезервированных переменных используется для передачи информации в запускаемые из командного интерпретатора приложения. Некоторые из них нужны для хранения текущего состояния самого интерпретатора.

Зарезервированные переменные Bash деляться на две группы:

1. Переменные Bourne Shell.
2. Переменные Bash.

Первая группа была унаследована из Bourne Shell и нужна для обсепечения POSIX-совместимости. Наиболее часто используемые из этих переменных представлены в таблице 3-4.

{caption: "Таблица 3-4. Зарезервированные переменные Bourne Shell", width: "100%"}
| Имя | Значение |
| --- | --- |
| `HOME` | Домашний каталог текущего пользователя. Значение переменной используется при вызове встроенной команды `cd` без параметров и подстановке символа тильда `~`. |
|  | |
| `IFS` | Список следующих друг за другом символов, которые используются в качестве разделителей при обработке вводимых строк (в том числе и для word splitting). По умолчанию это символы пробела, [табуляции](https://ru.wikipedia.org/wiki/Табуляция) и перевода строки. |
|  | |
| `PATH` | Список путей, разделённый двоеточиями, по которым интерпретатор ищет вызываемые утилиты и программы. |
|  | |
| `PS1` | Приглашение командной строки. Может состоять из набора [управляющих символов](https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html#Controlling-the-Prompt), которые будут заменены перед выводом на конкретные значения (например, имя текущего пользователя). |

В Bash были добавлены новые зарезервированные переменные. В таблице 3-5 приведены наиболее часто используемые из них.

{caption: "Таблица 3-5. Зарезервированные переменные Bash", width: "100%"}
| Имя | Значение |
| --- | --- |
| `BASH` | Полный путь, который использовался для запуска текущего экземпляра Bash. |
|  | |
| `BASHOPTS` | Список [дополнительных опций](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin) текущего экземпляра Bash, разделённых двоеточиями. |
|  | |
| `BASH_VERSION` | Номер версии текущего экземпляра Bash. |
|  | |
| `GROUPS` | Список групп, к которым относится текущий пользователь. |
|  | |
| `HISTCMD` | Номер текущей команды в истории команд. |
|  | |
| `HISTFILE` | Файл, в котором сохраняется история команд. Значение по умолчанию равно `~/.bash_history`. |
|  | |
| `HISTFILESIZE` | Максимально допустимое число строк в файле истории команд. Значение по умолчанию 500. |
|  | |
| `HISTSIZE` | Максимально допустимое число команд в файле истории команд. Значение по умолчанию 500. |
|  | |
| `HOSTNAME` | Имя текущего компьютера как узла вычислительной сети. |
|  | |
| `HOSTTYPE` | Строка, описывающая аппаратную платформу, на которой запущен Bash. |
|  | |
| `LANG` | [Региональные настройки](https://ru.wikipedia.org/wiki/Региональные_настройки_(программирование)) пользовательского интерфейса. Некоторые из них переопределяться переменными `LC_ALL`, `LC_COLLATE`, `LC_CTYPE`, `LC_MESSAGES`, `LC_NUMERIC`, `LC_TYPE`. |
|  | |
| `MACHTYPE` | Строка, полностью описывающая систему, на которой запущен Bash. Включает в себя информацию из `HOSTTYPE` и `OSTYPE`. |
|  | |
| `OLDPWD` | Предыдущий рабочий каталог, который был установлен встроенной командой `cd`. |
|  | |
| `OSTYPE` | Строка, описывающая ОС, на которой запущен Bash. |
|  | |
| `POSIXLY_CORRECT` | Если эта переменная определена, Bash работает в режиме [POSIX-совместимости](https://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html#Bash-POSIX-Mode). |
|  | |
| `PWD` | Текущий рабочий каталог, который был установлен встроенной командой `cd`. |
|  | |
| `RANDOM` | Каждый раз при чтении этой переменной возвращается случайное число от 0 до 32767. В случае записи переменной назначается инициализирующее число ([seed](https://en.wikipedia.org/wiki/Random_seed)) для [генератора псевдослучайных чисел](https://ru.wikipedia.org/wiki/Генератор_псевдослучайных_чисел). |
|  | |
| `SECONDS` | Количество секунд, прошедших с запуска текущего экземпляра Bash. |
|  | |
| `SHELL` | Полный путь к командному интерпретатору, установленному для текущего пользователя. |
|  | |
| `SHELLOPTS` | Список [дополнительных опций](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin) комндного интерпретатора, разделённых двоеточиями. |
|  | |
| `SHLVL` | Уровень вложенности текущего экземпляра Bash. Эта переменная увеличивается на единицу каждый раз, когда вы запускаете Bash из командного интерпретатора. |
|  | |
| `UID` | Идентификатор текущего пользователя. |

Обратите внимание, что есть несколько механизмов работы с зарезервированными переменными:

1. При запуске интерпретатор назначает переменной значение. В течении всей сессии оно остаётся неизменным. Пользователь может его прочитать, но не изменить. Примеры: `BASHOPTS`, `GROUPS`,  `SHELLOPTS`, `UID`.

2. При запуске интерпретатор назначает переменной значение по умолчанию. Оно меняется в результате выполнения пользователем команд или иных событий. Некоторые переменные могут быть изменены непосредственно, хоть и не предназначены для этого. Примеры: `HISTCMD`, `OLDPWD`, `PWD`, `SECONDS`, `SHLVL`.

3. При запуске интерпретатор назначает переменной значение по умолчанию. Оно может быть изменено только непосредственно пользователем. Примеры: `HISTFILESIZE`, `HISTSIZE`

### Специальные параметры

Специальные параметры всегда назначются интерпретатором. Некоторые из них хранят состояние его запущенного экземпляра (например, PID). Другие служат для передачи параметров командной строки в вызываемые утилиты и приложения, а также чтения их кода возврата. Все позиционные параметры относятся к специальным.

Наиболее часто используемые специальные параметры представлены в таблице 3-6.

{caption: "Таблица 3-6. Специальные параметры Bash", width: "100%"}
| Имя | Значение |
| --- | --- |
| `$*` | Используется для подстановки позиционных параметров, начиная с первого (`$1`). Если применяется без двойных кавычек, каждый позиционный параметр заменяется на отдельное слово. Если указан в двойных кавычках, вместо него будет подставлено одно слово, содержащее все параметры. Они будут разделены первым символом зарезервированной переменной `IFS`. |
|  | |
| `$@` | Используется для подстановки позиционных параметров, начиная с первого (`$1`). При применении без двойных кавычек и с ними, каждый позиционный параметр заменяется на отдельное слово (как в случае `$*` без кавычек). |
|  | |
| `$1`,`$2`... | Используется для подстановки позиционного параметра, порядковый номер которого в десятичной системе соответствует указанному. |
|  | |
| `$?` | Подстановка кода возврата последней выполненной команды в активном режиме (foreground). Если команды выполнялись в конвейере, параметр хранит код возврата последней из них. |
|  | |
| `$-` | Подстановка опций текущего экземпляра интерпретатора. |
|  | |
| `$$` | Подстановка идентификатора процесса текущего экземпляра интерпретатора. В случае подстановки в subshell, запущенного в скобках `()`, возвращает PID вызвавшего его интерпретатора. |
|  | |
| `$!` | Подстановка идентификатора процесса последней команды, запущенной в фоновом режиме. |
|  | |
| `$0` | Подстановка имени текущего командного интерпретатора или выполняемого в данный момент скрипта. |
|  | |

Все рассмотренные нами специальные параметры доступны в режиме POSIX-совместимости.

## Область видимости

### Переменные окружения

Все зарезервированные переменные Bash находятся в **глобальной области видимости** и называются **переменными окружения**.

Сначала разберёмся с тем, что означает **область видимости**? Это часть программы или в нашем случае системы, в которой имя переменной остаётся связанным с её значением, то есть корректно конвертируется в адрес памяти, по которому хранится значение этой переменной. За пределами области видимости то же самое имя может быть связано с другой переменной.

Область видимости называется глобальной, если распространяется на всю систему. Другими словами переменные этой области видимости доступны из любой части программы или системы.

Зачем интерпретатору понадобилось хранить переменные в глобальной области видимости? Дело в том, что в Unix есть набор настроек и переменных, которые влияют на поведение каждого приложения, запускаемого пользователем. Например, региональные настройки. Учитывая их, каждое запущенное приложение может адаптировать свой интерфейс. Именно для таких целей используются переменные окружения.

Когда один процесс порождает другой, дочерний процесс наследует все переменные окружения от родительского. В данном случае наследование означает создание собственной копии. Таким образом все утилиты и приложения, запущенные из командного интерпретатора, по умолчанию наследуют его переменные окружения. Это позволяет решить проблему передачи глобальных параметров во все приложения, запускаемые пользователем.

Важно заметить, что дочерние процессы могут изменять свои переменные окружения. В результате порождённые ими процессы будут наследовать эти изменения. Однако, это никак не отразится на соответствующих переменных родительского процесса.

Чтобы создать новую переменную окружения, используется зарезервированное слово `export`. Пример объявления такой переменной:
{line-numbers: false, format: Bash}
```
export BROWSER_PATH="/opt/firefox/bin"
```

Также вы можете поместить переменную в окружение после её объявления:
{line-numbers: true, format: Bash}
```
BROWSER_PATH="/opt/firefox/bin"
export BROWSER_PATH
```

Можно добавить или переопределить переменные окружения для одного конкретного запускаемого приложения. Если вы работаете в Bash, просто перечислите их имена и значения, разделённые пробелом, перед вызовом программы. Например, следующим образом:
{line-numbers: false, format: Bash}
```
MOZ_WEBRENDER=1 LANG="en_US.UTF-8" /opt/firefox/bin/firefox
```

Для других интерпретаторов (например, Bourne Shell) вам придётся использовать утилиту `env`. Вызовите утилиту, перечислите через пробел переменные окружения и вызовите нужное вам приложение. Например так:
{line-numbers: false, format: Bash}
```
env MOZ_WEBRENDER=1 LANG="en_US.UTF-8" /opt/firefox/bin/firefox
```

Если вызвать утилиту `env` без параметров, она выведет список всех определённых в данный момент переменных окружения текущего экземпляра интерпретатора. Попробуйте выполнить следующую команду в своём терминале:
{line-numbers: false, format: Bash}
```
env
```

Вызов встроенной команды `export` без параметров делает то же самое, что и `env`. В большинстве случаев предпочтительней использовать `export`. Во-первых, вывод этой команды отсортирован. Во-вторых, все значения переменных заключены в двойные кавычки, что позволяет избежать неоднозначностей, когда в значении встречается перевод строки.

Исторически сложилось так, что имена переменных окружения пишутся буквами в верхнем регистре. Поэтому хорошей практикой считается давать имена в нижнем регистре для всех локальных переменных. Таким образом вы гарантированно избежите случайного использования одной переменной вместо другой.

### Локальные переменные

Мы рассмотрели примеры объявления пользовательских переменных. Они могут быть как локальными, так и переменными окружения.

Если вы не использовали служебное слово `export` при объявлении переменной и не передавали её при вызове приложения, то она будет локальной. Это означает, что переменная будет доступна только в текущем экземпляре интерпретатора. Говорят, что она имеет **ограниченную область видимости**. При этом никакие дочерние процессы (кроме subshell) не наследуют локальные переменные.

Рассмотрим пример. Предположим, что вы объявили переменную в окне терминала MSYS следующим образом: 
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

Теперь в этом же окне терминала вы можете распечатать её значение:
{line-numbers: false, format: Bash}
```
echo "$filename"
```

Та же самая команда отработает корректно, если выполнить её в subshell:
{line-numbers: false, format: Bash}
```
(echo "$filename")
```

Однако, если вы попытаетесь получить доступ к переменной из дочернего процесса, то получите пустое значение. Чтобы это сделать, создайте и выполните скрипт с выводом переменной через `echo` или запустите новый экземпляр интерпретатора в окне терминала. Например, так:
{line-numbers: false, format: Bash}
```
bash -c 'echo "$filename"'
```

В опции `-c` передаётся команда, которая будет выполнена запущенным экземпляром `bash`. Аналогичный вызов `bash` происходит неявно при запуске скрипта из командного интерпретатора.

Обратите внимание на одинарные кавычки `'`, в которые мы поместили команду `echo`. Они отключают все подстановки для заключённой в них строки. В отличие от них двойные кавычки разрешают подстановки команд и параметров. Если в нашем вызове `bash` использовать двойные кавычки, то в результате подстановки параметров, получим следующее:
{line-numbers: false, format: Bash}
```
bash -c "echo README.txt"
```

Тогда значение переменной `filename` корректно напечатается из дочернего процесса `bash`. Но причина этого не в том, что переменная была передана в дочерний процесс, а в том что её значение попало в параметр команды вызова `bash`.

При изменении локальной переменной в subshell, её значение в родительском процессе не изменится. Например, в результате следующих команд напечатается строка "README.txt":
{line-numbers: true, format: Bash}
```
filename="README.txt"
(filename="CHANGELOG.txt")
echo "$filename"
```

То есть присвоение переменной `filename` нового значения в subshell никак не отразилось на родительском процессе.

После объявления локальной переменной она попадает в список **переменных оболочки** (shell variables). К ним относятся все локальные и переменные окружения, доступные в текущем экземпляре интерпретатора. Их можно вывести встроенной командой `set`, вызванной без параметров. Попробуйте найти нашу переменную `filename` следующим образом:
{line-numbers: false, format: Bash}
```
set | grep filename=
```

В выводе этой команды вы увидите строчку:
{line-numbers: false, format: Bash}
```
filename=README.txt
```

## Тип хранимого значения

TODO
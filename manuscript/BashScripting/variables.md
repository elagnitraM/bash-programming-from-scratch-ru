## Переменные

Мы уже сталкивались с переменными, когда говорили о `PATH`, хранящем список системных путей, и доступе к параметрам Bash скрипта по именам `$1`, `$2` и т.д. Теперь рассмотрим тему переменных подробнее.

### Объявление и использование

Что представляет собой переменная в контексте программирования? Это некоторая область памяти (обычно оперативной), в которой хранится значение. В первых языках программирования (например, [**ассемблере**](https://ru.wikipedia.org/wiki/Язык_ассемблера)) обращение к переменным происходит по их адресу. То есть чтобы записать новое значение или прочитать текущее, вы должны указывать адрес памяти. В 32-разрядных архитектурах длина адреса 4 байта (число от 0 до 4294967295), а в 64-разрядных он в два раза больше. Очевидно, что запоминать и оперировать такими большими числами неудобно. Поэтому более современные языки программирования позволяют вместо адресов работать с именами переменных. Эти имена в процессе компиляции или интерпретации программы транслируются в адреса памяти. Таким образом всю работу по "запоминанию" больших чисел берёт на себя компилятор или интерпретатор.

Переменные в языке Bash деляться на два типа: пользовательские (variables) и специальные (**special parameters**). К первому типу относятся все объявления пользователя. Ко второму - переменные, устанавливаемые самим интерепртатором. Они доступны только для чтения.

Пользовательские переменные вы можете объявлять следующим образом:
{line-numbers: false, format: Bash}
```
FILENAME="README.txt"
```

Обратите внимание, что пробел до и после знака равно не ставится. То есть следюующее объявление завершится с ошибкой:
{line-numbers: false, format: Bash}
```
FILENAME = "README.txt"
```

В этом случае Bash обработает эту строку как вызов команды с именем `FILENAME` и двумя параметрами: `=` и `"README.txt"`

I> В именах переменных можно использовать только символы латинского алфавита, числа и знак подчёркивания. Имя не должно начинаться с числа.

При объявлении переменной `FILENAME` в памяти процесса интерпретатора выделяется область памяти, в которой сохраняется строка `README.txt`. Чтобы её прочитать, следует обратиться к ней по имени. Но интерпретатор должен понять, что речь идёт не о команде или строке, а о переменной. Чтобы сообщить ему эту информацию, необходимо поставить знак доллара `$` перед именем:
{line-numbers: false, format: Bash}
```
$FILENAME
```

Что означает знак доллара? Встретив его в команде, Bash запускает механизм подстановки параметров (**parameter expansion**). Он заключается в подстановке значения переменной вместо её имени. Рассмотрим следующую команду:
{line-numbers: false, format: Bash}
```
cp $FILENAME ~
```

Bash развернёт её так:
{line-numbers: false, format: Bash}
```
cp README.txt ~
```

Учтите, что при подстановке параметров, Bash может совершать дополнительные действия. Например, объявим нашу переменную так:
{line-numbers: false, format: Bash}
```
FILENAME="my file.txt"
```

Тогда вызов утилиты `cp` будет развёрнут следующим образом:
{line-numbers: false, format: Bash}
```
cp my file.txt ~
```

В этом случае после подстановки имени переменной Bash выполнил word splitting и мы получили вместо одного параметра два. Очевидно, что такой вызов `cp` завершится ошибкой, потому что файлов `my` и `file.txt` не существует.

Проблема возникнет и в том случае, если в значении переменной встречается символ подстановки. Например:
{line-numbers: false, format: Bash}
```
FILENAME="*file.txt"
rm $FILENAME
```

В результате этой команды будут удалены все файлы, заканчивающиеся на `file.txt`. В таком поведении виноват механизм globbing, который отработает после подстановки параметра. В результате его работы в команду `rm` будут переданы все файлы из текущего каталога, имена которых смоответствуют шаблону поиска `*file.txt`. Например:
{line-numbers: false, format: Bash}
```
rm report_file.txt myfile.txt msg_file.txt
```

Чтобы избежать манипуляций Bash над подставленным значением переменной, заключайте обращение к ней в кавычки:
{line-numbers: true, format: Bash}
```
FILENAME1="my file.txt"
cp "$FILENAME1" ~

FILENAME2="*file.txt"
rm "$FILENAME2"
```

Благодаря этому, значение будет использовано без каких-либо изменений:
{line-numbers: false, format: Bash}
```
cp "my file.txt" ~
rm "*file.txt"
```

Запись имени переменной со знаком `$` вначале является сокращенной формой. В полном виде запись выглядит так:
{line-numbers: false, format: Bash}
```
${FILENAME}
```

Такая форма поможет избежать неоднозначности, если сразу за именем переменной следует текст. Например
{line-numbers: true, format: Bash}
```
PREFIX="my"
NAME="file.txt"
cp "$PREFIX_$NAME" ~
```

В этом случае при подстановке параметров интерпретатор будет искать переменную с именем `PREFIX_`. То есть он приклеит подчёркивание к имени. Чтобы избежать этой проблемы можно воспользоваться полной формой записи:
{line-numbers: false, format: Bash}
```
cp "${PREFIX}_${NAME}" ~
```

Либо заключить каждое имя переменной в кавычки:
{line-numbers: false, format: Bash}
```
cp "$PREFIX"_"$NAME" ~
```

Устранение неоднозначности - не единственный случай, когда пригодится полная форма записи подстановки. Также она будет полезна, когда переменная не определена. В этом случае вместо её значения можно подставить некоторое значение по-умолчанию. Например:
{line-numbers: false, format: Bash}
```
cp file.txt "${DIRECTORY:-~}"
```

При обработке этой команды Bash проверит, определена ли переменная с именем `DIRECTORY` и имеет ли она непустое значение. Если это так, произойдёт обычная подстановка. В противном случае будет использовано значение, следующее за символом `-`. В нашем примере это домашний каталог пользователя `~`.

Все варианты задания значения по умолчанию при подстановке приведены в таблице 3-1.

{caption: "Таблица 3-1. Задание значения по умолчанию при подстановке", width: "100%"}
| Форма записи | Описание|
| --- | --- |
| ${parameter:-word} | Если переменная `parameter` не объявлена или имеет пустое значение, будет подставлено занчение по умолчанию `word`. В противном случае подставляется значение переменной. |
|  | |
| ${parameter:=word} | Если переменная не объявлена или имеет пустое значение, ей будет присвоено занчение по умолчанию, которое затем будет подставлено. В противном случае подставляется значение переменной. Переопределение позиционных и специальных параметров таким способом не допустимо. |
|  | |
| ${parameter:?word} | Если переменная не объявлена или имеет пустое значение, значение по умолчанию будет выведено в стандартный поток ошибок. После этого выполнение скрипта будет завершено с кодом возврата отличным от 0. В противном случае подставляется значение переменной. |
|  | |
| ${parameter:+word} | Если переменная не объявлена или имеет пустое значение, ничего не будет подставлено. В противном случае подставляется значение по умолчанию. |

### Српециальные параметры

### Типы
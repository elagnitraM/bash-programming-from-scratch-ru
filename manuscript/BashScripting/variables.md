## Переменные и параметры

Мы уже сталкивались с переменными, когда говорили о `PATH`, хранящем список системных путей, и доступе к позиционным параметрам Bash-скрипта по именам `$1`, `$2` и т.д. Теперь рассмотрим тему переменных подробнее.

Что представляет собой переменная в контексте программирования? Это некоторая область памяти (обычно оперативной), в которой хранится значение. В первых языках программирования (например, [**ассемблере**](https://ru.wikipedia.org/wiki/Язык_ассемблера)) обращение к переменным происходит по их адресу. То есть, чтобы записать новое значение или прочитать текущее, вы должны указывать адрес памяти. В 32-разрядных архитектурах длина адреса 4 байта (число от 0 до 4294967295), а в 64-разрядных он в два раза больше. Очевидно, что запоминать и оперировать такими большими числами неудобно. Поэтому современные языки программирования позволяют вместо адресов работать с именами переменных. Эти имена в процессе компиляции или интерпретации программы транслируются в адреса памяти. Таким образом всю работу по "запоминанию" больших чисел берёт на себя компилятор или интерпретатор.

### Классификация переменных

Интерпретатор Bash может работать в двух основных режимах: интерактивном (командная оболочка) и неинтерактивном (исполнение скриптов). Переменные активно используются в каждом из них. Задачи решаемые переменными в этих режимах различаются. Это различие привело к появлению нескольких классификаций переменных в Bash.

Для удобства рассмотрения сделаем небольшое упрощение в терминологии, которое в общем не совсем правильно. При обсуждении скриптов, будем использовать тремин "переменная" (variable). Когда же обсуждается командная оболчка и аргументы командной строки, будем использовать термин "параметр" (parameter). Это позволит избежать путанницы. В английской литературе эти термины часто используются как синонимы.

Какие же классификации переменных есть в Bash? Таблица 3-1 демонстрирует их в кратком виде.

{caption: "Таблица 3-1. Классификация переменных в Bash", width: "100%"}
| Признак классификации | Типы | Определение | Примеры |
| --- | --- | --- | --- |
| Доступность в процессах | Глобальные переменные (переменные окружения) | Доступны в любом экземпляре запущенного интерпретатора. Выводятся утилитой `env`, запущенной без параметров. | `echo "$PATH"` |
|                     | Локальные переменные | Доступны только в конкретном экземпляре запущенного интерпретатора. | `filename="README.txt" ; echo "$filename"` |
|  | | | |
| Тип хранимого значения | Строковые | Хранят строки. | `filename="README.txt"` |
|                     | Целочисленные | Хранят целые числа. | `declare -i number=10/2 ; echo "$number"` |
|                     | Константные | Хранят неизменяемые значения или константы. | `readonly CONSTANT="ABC" ; echo "$CONSTANT"` |
|                     | | | `declare -r CONSTANT="ABC" ; echo "$CONSTANT"` |
|                     | Массивы | Хранят нумерованные списки строк. | `cities=("London" "New York" "Berlin") ; echo "${cities[1]}"` |
|  | | | `cities[0]="London" ; cities[1]="New York" ; cities[2]="Berlin" ; echo "${cities[1]}"` |
|  | | | |
| Механизм установки | Зарезервированные (системные) | Устанавливаются интерпретатором и нужны для его корректной работы. | `echo "$PATH"` |
|                      | Пользовательские | Устанавливаются пользователем. | `filename="README.txt" ; echo "$filename"` |

Рассмотрим каждый из приведённых типов переменных.

### Механизм установки

#### Пользовательские переменные

Начнём наше знакомство с пользовательских переменных. Как следует из названия, они задаются пользователем для хранения промежуточных результатов работы скрипта. 

Чтобы объявить переменную, укажите её имя, знак равно и значение. Например, следующая строка объявляет переменную с именем `filename`, значение которой равно `README.txt`:
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

Обратите внимание, что пробел до и после знака равно не ставится. То есть следующее объявление завершится с ошибкой:
{line-numbers: false, format: Bash}
```
filename = "README.txt"
```

Bash обработает такую строку как вызов команды с именем `filename` и двумя параметрами: `=` и `"README.txt"`

I> В именах переменных можно использовать только символы латинского алфавита, числа и знак подчёркивания. Имя не должно начинаться с числа. Регистр букв важен, т.е. `filename` и `FILENAME` — это две разные переменные.

При объявлении переменной `filename` в памяти процесса интерпретатора выделяется область памяти, в которой сохраняется строка `README.txt`. Чтобы её прочитать, следует обратиться к ней по имени. Но интерпретатор должен понять, что речь идёт не о команде или строке, а о переменной. Чтобы сообщить ему эту информацию, необходимо поставить знак доллара `$` перед именем:
{line-numbers: false, format: Bash}
```
$filename
```

Что означает знак доллара? Встретив его в команде, Bash запускает механизм подстановки переменных (**parameter expansion**). Этот механизм заменяет все вхождения имени переменной на её значение. Рассмотрим следующую команду:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

После подстановки она будет выглядеть так:
{line-numbers: false, format: Bash}
```
cp README.txt ~
```

Учтите, что подстановка переменных не единственная. За ней следуют другие, что может привести к ошибкам. Рассмотрим пример. Предположим, что нам нужно оперировать файлом, в имени которого встречается пробел. Тогда объявление переменной `filename` с его именем будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
filename="my file.txt"
```

Далее эта переменная используется в вызове утилиты `cp`, как и раньше:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

После подстановки переменных Bash выполняет word splitting. В результате получится следующий вызов утилиты `cp`:
{line-numbers: false, format: Bash}
```
cp my file.txt ~
```

Такой вызов завершится с ошибкой, потому что вместо одного параметра с именем файла, мы получили два: `my` и `file.txt`. Таких файлов не существует.

Проблема возникнет и в том случае, если в значении переменной встречается символ подстановки. Например:
{line-numbers: false, format: Bash}
```
filename="*file.txt"
rm $filename
```

В результате этой команды будут удалены все файлы, заканчивающиеся на `file.txt`. В таком поведении виноват механизм globbing, который также выполняется после подстановки переменных. В результате его работы в утилиту `rm` будут переданы все файлы из текущего каталога, имена которых соответствуют шаблону поиска `*file.txt`. Например, мы можем получить следующий вызов `rm`:
{line-numbers: false, format: Bash}
```
rm report_file.txt myfile.txt msg_file.txt
```

Чтобы избежать нежелательных подстановок Bash, заключайте все обращения к переменным в двойные кавычки `"`. Например, следующим образом:
{line-numbers: true, format: Bash}
```
filename1="my file.txt"
cp "$filename1" ~

filename2="*file.txt"
rm "$filename2"
```

Благодаря этому, значение переменной будет подставлено без дальнейших изменений:
{line-numbers: false, format: Bash}
```
cp "my file.txt" ~
rm "*file.txt"
```

Мы уже познакомились с несколькими [подстановками](http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Expansions), выполняемыми Bash. В таблице 3-2 приведены остальные, а также указан их порядок выполнения. 

{caption: "Таблица 3-2. Подстановки Bash", width: "100%"}
| Приоритет | Подстановка | Комментарий | Пример |
| --- | --- | --- | --- |
| 1 | Brace Expansion | Подстановка фигурных скобок `{` и `}`. | `echo a{d,c,b}e` |
|  | | | |
| 2 | Tilde Expansion | Подстановка символа тильда `~`. | `cd ~` |
|  | | | |
| 3 | Parameter Expansion | Подстановка параметров и переменных. | `echo "$PATH"` |
|  | | | |
| 4 | Arithmetic Expansion | Подстановка вместо арифметических выражений их значений. | `echo $((4+3))` |
|  | | | |
| 5 | Command Substitution | Подстановка вместо команды её вывода. | `echo $(cat README.txt)` |
|  | | | |
| 6 | Process Substitution | Подстановка вместо команды её вывода. В отличие от Command Substitution выполняется [асинхронно](https://ru.wikipedia.org/wiki/Асинхронность#Асинхронность_в_информатике), а ввод и вывод команды привязаны к временному файлу. | `diff <(sort file1.txt) <(sort file2.txt)` |
|  | | | |
| 7 | Word Splitting | Разделение аргументов командной строки на слова и передача их в качестве отдельных параметров. | `cp file1.txt file2.txt ~` |
|  | | | |
| 8 | Filename Expansion (globbing) | Подстановка имён файлов вместо шаблонов. | `rm -rf *` |
|  | | | |
| 9 | Quote Removal | Удаление всех неэкранированных символов `\`, `'` и `"`, которые не были получены в результате одной из предыдущих подстановок | `cp "my file.txt" ~` |

Запись имени переменной со знаком `$` в начале является сокращенной формой. В полном виде запись выглядит так:
{line-numbers: false, format: Bash}
```
${filename}
```

Такая форма поможет избежать неоднозначности, если сразу за именем переменной следует текст. Например в следующем случае:
{line-numbers: true, format: Bash}
```
prefix="my"
name="file.txt"
cp "$prefix_$name" ~
```

Здесь при подстановке параметров интерпретатор будет искать переменную с именем `prefix_`. То есть он приклеит подчёркивание к имени. Чтобы избежать этой проблемы можно воспользоваться полной формой записи:
{line-numbers: false, format: Bash}
```
cp "${prefix}_${name}" ~
```

Альтернативное решение — заключить каждое имя переменной в кавычки:
{line-numbers: false, format: Bash}
```
cp "$prefix"_"$name" ~
```

Устранение неоднозначности — не единственный случай, когда пригодится полная форма записи подстановки. Также она будет полезна, когда переменная не определена. В этом случае вместо её значения можно подставить некоторое значение по умолчанию. Например:
{line-numbers: false, format: Bash}
```
cp file.txt "${directory:-~}"
```

При обработке этой команды Bash проверит, определена ли переменная с именем `directory` и имеет ли она непустое значение. Если это так, произойдёт обычная подстановка. В противном случае будет использовано значение, следующее за символом `-`. В нашем примере это домашний каталог пользователя `~`.

Все варианты задания значения по умолчанию при подстановке приведены в таблице 3-3.

{caption: "Таблица 3-3. Задание значения по умолчанию при подстановке", width: "100%"}
| Форма записи | Описание|
| --- | --- |
| `${parameter:-word}` | Если переменная `parameter` не объявлена или имеет пустое значение, будет подставлено значение по умолчанию `word`. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:=word}` | Если переменная не объявлена или имеет пустое значение, ей будет присвоено значение по умолчанию, которое затем будет подставлено. В противном случае подставляется значение переменной. Переопределение позиционных и специальных параметров таким способом не допустимо. |
|  | |
| `${parameter:?word}` | Если переменная не объявлена или имеет пустое значение, значение по умолчанию будет выведено в стандартный поток ошибок. После этого выполнение скрипта будет завершено с кодом возврата отличным от 0. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:+word}` | Если переменная не объявлена или имеет пустое значение, ничего не будет подставлено. В противном случае подставляется значение по умолчанию. |

{caption: "Упражнение 3-1. Использование полной формы подстановки параметров", format: text, line-numbers: false}
```
Напишите скрипт, который ищет файлы с расширением TXT в текущем каталоге, исключая его подкаталоги. Все найденные файлы должны быть скопированы или перемещены в домашний каталог пользователя. При вызове скрипта требуемая операция передаётся в первом позиционном параметре. Если она не указана, выполняется копирование.
```

#### Зарезервированные переменные

Кроме пользователя переменные может объявлять сам интерпретатор. В этом случае они называются зарезервированными (reserved) или переменными оболчки (shell variables). Как правило интерпретатор присваивает им значение по умолчанию, которое в дальнейшем может меняться пользователем.

Зарезервированные переменные Bash деляться на две группы:

1. Переменные Bourne Shell.
2. Переменные Bash.

Первые были унаследованы из Bourne Shell и нужны для обсепечения POSIX-совместимости. Наиболее важные из них представлены в таблице 3-4.

{caption: "Таблица 3-4. Зарезервированные переменные Bourne Shell", width: "100%"}
| Имя | Значение |
| --- | --- |
| `HOME` | Домашний каталог текущего пользователя. Значение переменной используется при вызове встроенной команды `cd` без параметров и подстановки символа тильда `~`. |
|  | |
| `IFS` | Список следующих друг за другом символов, которые используются в качестве разделителей при обработке вводимых строк (в том числе и для word splitting). По умолчанию это символы пробела, [табуляции](https://ru.wikipedia.org/wiki/Табуляция) и перевода строки. |
|  | |
| `PATH` | Список путей, разделённый двоеточиями, по которым интерпретатор ищет вызываемые утилиты и программы. |
|  | |
| `PS1` | Приглашение командной строки. Может состоять из набора [управляющих символов](https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html#Controlling-the-Prompt), которые будут заменены перед выводом на конкретные значения (например, имя текущего пользователя). |

В Bash были добавлены новые зарезервированные переменные. Наиболее важные из них представлены в таблице 3-5.

{caption: "Таблица 3-5. Зарезервированные переменные Bash", width: "100%"}
| Имя | Значение |
| --- | --- |
| `BASH` | Полный путь, который использовался для запуска текущего экземпляра Bash. |
|  | |
| `BASHOPTS` | Список [дополнительных опций](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin) текущего экземпляра Bash, разделённых двоеточиями. |
|  | |
| `BASH_VERSION` | Номер версии текущего экземпляра Bash. |
|  | |
| `GROUPS` | Список групп, к которым относится текущий пользователь. |
|  | |
| `HISTCMD` | Номер текущей команды в истории команд. |
|  | |
| `HISTFILE` | Файл, в котором сохраняется история команд. Значение по умолчанию равно `~/.bash_history`. |
|  | |
| `HISTFILESIZE` | Максимально допустимое число строк в файле истории команд. Значение по умолчанию 500. |
|  | |
| `HISTSIZE` | Максимально допустимое число команд в файле истории команд. Значение по умолчанию 500. |
|  | |
| `HOSTNAME` | Имя текущего компьютера как узла вычислительной сети. |
|  | |
| `HOSTTYPE` | Строка, описывающая аппаратную платформу, на которой запущен Bash. |
|  | |
| `LANG` | [Региональные настройки](https://ru.wikipedia.org/wiki/Региональные_настройки_(программирование)) пользовательского интерфейса. Некоторые из них переопределяться переменными `LC_ALL`, `LC_COLLATE`, `LC_CTYPE`, `LC_MESSAGES`, `LC_NUMERIC`, `LC_TYPE`. |
|  | |
| `MACHTYPE` | Строка, полностью описывающая систему, на которой запущен Bash. Включает в себя информацию из `HOSTTYPE` и `OSTYPE`. |
|  | |
| `OLDPWD` | Предыдущий рабочий каталог, который был установлен встроенной командой `cd`. |
|  | |
| `OSTYPE` | Строка, описывающая ОС, на которой запущен Bash. |
|  | |
| `POSIXLY_CORRECT` | Если эта переменная определена, Bash работает в режиме [POSIX-совместимости](https://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html#Bash-POSIX-Mode). |
|  | |
| `PWD` | Текущий рабочий каталог, который был установлен встроенной командой `cd`. |
|  | |
| `RANDOM` | Каждый раз при чтении этой переменной возвращается случайное число от 0 до 32767. В случае записи переменной назначается инициализирующее число ([seed](https://en.wikipedia.org/wiki/Random_seed)) для [генератора псевдослучайных чисел](https://ru.wikipedia.org/wiki/Генератор_псевдослучайных_чисел). |
|  | |
| `SECONDS` | Количество секунд, прошедших с запуска текущего экземпляра Bash. |
|  | |
| `SHELL` | Полный путь к командному интерпретатору, установленному для текущего пользователя. |
|  | |
| `SHELLOPTS` | Список [дополнительных опций](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin) комндного интерпретатора, разделённых двоеточиями. |
|  | |
| `SHLVL` | Уровень вложенности текущего экземпляра Bash. Эта переменная увеличивается на единицу каждый раз, когда вы запускаете Bash из командного интерпретатора. |
|  | |
| `UID` | Идентификатор текущего пользователя. |

### Доступность в процессах

#### Глобальные переменные

#### Локальные

Рассмотренные нами пользовательские переменные являются локальными. Это значит, что после их определения они не будут доступны в другом экземпляря командного интерпретатора, если вы его запустите. Другими словами вы можете объявить переменную в окне терминала MSYS, например, так:
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

После этого переменная `filename` попадёт в список **переменных оболочки** (shell variables), которые выводятся встроенной командой `set`, вызванной без параметров. Выполните следующую команду:
{line-numbers: false, format: Bash}
```
set | grep filename=
```

В её выводе вы увидите следующую строчку:
{line-numbers: false, format: Bash}
```
filename=README.txt
```

Вы получите корректное значение переменной, если попробуйте её вывести с помощью команды `echo`, набранной в том же терминале, в котором её определили:
{line-numbers: false, format: Bash}
```
echo "$filename"
```

Однако, если сделать точно такой же вывод из скрипта, напечатается пустая строка. То же самое произойдёт, если запустить новый экземпляр интерпретатора и выполнить `echo` в нём. Например, так:
{line-numbers: false, format: Bash}
```
filename="README.txt" ; bash -c 'echo $filename'
```

Именно такой вызов `bash` происходит неявно при запуске скрипта из командного интерпретатора.

I> Обратите внимание на одинарные кавычки `'`. Они отключают все подстановки для заключённой в них строки. В отличие от них двойные кавычки разрешают подстановки команд и параметров. Если в нашем примере использовать двойные кавычки, то в результате подстановки получится следующая команда вызова `bash`:
{line-numbers: false, format: Bash}
```
bash -c "echo README.txt"
```

// TODO: Таблица

### Специальные параметры

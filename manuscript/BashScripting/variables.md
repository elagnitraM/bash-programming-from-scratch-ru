## Переменные и параметры

Мы уже сталкивались с переменными, когда говорили о `PATH`, хранящем список системных путей, и доступе к позиционным параметрам Bash-скрипта по именам `$1`, `$2` и т.д. Теперь рассмотрим тему переменных подробнее.

Что представляет собой переменная в контексте программирования? Это некоторая область памяти (обычно оперативной), в которой хранится значение. В первых языках программирования (например, [**ассемблере**](https://ru.wikipedia.org/wiki/Язык_ассемблера)) обращение к переменным происходит по их адресу. То есть, чтобы записать новое значение или прочитать текущее, вы должны указывать адрес памяти. В 32-разрядных архитектурах длина адреса 4 байта (число от 0 до 4294967295), а в 64-разрядных он в два раза больше. Очевидно, что запоминать и оперировать такими большими числами неудобно. Поэтому современные языки программирования позволяют вместо адресов работать с именами переменных. Эти имена в процессе компиляции или интерпретации программы транслируются в адреса памяти. Таким образом всю работу по "запоминанию" больших чисел берёт на себя компилятор или интерпретатор.

Зачем нужны переменные? Из предыдущих примеров очевидно, что переменные используются для хранения каких-то значений. Обычно при этом преследуется одна из следующих целей:

1. Передать информацию из одной части программы или системы в другую.

2. Сохранить промежуточный результат вычислений для дальнейшего использования.

3. Сохранить текущее состояние программы или системы. Состояние может определять поведение.

4. Задать константное значение, которое будет многократно использоваться в дальнейшем.

Для каждой из целей в языках программирования вводится специальный тип переменной. Язык Bash не является исключением.

### Классификация переменных

Интерпретатор Bash может работать в двух основных режимах: интерактивном (командная оболочка) и неинтерактивном (исполнение скриптов). В каждом из них переменные решают сходные задачи, но контексты их использования различаются. Из-за этого в Bash больше признаков для классификации переменных, чем в большинстве других языков.

Для удобства рассмотрения сделаем сразу небольшое упрощение в терминологии, которое в общем не совсем правильно. При обсуждении скриптов, будем использовать термин "переменная" (variable). Когда же обсуждается командная оболочка и аргументы командной строки, будем использовать термин "параметр" (parameter). Это позволит избежать путаницы. В английской литературе эти термины часто используются как синонимы.

Какие же классификации переменных есть в Bash? Таблица 3-1 демонстрирует их в кратком виде.

{caption: "Таблица 3-1. Классификация переменных в Bash", width: "100%"}
| Признак классификации | Типы | Определение | Примеры |
| --- | --- | --- | --- |
| Механизм установки | Пользовательские переменные | Устанавливаются пользователем. | `filename="README.txt" ; echo "$filename"` |
|  | | | |
|                    | Зарезервированные (системные) переменные | Устанавливаются интерпретатором и нужны для его корректной работы. | `echo "$PATH"` |
|  | | | |
|                    | Специальные параметры | Устанавливаются интерпретатором и доступны только для чтения. | `echo "$?"` |
|  | | | |
| [Область видимости](https://ru.wikipedia.org/wiki/Область_видимости) | Переменные окружения (или глобальные) | Доступны в любом экземпляре запущенного интерпретатора. Выводятся утилитой `env`, запущенной без параметров. | `echo "$PATH"` |
|  | | | |
|                     | Локальные переменные | Доступны только в конкретном экземпляре запущенного интерпретатора. | `filename="README.txt" ; echo "$filename"` |
|  | | | |
| Содержимое | Строка | Хранит строку. | `filename="README.txt"` |
|  | | | |
|            | Число | Хранит целое число. | `declare -i number=10/2 ; echo "$number"` |
|  | | | |
|            | Индексируемый массив | Хранит нумерованный список строк. | `cities=("London" "New York" "Berlin") ; echo "${cities[1]}"` |
|  | | | `cities[0]="London" ; cities[1]="New York" ; cities[2]="Berlin" ; echo "${cities[1]}"` |
|            | Ассоциативный массив | Структура данных, каждый элемент которой представляет собой пару ключ-значение. Ключём и значением являются строки. | `declare -A cities=( ["Alice"]="London" ["Bob"]="New York" ["Eve"]="Berlin" ) ; echo "${cities[Bob]}"` |
| Возможность изменения | Константны | Не могут быть удалены. Хранят значения, которые нельзя переопределить. | `readonly CONSTANT="ABC" ; echo "$CONSTANT"` |
|                     | | | `declare -r CONSTANT="ABC" ; echo "$CONSTANT"` |
|  | | | |
|                     | Переменные | Могут быть удалены. Их значения можно переопределить. | `filename="README.txt"` |

Рассмотрим каждый из приведённых типов переменных.

### Механизм установки

#### Пользовательские переменные

Начнём наше знакомство с пользовательских переменных. Как следует из названия, они задаются пользователем для хранения промежуточных результатов работы скрипта, его состояния или константных значений.

Чтобы объявить переменную, укажите её имя, знак равно и значение без пробелов. Например, следующая строка объявляет переменную с именем `filename`, значение которой равно `README.txt`:
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

Обратите внимание, что пробел до и после знака равно не ставится. То есть следующее объявление завершится с ошибкой:
{line-numbers: false, format: Bash}
```
filename = "README.txt"
```

Bash обработает такую строку как вызов команды с именем `filename` и двумя параметрами: `=` и `"README.txt"`

В именах переменных можно использовать только символы латинского алфавита, числа и знак подчёркивания. Имя не должно начинаться с числа. Регистр букв важен, т.е. `filename` и `FILENAME` — это две разные переменные.

При объявлении переменной `filename` в памяти процесса интерпретатора выделяется область памяти, в которой сохраняется строка `README.txt`. Чтобы её прочитать, следует обратиться к ней по имени. Но интерпретатор должен понять, что речь идёт не о команде или строке, а о переменной. Чтобы сообщить ему эту информацию, необходимо поставить знак доллара `$` перед именем:
{line-numbers: false, format: Bash}
```
$filename
```

Что означает знак доллара? Встретив его в команде, Bash запускает механизм подстановки переменных (**parameter expansion**). Этот механизм заменяет все вхождения имени переменной на её значение. Рассмотрим следующую команду:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

После подстановки она будет выглядеть так:
{line-numbers: false, format: Bash}
```
cp README.txt ~
```

Учтите, что интерпретатор выполняет и другие подстановки. Невнимательное отношение к их порядку может привести к ошибкам. Рассмотрим пример. Предположим, что нам нужно оперировать файлом, в имени которого встречается пробел. Тогда объявление переменной `filename` с его именем будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
filename="my file.txt"
```

Далее эта переменная используется в вызове утилиты `cp`, как и раньше:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

После подстановки переменных Bash выполняет word splitting. В результате получится следующий вызов утилиты `cp`:
{line-numbers: false, format: Bash}
```
cp my file.txt ~
```

Такой вызов завершится с ошибкой, потому что вместо одного параметра с именем файла, мы получили два: `my` и `file.txt`. Таких файлов не существует.

Проблема возникнет и в том случае, если в значении переменной встречается символ подстановки. Например:
{line-numbers: false, format: Bash}
```
filename="*file.txt"
rm $filename
```

В результате этой команды будут удалены все файлы, заканчивающиеся на `file.txt`. В таком поведении виноват механизм globbing, который также выполняется после подстановки переменных. Из-за него в утилиту `rm` будут переданы все файлы из текущего каталога, имена которых соответствуют шаблону поиска `*file.txt`. После всех подстановок мы можем получить совершенно неожиданный вызов `rm`. Например такой:
{line-numbers: false, format: Bash}
```
rm report_file.txt myfile.txt msg_file.txt
```

Чтобы избежать нежелательных подстановок Bash, заключайте все обращения к переменным в двойные кавычки `"`. Например, следующим образом:
{line-numbers: true, format: Bash}
```
filename1="my file.txt"
cp "$filename1" ~

filename2="*file.txt"
rm "$filename2"
```

Благодаря этому, значение переменной будет подставлено без дальнейших изменений:
{line-numbers: false, format: Bash}
```
cp "my file.txt" ~
rm "*file.txt"
```

Мы уже познакомились с несколькими [подстановками](http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Expansions), выполняемыми Bash. В таблице 3-2 приведены остальные, а также указан их порядок выполнения. 

{caption: "Таблица 3-2. Подстановки Bash", width: "100%"}
| Порядок выполнения | Подстановка | Комментарий | Пример |
| --- | --- | --- | --- |
| 1 | Brace Expansion | Подстановка фигурных скобок `{` и `}`. | `echo a{d,c,b}e` |
|  | | | |
| 2 | Tilde Expansion | Подстановка символа тильда `~`. | `cd ~` |
|  | | | |
| 3 | Parameter Expansion | Подстановка параметров и переменных. | `echo "$PATH"` |
|  | | | |
| 4 | Arithmetic Expansion | Подстановка вместо арифметических выражений их значений. | `echo $((4+3))` |
|  | | | |
| 5 | Command Substitution | Подстановка вместо команды её вывода. | `echo $(< README.txt)` |
|  | | | |
| 6 | Process Substitution | Подстановка вместо команды её вывода. В отличие от Command Substitution выполняется [асинхронно](https://ru.wikipedia.org/wiki/Асинхронность#Асинхронность_в_информатике), а ввод и вывод команды привязаны к временному файлу. | `diff <(sort file1.txt) <(sort file2.txt)` |
|  | | | |
| 7 | Word Splitting | Разделение аргументов командной строки на слова и передача их в качестве отдельных параметров. | `cp file1.txt file2.txt ~` |
|  | | | |
| 8 | Filename Expansion (globbing) | Подстановка имён файлов вместо шаблонов. | `rm ~/delete/*` |
|  | | | |
| 9 | Quote Removal | Удаление всех неэкранированных символов `\`, `'` и `"`, которые не были получены в результате одной из предыдущих подстановок | `cp "my file.txt" ~` |

{caption: "Упражнение 3-1. Тестирование подстановок Bash", format: text, line-numbers: false}
```
Выполните примеры каждой из подстановок Bash, приведённые в таблице 3-2. Удостоверьтесь, что поняли как был получен результат в каждом случае. Придумайте свои примеры.
```

Запись имени переменной со знаком `$` в начале является сокращенной формой подстановки. В полном виде она выглядит так:
{line-numbers: false, format: Bash}
```
${filename}
```

Такая форма поможет избежать неоднозначности, если сразу за именем переменной следует текст. Например в следующем случае:
{line-numbers: true, format: Bash}
```
prefix="my"
name="file.txt"
cp "$prefix_$name" ~
```

Здесь при подстановке параметров интерпретатор будет искать переменную с именем `prefix_`. То есть он приклеит символ подчёркивания к имени переменной. Чтобы избежать этой проблемы можно воспользоваться полной формой записи:
{line-numbers: false, format: Bash}
```
cp "${prefix}_${name}" ~
```

Альтернативное решение — заключить каждое имя переменной в кавычки:
{line-numbers: false, format: Bash}
```
cp "$prefix"_"$name" ~
```

Устранение неоднозначности — не единственный случай, когда пригодится полная форма записи подстановки. Также она будет полезна, когда переменная не определена. В этом случае вместо неё можно подставить некоторое значение по умолчанию. Например:
{line-numbers: false, format: Bash}
```
cp file.txt "${directory:-~}"
```

При обработке этой команды Bash проверит, определена ли переменная с именем `directory` и имеет ли она непустое значение. Если это так, произойдёт обычная подстановка. В противном случае будет использовано значение, следующее за символом `-`. В нашем примере это домашний каталог пользователя `~`.

Все варианты задания значения по умолчанию при подстановке приведены в таблице 3-3.

{caption: "Таблица 3-3. Задание значения по умолчанию при подстановке", width: "100%"}
| Форма записи | Описание|
| --- | --- |
| `${parameter:-word}` | Если переменная `parameter` не объявлена или имеет пустое значение, будет подставлено значение по умолчанию `word`. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:=word}` | Если переменная не объявлена или имеет пустое значение, ей будет присвоено значение по умолчанию, которое затем будет подставлено. В противном случае подставляется значение переменной. Переопределение позиционных и специальных параметров таким способом не допустимо. |
|  | |
| `${parameter:?word}` | Если переменная не объявлена или имеет пустое значение, значение по умолчанию будет выведено в стандартный поток ошибок. После этого выполнение скрипта будет завершено с кодом возврата отличным от 0. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:+word}` | Если переменная не объявлена или имеет пустое значение, подстановки не будет. В противном случае подставляется значение по умолчанию. |

{caption: "Упражнение 3-2. Использование полной формы подстановки параметров", format: text, line-numbers: false}
```
Напишите скрипт, который ищет файлы с расширением TXT в текущем каталоге, исключая его подкаталоги. Все найденные файлы должны быть скопированы или перемещены в домашний каталог пользователя. При вызове скрипта требуемая операция передаётся в первом позиционном параметре. Если она не указана, выполняется копирование.
```

#### Зарезервированные переменные

Кроме пользователя переменные может объявлять сам интерпретатор. В этом случае они называются **зарезервированными** (reserved) или **переменными оболочки** (shell variables). Как правило, интерпретатор присваивает им значение по умолчанию, которое в некоторых случаях может меняться пользователем.

Большая часть зарезервированных переменных используется для передачи информации в запускаемые из командного интерпретатора приложения. Некоторые из них нужны для хранения текущего состояния самого интерпретатора.

Зарезервированные переменные Bash делятся на две группы:

1. Переменные Bourne Shell.
2. Переменные Bash.

Первая группа была унаследована из Bourne Shell и нужна для обеспечения POSIX-совместимости. Наиболее часто используемые из этих переменных представлены в таблице 3-4.

{caption: "Таблица 3-4. Зарезервированные переменные Bourne Shell", width: "100%"}
| Имя | Значение |
| --- | --- |
| `HOME` | Домашний каталог текущего пользователя. Значение переменной используется при вызове встроенной команды `cd` без параметров и подстановке символа тильда `~`. |
|  | |
| `IFS` | Список следующих друг за другом символов, которые используются в качестве разделителей при обработке вводимых строк (в том числе и для word splitting). По умолчанию это символы пробела, [табуляции](https://ru.wikipedia.org/wiki/Табуляция) и перевода строки. |
|  | |
| `PATH` | Список путей, разделённый двоеточиями, по которым интерпретатор ищет вызываемые утилиты и программы. |
|  | |
| `PS1` | Приглашение командной строки. Может состоять из набора [управляющих символов](https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html#Controlling-the-Prompt), которые будут заменены перед выводом на конкретные значения (например, имя текущего пользователя). |

В Bash были добавлены новые зарезервированные переменные. В таблице 3-5 приведены наиболее часто используемые из них.

{caption: "Таблица 3-5. Зарезервированные переменные Bash", width: "100%"}
| Имя | Значение |
| --- | --- |
| `BASH` | Полный путь, который использовался для запуска текущего экземпляра Bash. |
|  | |
| `BASHOPTS` | Список [дополнительных опций](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin) текущего экземпляра Bash, разделённых двоеточиями. |
|  | |
| `BASH_VERSION` | Номер версии текущего экземпляра Bash. |
|  | |
| `GROUPS` | Список групп, к которым относится текущий пользователь. |
|  | |
| `HISTCMD` | Номер текущей команды в истории команд. |
|  | |
| `HISTFILE` | Файл, в котором сохраняется история команд. Значение по умолчанию равно `~/.bash_history`. |
|  | |
| `HISTFILESIZE` | Максимально допустимое число строк в файле истории команд. Значение по умолчанию 500. |
|  | |
| `HISTSIZE` | Максимально допустимое число команд в файле истории команд. Значение по умолчанию 500. |
|  | |
| `HOSTNAME` | Имя текущего компьютера как узла вычислительной сети. |
|  | |
| `HOSTTYPE` | Строка, описывающая аппаратную платформу, на которой запущен Bash. |
|  | |
| `LANG` | [Региональные настройки](https://ru.wikipedia.org/wiki/Региональные_настройки_(программирование)) пользовательского интерфейса. Некоторые из них переопределяться переменными `LC_ALL`, `LC_COLLATE`, `LC_CTYPE`, `LC_MESSAGES`, `LC_NUMERIC`, `LC_TYPE`. |
|  | |
| `MACHTYPE` | Строка, полностью описывающая систему, на которой запущен Bash. Включает в себя информацию из `HOSTTYPE` и `OSTYPE`. |
|  | |
| `OLDPWD` | Предыдущий рабочий каталог, который был установлен встроенной командой `cd`. |
|  | |
| `OSTYPE` | Строка, описывающая ОС, на которой запущен Bash. |
|  | |
| `POSIXLY_CORRECT` | Если эта переменная определена, Bash работает в режиме [POSIX-совместимости](https://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html#Bash-POSIX-Mode). |
|  | |
| `PWD` | Текущий рабочий каталог, который был установлен встроенной командой `cd`. |
|  | |
| `RANDOM` | Каждый раз при чтении этой переменной возвращается случайное число от 0 до 32767. В случае записи переменной назначается инициализирующее число ([seed](https://en.wikipedia.org/wiki/Random_seed)) для [генератора псевдослучайных чисел](https://ru.wikipedia.org/wiki/Генератор_псевдослучайных_чисел). |
|  | |
| `SECONDS` | Количество секунд, прошедших с запуска текущего экземпляра Bash. |
|  | |
| `SHELL` | Полный путь к командному интерпретатору, установленному для текущего пользователя. |
|  | |
| `SHELLOPTS` | Список [дополнительных опций](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin) комндного интерпретатора, разделённых двоеточиями. |
|  | |
| `SHLVL` | Уровень вложенности текущего экземпляра Bash. Эта переменная увеличивается на единицу каждый раз, когда вы запускаете Bash из командного интерпретатора. |
|  | |
| `UID` | Идентификатор текущего пользователя. |

Обратите внимание, что есть несколько механизмов работы с зарезервированными переменными:

1. При запуске интерпретатор назначает переменной значение. В течении всей сессии оно остаётся неизменным. Пользователь может его прочитать, но не изменить. Примеры: `BASHOPTS`, `GROUPS`, `SHELLOPTS`, `UID`.

2. При запуске интерпретатор назначает переменной значение по умолчанию. Оно меняется в результате выполнения пользователем команд или иных событий. Некоторые переменные могут быть изменены непосредственно, хоть и не предназначены для этого. Примеры: `HISTCMD`, `OLDPWD`, `PWD`, `SECONDS`, `SHLVL`.

3. При запуске интерпретатор назначает переменной значение по умолчанию. Оно может быть изменено только непосредственно пользователем. Примеры: `HISTFILESIZE`, `HISTSIZE`

#### Специальные параметры

Специальные параметры всегда назначаются интерпретатором. Некоторые из них хранят состояние его запущенного экземпляра (например, PID). Другие служат для передачи параметров командной строки в вызываемые утилиты и приложения, а также чтения их кода возврата. Все позиционные параметры относятся к специальным.

Наиболее часто используемые специальные параметры представлены в таблице 3-6.

{caption: "Таблица 3-6. Специальные параметры Bash", width: "100%"}
| Имя | Значение |
| --- | --- |
| `$*` | Используется для подстановки позиционных параметров, начиная с первого (`$1`). Если применяется без двойных кавычек, каждый позиционный параметр заменяется на отдельное слово. Если указан в двойных кавычках, вместо него будет подставлено одно слово, содержащее все параметры. Они будут разделены первым символом зарезервированной переменной `IFS`. |
|  | |
| `$@` | Используется для подстановки позиционных параметров, начиная с первого (`$1`). При применении без двойных кавычек и с ними, каждый позиционный параметр заменяется на отдельное слово (как в случае `$*` без кавычек). |
|  | |
| `$1`,`$2`... | Используется для подстановки позиционного параметра, порядковый номер которого в десятичной системе соответствует указанному. |
|  | |
| `$?` | Подстановка кода возврата последней выполненной команды в активном режиме (foreground). Если команды выполнялись в конвейере, параметр хранит код возврата последней из них. |
|  | |
| `$-` | Подстановка опций текущего экземпляра интерпретатора. |
|  | |
| `$$` | Подстановка идентификатора процесса текущего экземпляра интерпретатора. В случае подстановки в subshell, запущенного в скобках `()`, возвращает PID вызвавшего его интерпретатора. |
|  | |
| `$!` | Подстановка идентификатора процесса последней команды, запущенной в фоновом режиме. |
|  | |
| `$0` | Подстановка имени текущего командного интерпретатора или выполняемого в данный момент скрипта. |
|  | |

Все рассмотренные нами специальные параметры доступны в режиме POSIX-совместимости.

### Область видимости

#### Переменные окружения

Все зарезервированные переменные Bash находятся в **глобальной области видимости** и называются **переменными окружения**.

Сначала разберёмся с тем, что означает **область видимости**? Это часть программы или в нашем случае системы, в которой имя переменной остаётся связанным с её значением. Другими словами имя корректно конвертируется в адрес памяти, по которому хранится значение переменной. За пределами области видимости то же самое имя может быть связано уже с другой переменной.

Область видимости называется глобальной, если распространяется на всю систему. Другими словами переменные этой области видимости доступны из любой части программы или системы.

Зачем интерпретатору понадобилось хранить переменные в глобальной области видимости? Дело в том, что в Unix есть набор настроек и переменных, которые влияют на поведение каждого приложения, запускаемого пользователем. Например, региональные настройки. Учитывая их, каждое запущенное приложение может адаптировать свой интерфейс. Именно для таких целей используются переменные окружения.

Когда один процесс порождает другой, дочерний процесс наследует все переменные окружения от родительского. В данном случае наследование означает создание собственной копии. Таким образом все утилиты и приложения, запущенные из командного интерпретатора, по умолчанию наследуют его переменные окружения. Это позволяет решить проблему передачи глобальных параметров во все приложения, запускаемые пользователем.

Важно заметить, что дочерние процессы могут изменять свои переменные окружения. В результате порождённые ими процессы будут наследовать эти изменения. Однако, это никак не отразится на соответствующих переменных родительского процесса.

Для создания новой переменной окружения используется зарезервированное слово `export`. Пример объявления такой переменной:
{line-numbers: false, format: Bash}
```
export BROWSER_PATH="/opt/firefox/bin"
```

Также вы можете поместить переменную в окружение после её объявления:
{line-numbers: true, format: Bash}
```
BROWSER_PATH="/opt/firefox/bin"
export BROWSER_PATH
```

Можно добавить или переопределить переменные окружения для одного конкретного запускаемого приложения. Если вы работаете в Bash, просто перечислите их имена и значения, разделённые пробелом, перед вызовом программы. Например, следующим образом:
{line-numbers: false, format: Bash}
```
MOZ_WEBRENDER=1 LANG="en_US.UTF-8" /opt/firefox/bin/firefox
```

Для других интерпретаторов (например, Bourne Shell) вам придётся использовать утилиту `env`. Вызовите утилиту, перечислите через пробел переменные окружения и вызовите нужное вам приложение. Например так:
{line-numbers: false, format: Bash}
```
env MOZ_WEBRENDER=1 LANG="en_US.UTF-8" /opt/firefox/bin/firefox
```

Если вызвать утилиту `env` без параметров, она выведет список всех определённых в данный момент переменных окружения текущего экземпляра интерпретатора. Попробуйте выполнить следующую команду в своём терминале:
{line-numbers: false, format: Bash}
```
env
```

Вызов встроенной команды `export` без параметров делает то же самое, что и `env`. В большинстве случаев предпочтительней использовать `export`. Во-первых, вывод этой команды отсортирован. Во-вторых, все значения переменных заключены в двойные кавычки, что позволяет избежать неоднозначностей, когда в значении встречается перевод строки.

Исторически сложилось так, что имена переменных окружения пишутся буквами в верхнем регистре. Поэтому хорошей практикой считается давать имена всем локальным переменным в нижнем регистре. Таким образом вы гарантированно избежите случайного использования одной переменной вместо другой.

#### Локальные переменные

Мы рассмотрели примеры объявления пользовательских переменных. Они могут быть как локальными, так и переменными окружения.

Если вы не использовали служебное слово `export` при объявлении переменной и не передавали её при вызове приложения, то она будет локальной. Это означает, что переменная будет доступна только в текущем экземпляре интерпретатора. Говорят, что она имеет **ограниченную область видимости**. При этом никакие дочерние процессы (кроме subshell) её не наследуют.

Рассмотрим пример. Предположим, что вы объявили переменную в окне терминала MSYS следующим образом: 
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

Теперь в этом же окне терминала вы можете распечатать её значение:
{line-numbers: false, format: Bash}
```
echo "$filename"
```

Та же самая команда отработает корректно, если выполнить её в subshell:
{line-numbers: false, format: Bash}
```
(echo "$filename")
```

Однако, если вы попытаетесь получить доступ к переменной из дочернего процесса, то получите пустое значение. Чтобы это сделать, создайте и выполните скрипт с выводом переменной через `echo` или запустите новый экземпляр интерпретатора в окне терминала. Например так:
{line-numbers: false, format: Bash}
```
bash -c 'echo "$filename"'
```

В опции `-c` передаётся команда, которая будет выполнена запущенным экземпляром `bash`. Аналогичный вызов `bash` происходит неявно при запуске скрипта из командного интерпретатора.

Обратите внимание на одинарные кавычки `'`, в которые мы поместили команду `echo`. Они отключают все подстановки для заключённой в них строки. В отличие от них двойные кавычки разрешают подстановки команд и параметров. Если в нашем вызове `bash` использовать двойные кавычки, то в результате подстановки параметров, получим следующее:
{line-numbers: false, format: Bash}
```
bash -c "echo README.txt"
```

Тогда значение переменной `filename` корректно напечатается из дочернего процесса `bash`. Но причина этого не в том, что переменная была передана в дочерний процесс, а в том что её значение попало в параметр команды вызова `bash`.

При изменении локальной переменной в subshell, её значение в родительском процессе не изменится. Например, в результате следующих команд напечатается строка "README.txt":
{line-numbers: true, format: Bash}
```
filename="README.txt"
(filename="CHANGELOG.txt")
echo "$filename"
```

То есть присвоение переменной `filename` нового значения в subshell никак не отразилось на родительском процессе.

После объявления локальной переменной она попадает в список **переменных оболочки** (shell variables). К ним относятся все локальные и переменные окружения, доступные в текущем экземпляре интерпретатора. Их можно вывести встроенной командой `set`, вызванной без параметров. Попробуйте найти нашу переменную `filename` следующим образом:
{line-numbers: false, format: Bash}
```
set | grep filename=
```

В выводе этой команды вы увидите следующую строчку:
{line-numbers: false, format: Bash}
```
filename=README.txt
```

### Содержимое переменной

#### Типы переменных

В компилируемых языках программирования (например, C++) обычно используется [**статическая типизация**](https://ru.wikipedia.org/wiki/Статическая_типизация). Это означает, что способ хранения переменной в памяти определяется в момент её объявления. Рассмотрим конкретный пример, чтобы лучше разобраться в этом подходе.

Предположим, что вы объявляете переменную с именем `number` и указываете её тип — целое беззнаковое (положительное) число размером два байта. В результате на эту переменную в памяти будет отведено ровно два байта. Далее вы присваиваете переменной значение 203 или 0xCB в шестнадцатеричной системе. В памяти она будет храниться в следующем виде:
{line-numbers: false, format: Bash}
```
00 CB
```

I> На самом деле в памяти современного компьютера информация хранится в двоичном виде. В нашем примере мы используем шестнадцатеричный формат для наглядности.

Обратите внимание, что для хранения значения 203 было бы достаточно одного байта. Но при объявлении переменной было зарезервировано два. Поэтому второй байт, который в нашем случае равен нулю, не будет использоваться никакими другими переменными на протяжении всей работы программы.

Если вы решаете присвоить переменной значение 14037 или 0x36D5, в отведённую переменной память будут записаны следующие два байта:
{line-numbers: false, format: Bash}
```
36 D5
```

Теперь предположим, что вам нужно сохранить значение 107981 или 0x1A5CD, которое не помещается в два байта. В этом случае отведённая под переменную память не будет расширена до необходимого размера. Вместо этого записываемое значение будет обрезано до двух байтов. В результате в нашем случае будет записано следующее:
{line-numbers: false, format: Bash}
```
A5 CD
```

Старшая единица была отброшена. Теперь если вы прочитаете значение переменной `number`, то получите 42445 или 0xA5CD. Другими словами, записанное в `number` число 107981 потеряно и его невозможно восстановить. Эта проблема называется [**переполнением**](https://ru.wikipedia.org/wiki/Целочисленное_переполнение).

Рассмотрим другой пример статической типизации. Предположим, что вам нужно сохранить имя пользователя в переменной `username`. Для этого вы объявляете переменную строкового типа. Во многих компилируемых языках программирования необходимо указать максимально допустимую длину строки при её объявлении. Предположим, в нашем случае длина — десять символов. Затем вы присваиваете переменной значение "Alice" в ASCII-кодировке. Тогда если вы используете компилятор языка C++, строка будет сохранена в памяти так:
{line-numbers: false, format: Bash}
```
41 6C 69 63 65 00 00 00 00 00
```

I> Вы можете проверить ASCII-коды букв в шестнадцатеричной системе по [таблице](https://ru.wikipedia.org/wiki/ASCII).

Для хранения этой строки было бы достаточно шести байтов: пять байтов для каждой буквы плюс один для нуль-терминатора на конце, который равен 00. Однако, мы зарезервировали десять байтов, поэтому неиспользуемая память может быть заполнена нулями или случайными значениями.

[**Динамическая типизация**](https://ru.wikipedia.org/wiki/Динамическая_типизация) является альтернативным подходом. В нём способ хранения переменной определяется не в момент её объявления, а в момент присваивания ей нового значения. Вместе с этим присваиванием переменной назначается [**метаинформация**](https://ru.wikipedia.org/wiki/Метаданные) о её текущем типе. В ходе исполнения программы значение и соответствующая ему метаинформация могут меняться. Таким образом представление переменной в памяти также будет меняться. Динамическая типизация обычно применяется в интерпретируемых языках программирования (например, Python).

I> Метаинформация — это дополнительная информация о каком-либо объекте или данных. [Библиотечный каталог](https://ru.wikipedia.org/wiki/Библиотечный_каталог) является хорошим примером метаинформации. В нём для каждой книги заведена карточка. В ней обычно указывается автор, название произведения, издательство, год издания и количество страниц.

В языке Bash все [**скалярные переменные**](https://en.wikipedia.org/wiki/Variable_(computer_science)) являются строками. Что это значит? Прежде всего уточним определение скалярной переменной. Под этим термином понимаются данные [**примитивного типа**](https://ru.wikipedia.org/wiki/Примитивный_тип). В языке программирования они являются минимальными строительными блоками из которых собираются данные более сложных [**составных типов**](https://en.wikipedia.org/wiki/Composite_data_type). Как правило, скалярная переменная является просто синонимом для адреса памяти, по которому хранится её значение.

Теперь рассмотрим, как Bash представляет свои скалярные переменные в памяти. Предположим, что вы сделали следующее объявление:
{line-numbers: false, format: Bash}
```
declare -i number=42
```

В памяти переменная `number` будет сохранена как строка следующим образом:
{line-numbers: false, format: Bash}
```
34 32 00
```

Обратите внимание, что в строго типизированном языке для хранения этого числа было бы достаточно одного байта. Но в Bash нам потребовалось три: по байту для каждого числа плюс нуль-терминатор на конце.

В Bourne Shell доступны только скалярные переменные. В Bash было добавлено два новых составных типа: индексируемый и ассоциативный [**массивы**](https://ru.wikipedia.org/wiki/Массив_(тип_данных)). Первый из них представляет собой пронумерованный набор строк. Другими словами каждой строке соответствует порядковый номер. Массивы этого типа хранятся в памяти в виде [**связанного списка**](https://ru.wikipedia.org/wiki/Связный_список). Связанный список — это структура данных, состоящая их узлов. Каждый из них содержит данные (в нашем случае строку) и адрес в памяти следующего узла.

Ассоциативный массив устроен сложнее. Он представляет собой набор элементов. Каждый элемент состоит из двух строк. Первая из них называется ключом, а вторая — значением. Чтобы прочитать или записать строку в массив, вам нужно указать соответствующий ей ключ. Точно так же в индексируемом массиве для доступа к строке следует указать её порядковый номер. Очевидно, что под одним номером может хранится только одна строка. Аналогично один ключ в ассоциативном массиве может соответствовать только одной строке. В памяти эти массивы хранятся в виде [**хэш-таблиц**](https://ru.wikipedia.org/wiki/Хеш-таблица).

#### Атрибуты

В Bourne Shell есть только скалярные переменные, которые хранятся в в памяти в виде строк. Bash вводит два новых типа: 


 вы не можете задать тип переменной. Однако, вы можете указать для неё дополнительные атрибуты. Эти атрибуты накладывают ограничения.

//TODO

При объявлении переменной в Bash можно указать её дополнительные атрибуты. Это может быть её тип, константность или ограничение области видимости.

Для указания атрибутов переменной используется встроенная команда `declare`. Если вызвать её без параметров, вы получите список всех локальных и переменных окружения. По сути это тот же результат, который возвращает команда `set`.

Вы можете вызвать `declare` с опцией `-p`. Тогда команда выведет список всех объявленных переменных с их атрибутами. Можно указать имя переменной, чтобы получить информацию только о ней. Например так:
{line-numbers: false, format: Bash}
```
declare -p PATH
```

Также можно вызвать команду `declare` с опцией `-f` для вывода всех объявленных [**функций**](https://ru.wikipedia.org/wiki/Функция_(программирование)). После опции можно указать имя функции, тогда будет выведено только её определение. Пример для функции `quote`:
{line-numbers: false, format: Bash}
```
declare -f quote
```

Наиболее часто используемые атрибуты, устанавливаемые командой `declare`, приведены в таблице 3-7.

{caption: "Таблица 3-7. Зарезервированные переменные Bash", width: "100%"}
| Атрибут | Значение |
| --- | --- |
| `-a` | Объявленная переменная является индексируемым [**массивом**](https://ru.wikipedia.org/wiki/Массив_(тип_данных)). В этом случае элементы массива доступны по целочисленным номерам. |
|  | |
| `-A` | Объявленная переменная является ассоциативным массивом. В этом случае каждому элементу массива соответствует ключ-строка. |
|  | |
| `-g` | Объявление переменной в глобальной области видимости скрипта. При этом переменная не попадает в окружение. |
|  | |
| `-i` | Объявление переменной целочисленного типа. Присваиваемое ей значение будет обработано, как арифметическое выражение. |
|  | |
| `-r` | Объявление константы. Это означает, что указанному имени переменной не может быть присвоено другое значение. |
|  | |
| `-x` | Объявление переменной окружения. |

Рассмотрим примеры объявления переменных с атрибутами. Начнём с целочисленного типа. Выполним два следующих объявления:
{line-numbers: true, format: Bash}
```
declare -i sum=11+2
text=11+2
```

В результате первая переменная, объявленная как целочисленная, будет иметь значение 13, то есть суммы чисел 11 и 2. Вторая переменная будет равна тексту "11+2". По умолчанию тип всех объявляемых переменных — строковый. Всегда учитывайте это при работе с Bash.

С переменными целочисленного типа можно совершать арфиметические операции без подстановки арифметических выражений. Например:
{line-numbers: true, format: Bash}
```
sum=sum+1       # 13 + 1 = 14
sum+=1          # 14 + 1 = 15
sum+=sum+1      # 15 + 15 + 1 = 31
```

Если выполнить те же самые операции со строковой переменной, результат будет отличаться:
{line-numbers: true, format: Bash}
```
text=text+1     # "text+1"
text+=1         # "text+1" + "1" = "text+11"
text+=text+1    # "text+11" + "text" + "1" = "text+11text+1"
```

Вместо арифметических операций произошло добавление суффикса к строке.

Bash ограничивает допустимые значения целочисленных переменных. Если вы попробуете присвоить ей строковое значение, она станет равна нулю. Например:
{line-numbers: false, format: Bash}
```
declare -i sum="test"
```

В результате этого объявления значение `sum` будет равно нулю.

Попробуйте объявить переменную константой, например, так:
{line-numbers: false, format: Bash}
```
declare -r filename="README.txt"
```

После этого Bash будет возвращать сообщение об ошибке при попытке переобъявить или удалить эту переменную. То есть следующие команды не будут выполнены:
{line-numbers: true, format: Bash}
```
filename="123.txt"
unset filename
```

I> Для удаления переменной любого типа, кроме константы, используйте встроенную команду `unset`.

Команда `declare`, вызванная с атрибутом `-x` полностью эквивалентна команде `export`. То есть следующие две команды делают одинаковые объявления переменной `BROWSER_PATH`:
{line-numbers: false, format: Bash}
```
export BROWSER_PATH="/opt/firefox/bin"
declare -x BROWSER_PATH="/opt/firefox/bin"
```

Хорошей практикой считается использовать команду `export` вместо `declare -x`. Это улучшает читаемость кода, потому что не приходится вспоминать значение атрибутов `declare`. По этой же причине предпочитайте использовать команду `readonly` вместо `declare -r`. Она делает то же самое, но её проще запомнить.

Обратите внимание, что команда `readonly` объявляет переменную в глобальной области видимости скрипта. Если вы используете `declare -r` в теле функции, будет объявлена локальная переменная, доступная только в функции. В этом случае чтобы добиться такого же эффекта как от `readonly` используйте опцию `-g`. Например так:
{line-numbers: false, format: Bash}
```
declare -gr filename="README.txt"
```

#### Массивы

В Bash есть три типа переменных: целые числа, строки, массивы. Случаи использования первых двух очевидны. Если вам нужно оперировать числами, вы выбираете целочисленный тип. Для работы с текстом и словами лучше подойдёт строковый тип. В каком случае вам могут понадобиться массивы?

У строкового типа в Bash есть серьёзное ограничение. Когда вы помещаете в переменную какое-то значение, логически это один элемент. Например, вы сохранили в переменной с именем `files` список файлов, разделённых пробелами. В результате `files` хранит одну строку с точки зрения Bash. Это может привести к ошибкам.

Как мы выяснили, стандарт POSIX разрешает любые символы в именах файлов, кроме нуль-терминатора (NUL). NUL означает конец имени файла. Этот же самый символ в Bash означает конец строки. Следовательно, строковая переменная может содержать NUL не в произвольном месте, а только в конце. К чему это приводит? Если вы сохраняете список имён файлов в строке, у вас нет надёжного способа восстановить этот список. Любой символ-разделитель между ними, потенциально может встречаться в этих именах.

Надёжная обработка вывода утилиты `ls` невозможна именно из-за проблемы разделителя. `ls` не позволяет разделять имена файлов и каталогов NUL символом в отличие от утилиты `find`. Но никакой другой символ не будет достаточно надёжным. Поэтому объявления переменных, подобные следующему, следует избегать:
{line-numbers: false, format: Bash}
```
files=$(ls Documents/*.txt)
```

Массивы решают именно эту проблему хранения списка логически отдельных элементов. Вместо присваивания переменной вывода утилиты `ls` используйте массив:
{line-numbers: false, format: Bash}
```
declare -a files=(Documents/*.txt)
```

Когда Bash может вывести тип переменной исходя из присваиваемого ей значения, вы можете опустить команду `declare`. Следующее объявление даст тот же самый результат:
{line-numbers: false, format: Bash}
```
files=(Documents/*.txt)
```

Если все элементы массива вам известны, вы можете указать их явно при объявлении:
{line-numbers: false, format: Bash}
```
files=("/usr/share/doc/bash/README" "/usr/share/doc/flex/README.md" "/usr/share/doc/xz/README")
```

В качестве элементов массива можно использовать другие переменные. Например так:
{line-numbers: true, format: Bash}
```
bash_doc="/usr/share/doc/bash/README"
flex_doc="/usr/share/doc/flex/README.md"
xz_doc="/usr/share/doc/xz/README"
files=("$bash_doc" "$flex_doc" "$xz_doc")
```

Также вы можете явно задавать порядковые номера, называемые **индексами**, для каждого элемента. Например, c учётом объявленных выше переменных `bash_doc` и `flex_doc` можно создать следующий массив `files`:
{line-numbers: false, format: Bash}
```
files=([0]="$bash_doc" [1]="$flex_doc" [5]="/usr/share/doc/xz/README")
```

Обратите внимание на отсутствие пробелов до и после каждого знака равно `=`. Запомните простое правило: в Bash при объявлении переменных пробелы до и после `=` никогда не ставятся.

Вместо объявления всего массива за раз, вы можете устанавливает его элементы по отдельности. Например так:
{line-numbers: true, format: Bash}
```
files[0]="$bash_doc"
files[1]="$flex_doc"
files[5]="/usr/share/doc/xz/README"
```

Наверное, вы обратили внимание, что в последних двух объявлениях массива `files` нумерация его индексов идёт не по порядку. Bash допускает массивы с пропусками. Они называются **sparse arrays**.

Bash начиная с версии 4 предоставляет встроенную команду `readarray` (также известную как `mapfile`). Она позволяет прочитать содержимое текстового файла в массив. Предположим, что у нас есть файл с именем `names.txt` и следующим содержимым:
{line-numbers: true, format: Bash}
```
Alice
Bob
Eve
Mallory
```

Чтобы создать массив, каждый элемент которого соответствует строке файла `names.txt`, выполните следующую команду:
{line-numbers: false, format: Bash}
```
readarray -t names < names.txt
```

В результате содержимое файла будет записано в массив с именем `names`.

{caption: "Упражнение 3-3. Объявление массивов", format: text, line-numbers: false}
```
Выполните самостоятельно все рассмотренные нами способы объявления массивов:

1. С помощью команды declare.

2. Без использования команды declare.

3. Все элементы массива подставляются в результате globbing.

4. Все элементы массива указываются явно при объявлении.

5. Каждый элемент массива задаётся отдельно.

6. В качестве элементов массива используются значения объявленных ранее переменных.

7. Элементы массива читаются из текстового файла.

Выведите содержимое массива с помощью команды echo. Убедитесь, что каждое объявление выполнилось корректно.
```

Мы научились объявлять индексируемые массивы. Теперь разберёмся, как их использовать. Предположим, что массив `files` содержит список имён файлов. Если вам надо скопировать первый из них, вызов утилиты `cp` будет выглядеть так:
{line-numbers: false, format: Bash}
```
cp "${files[0]}" ~/Documents
```

W> В большинстве языков программирования принято нумеровать элементы массивов и строк с нуля, а не с единицы.

Для доступа к элементу массива используется полная форма подстановки с фигурными скобками. После его имени в квадратных скобках указывается номер элемента, который Bash должен подставить. Если вам необходимо подставить все элементы массива, используйте символ `@`. Например так:
{line-numbers: false, format: Bash}
```
cp "${files[@]}" ~/Documents
```

Чтобы получить размер массива, поставьте символ решётка `#` перед его именем. Например:
{line-numbers: false, format: Bash}
```
echo "${#files[@]}"
```

При подстановке элементов массива всегда используйте двойные кавычки, чтобы предотвратить word splitting.

Чтобы удалить элемент массива, используйте встроенную команду `unset`. Например, удаление четвёртого элемента (не забывайте про нумерацию с нуля) выглядит следующим образом:
{line-numbers: false, format: Bash}
```
unset 'files[3]'
```

Обратите внимание на обязательные одинарные кавычки. Они позволят избежать любые подстановки интерпретатора.

Чтобы очистить весь массив, также используйте команду `unset`:
{line-numbers: false, format: Bash}
```
unset files
```

До сих пор мы рассматривали индексируемые массивы. Каждый элемент в них может быть только строкой, но не целым числом. Для доступа к элементам используются целочисленные порядковые номера — индексы. Другими словами индексируемый массив позволяет из целого числа получить соответствующую ему строку.

В Bash начиная с версии 4 появился новый тип переменных — ассоциативные массивы. В них в качестве индексов можно использовать строки. То есть благодаря такому массиву вы сможете по известной строке получить другую, соответствующую ей. Рассмотрим пример.

Предположим, что у вас есть список файлов

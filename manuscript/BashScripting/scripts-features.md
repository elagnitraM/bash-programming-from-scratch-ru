## Зачем нужны скрипты?

В прошлой главе мы научились писать достаточно сложные Bash команды с использованием конвейеров и коннекторов. С их помощью мы реализовали не только простые линейные алгоритмы, но и содержащие ветвление. Таким образом мы добились сложного поведения только средствами командного интерпретатора.

Может возникнуть вопрос: зачем вообще нужно объединять набор команд в законченную программу? Это разумное замечание. Предлагаю рассмотреть его подробнее.

### Команда для резервного копирования

Напишем команду для резервного копирования фотографий на [внешний жёсткий диск](https://ru.wikipedia.org/wiki/Внешний_жёсткий_диск). Она будет состоять всего из двух действий: архивирования и копирования. Предположим, что фотографии хранятся в каталоге `~/photo`, а `/d` — это точка монтирования внешнего диска. Тогда команда может выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/photo.tar.bz2 ~/photo && cp -f ~/photo.tar.bz2 /d
```

Благодаря коннектору `&&`, копирование выполняется только в случае успешного архивирования.

I> В нашем примере мы выполняем резервное копирование в два этапа: архивирование и копирование. Такое разделение действий нужно для образовательных целей. На самом деле вы можете выполнить резервное копирование одной командой `bsdtar`. Для этого просто укажите путь до архива на диске D. Например, так:
{line-numbers: false, format: Bash}
```
bsdtar -cjf /d/photo.tar.bz2 ~/photo
```

Для проверки корректности добавим вывод результатов каждой операции в лог-файл. Мы уже знаем, как это сделать для команд по отдельности с помощью вызова `echo`, коннекторов `&&` и `||`:
{line-numbers: true, format: Bash}
```
bsdtar -cjf ~/photo.tar.bz2 ~/photo && echo "bsdtar - OK" > results.txt || echo "bsdtar - FAILS" > results.txt
cp -f ~/photo.tar.bz2 /d && echo "cp - OK" >> results.txt || echo "cp - FAILS" >> results.txt
```

Вопрос в том, как нам объединить эти две команды в одну? Попробуем прямолинейное решение с коннектором `&&` между ними:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/photo.tar.bz2 ~/photo && echo "bsdtar - OK" > results.txt || echo "bsdtar - FAILS" > results.txt && cp -f ~/photo.tar.bz2 /d && echo "cp - OK" >> results.txt || echo "cp - FAILS" >> results.txt
```

Что будет делать эта команда? Для простоты рассмотрения перепишем её в виде логического выражения, заменив каждый вызов на буквы латинского алфавита:
{line-numbers: false, format: Bash}
```
B && O1 || F1 && C && O2 || F2
```

Буквы `B` и `C` обозначают команды `bsdtar` и `cp`. `O1` и`F1` — это вывод в лог-файл "OK" и "FAIL" соответственно для первой команды. Аналогично, `O2` и `F2` — это вывод для вызова утилиты `cp`.

В случае истинности `B`, вся команда отрабатывает корректно. Будет выполнена следующая последовательность действий:

1. B
2. O1
3. C
4. O2 или F2

Проблема возникнет, когда `B` ложно. В этом случае будет выполнено следующее:

1. B
2. F1
3. C
4. O2 или F2

Очевидно, что операция копирования не имеет смысла, если архивирование завершилось с ошибкой. Ситуация усугубляется тем, что `bsdtar` создаёт пустой архив, если целевого каталога или файла не существует. В этом случае `cp` успешно скопирует его и запишет в лог-файл "cp - OK". В результате `results.txt` будет выглядеть следующим образом:
{line-numbers: true}
```
tar - FAILS
cp - OK
```

Такой вывод только запутает пользователя.

Причина нашего затруднения в том, что вызов `F1` (команда `echo`) всегда возвращает истину. Это приводит к тому, что выражение `B && O1 || F1` истинно в случае ошибки `bsdtar` и дальнейшие команды продолжат исполняться. Всё что нам нужно сделать — это инвертировать результат вызова `F1` с помощью логического НЕ, которое в Bash обозначается как `!`:
{line-numbers: false}
```
B && O1 || ! F1 && C && O2 || F2
```

Теперь в случае ошибки утилиты `bsdtar` в лог-файл будет выведено "bsdtar - FAIL". Но оставшаяся часть выражения всё равно будет обработана. Операции `C` и `O2` не будут выполнены, потому что связаны логическим И с результатом `F1`, который всегда ложен. При этом операнд `F2` будет вычислен. На самом деле наше выражение выглядит теперь так:
{line-numbers: false}
```
(B && O1 || ! F1 && C && O2) || F2
```

В результате выполнения этой команды в лог файл будет выведено:
{line-numbers: true}
```
tar - FAILS
cp - FAILS
```

Такое поведение лучше предыдущего. Теперь не происходит вызова `cp` и копирования пустого архива. Но представьте, что мы пишем команду в которой около 100 операций. Если ошибка произойдёт, например, на 50-ой, вывод всех оставшихся всё равно попадёт в лог-файл. Это затруднит поиск проблемы. Правильным поведением в этом случае было бы прекращение выполнения всей команды после первой же ошибки. Чтобы добиться этого поведения, нам нужно сгруппировать каждую команду и её вывод следующим образом:
{line-numbers: false}
```
(B && O1 || ! F1) && (C && O2 || F2)
```

Рассмотрим, что произойдёт если `B` ложно. В этом случае отработает `F1` и вернёт ложь, благодаря отрицанию `!`. В результате всё выражение `(B && O1 || ! F1)` будет ложным. Тогда благодаря короткому замыканию, коннектор `&&` не станет вычислять свой правый операнд, равный выражению `(C && O2 || F2)`. Мы получим именно то поведение, которое нам нужно.

Добавим последний штрих. Имеет смысл также инвертировать вызов `F2` с помощью логического НЕ. Благодаря этому, вся наша команда вернёт ложь, если операция `B` истинна, а `C` ложна. Такое поведение может быть полезно, в случае интеграции нашей команды с другими или расширения её функций. В результате получим:
{line-numbers: false}
```
(B && O1 || ! F1) && (C && O2 || ! F2)
```

Если мы вернёмся к реальному коду на Bash, наша команда станет выглядеть так:
{line-numbers: false, format: Bash}
```
(bsdtar -cjf ~/photo.tar.bz2 ~/photo && echo "bsdtar - OK" > results.txt || ! echo "bsdtar - FAILS" > results.txt) && (cp -f ~/photo.tar.bz2 /d && echo "cp - OK" >> results.txt || ! echo "cp - FAILS" >> results.txt)
```

Как это часто бывает в программировании, такую команду несложно написать, но достаточно трудно прочитать и понять.

### Неверное техническое решение

Мы написали достаточно длинную команду резервного копирования. Если её требуется выполнять регулярно, нам потребуется где-то её сохранить, чтобы не набирать каждый раз в окне терминала.

Мы уже знаем, что все выполненные Bash команды автоматически сохраняются в файле истории `~/.bash_history`. Тогда с помощью комбинации Ctrl+R найти эту команду не составит труда. Возможно, вам это решение покажется надёжным и удобным. Но не торопитесь с выводами. Давайте рассмотрим связанные с ним возможные проблемы.

Прежде всего размер истории Bash ограничен. По умолчанию сохраняются только 1000 последних команд. Если превысить это число, то самые новые начнут записываться вместо самых старых. Таким образом возникает риск случайно потерять нашу сохранённую команду.

Можно увеличить максимальный размер истории. Но сразу возникает вопрос: увеличить на сколько? Какой бы большой размер мы не выбрали, рано или поздно появляется риск его переполнения. Есть вариант вообще снять ограничение на размер. Тогда будут сохраняться все введённые команды, а старые никогда не будут удаляться.

Кажется, нам удалось решить проблему и найти приемлемое техническое решение. Имеет ли оно какие-то побочные эффекты? Давайте подумает над этим вопросом. Предположим, что вы используйте Bash год или два. Все команды, введённые вами за это время, попадут в файл `.bash_history`. Учтите, что одни и те же команды в нём дублируются. То есть, например, каждая команда `cd ~` будет записана в этот файл, независимо от того есть уже она в нём или нет. Можно предположить, что за год этот файл достигнет значительного размера около нескольких сотен мегабайт. При этом большая часть сохранённой в нём информации окажется не нужна. Нас интересует только несколько команд, которые мы используем регулярно. В результате мы получим первый побочный эффект: нерациональное использование места на жёстком диске.

Вы можете возразить, что хранить лишние две-три сотни мегабайт — это не проблема для современных компьютеров. Да, это так. Но не забывайте, что при навигации по истории через нажатие Ctrl+R Bash ищет нужную команду по всему файлу `.bash_history`. Чем он больше, тем дольше будет длиться этот поиск. Рано или поздно он станет занимать десятки секунд даже на мощном компьютере. Дальше с ростом файла это время будет только увеличиваться.

Раздувание файла истории приводит к увеличению времени поиска. Это связано не только с тем, что Bash приходится перебирать больше строк. Поиск по Ctrl+R позволяет вам ввести начало нужной команды. Представьте себе, что история огромна. В этом случае в ней содержится очень много команд, которые начинаются одинаково. В результате вам придётся набирать больше символов, чтобы найти из них нужную. Неудобство вызова команды — это второй побочный эффект нашего решения.

Предположим, что у нас появились новые альбомы фотографий. Они хранятся не в каталоге `~/photo`, а например в `~/Documents/official_photo`. К сожалению, наша команда резервного копирования работает только с одним предопределённым путём. Чтобы она стала поддерживать другие, необходимо её переписать и добавить новые шаги для архивации и копирования каталога `~/Documents/official_photo`. В результате отредактированная команда также попадёт в историю `.bash_history`. Это опять же увеличит время на её поиск. Итак, сложность расширения функций — третий побочный эффект.

Если вы решите объединить нашу команду резервного копирования фотографий с аналогичной ей, которая копирует документы, это будет проблематично. Опять же понадобиться новая команда, которая сочетает в себе две существующие.

Какой можно сделать вывод из рассмотренных возможных проблем? Долговременное хранение команд в файле истории неудобно. Настоящая причина этого в том, что мы попытались использовать механизм для целей, к которым он не был предназначен. В результате мы пришли к техническому решению, которое неудобно в использовании и сопровождении.

Неверные технические решения распространены не только среди начинающих программистов. Профессионалы с большим опытом тоже их совершают и достаточно часто. В чём причина таких решений? На самом деле этих причин много. В нашем случае её можно сформулировать примерно так: "нежелание учиться новому".

Мы освоились с работой Bash в режиме командного интерпретатора. Но применяя полученные знания для новой задачи резервного копирования, мы не учли в полной мере её требований. Кроме непосредственного копирования, необходимо обеспечить следующее:

1. Долговременное хранение команды.
2. Удобство вызова.
3. Возможность её расширения.
4. Возможность сочетания с другими командами.

Чтобы удовлетворить этим требованиям, наших знаний просто недостаточно. Все известные нам на данный момент механизмы не подходят. Но, вероятно, Bash скрипт поможет нам выйти из этого затруднения. Предлагаю изучить его возможности, а затем проверить, помогут ли новые знания в решении поставленной задачи.

### Запуск скрипта

Сделаем скрипт на основе нашей команды для резервного копирования. Для этого выполните следующие действия:

1. Откройте редактор исходного кода и создайте в нём новый файл. Для Notepad++, интегрированного с Bash, команда запуска может выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
notepad++ ~/photo-backup.sh
```

2. Скопируйте в файл команду резервного копирования:
{line-numbers: false, format: Bash}
```
(bsdtar -cjf ~/photo.tar.bz2 ~/photo && echo "bsdtar - OK" > results.txt || ! echo "bsdtar - FAILS" > results.txt) && (cp -f ~/photo.tar.bz2 /d && echo "cp - OK" >> results.txt || ! echo "cp - FAILS" >> results.txt)
```

3. Сохраните измененный файл и закройте редактор.

В результате мы получим файл скрипта `photo-backup.sh` в домашнем каталоге пользователя. Чтобы его исполнить, запустите интерпретатор командой `bash` и передайте имя файла первым параметром:
{line-numbers: false, format: Bash}
```
bash photo-backup.sh
```

Мы только что написали и запустили наши первый скрипт. В общем случае он представляет собой последовательность команд, записанных в файл. Обратите внимание, что порядок их исполнения точно такой же, как если бы вы вводили их вручную в окно терминала.

Запуск скриптов с явным вызовом интерпретатора Bash неудобен. Можем ли мы запустить нашу программу так же, как и любую другую GNU утилиту по относительному или абсолютному пути? Можем, но для этого нам потребуется несколько действий:

1. В окне терминала выполните следующую команду:
{line-numbers: false, format: Bash}
```
chmod +x ~/photo-backup.sh
```

2. Откройте файл скрипта для редактирования и добавьте в его начало следующую строку:
{line-numbers: false, format: Bash}
```
#!/bin/bash
```

3. Сохраните изменённый файл и закройте редактор.

Теперь вы можете запускать скрипт по относительному или абсолютному путям.

Рассмотрим выполненные нами действия. Первое, что мешает запустить скрипт — это права доступа. По умолчанию все созданные пользователем файлы имеют следующие права:
{line-numbers: false}
```
-rw-rw-r--
```

Это значит, что владелец и его группа могут читать и изменять файл. Все остальные могут только читать. Команда `chmod` меняет права указанного файла. Передав ей параметр `+x`, мы разрешили всем пользователем исполнение нашего скрипта. В результате его права стали следующими:
{line-numbers: false}
```
-rwxrwxr-x
```

После этого шага, вы уже можете запустить файл и Bash будет интерпретировать его команды. Однако, возможна ситуация, когда вы используйте другой командный интерпретатор (например, [C shell](https://ru.wikipedia.org/wiki/Csh)). В этом случае скрипт будет исполняться им и завершится ошибкой. Чтобы явно указать интерпретатор, который должен выполнять скрипт, надо в начале файла ввести его абсолютный путь после символов `#!`. Теперь ваша программа может запущена на любой системе, имеющей Bash.

I> Если в скрипте не указан интерпретатор для запуска, то утилита `file` определит его как обычный текстовый файл:
{line-numbers: false, format: Bash}
```
~/photo-backup.sh: ASCII text
```
После добавления строки `#!`, он же определяется как Bash скрипт:
{line-numbers: false, format: Bash}
```
~/photo-backup.sh: Bourne-Again shell script, ASCII text executable
```

В некоторых системах Unix (например, FreeBSD) путь к Bash отличается от `/bin/bash`. Если вам важна переносимость скриптов, то вместо абсолютного пути до интерпретатора указывайте следующее:
{line-numbers: false, format: Bash}
```
#!/usr/bin/env bash
```

Что делает команда `/usr/bin/env bash`? Она запускает интерпретатор `bash`, используя все текущие переменные окружения. Благодаря этому, исполняемый файл `bash` будет найден в одном из путей переменной `PATH`.

### Последовательность команд

Сейчас наш скрипт выглядит как в листинге 3-1.

{caption: "Листинг 3-1. Исходный код скрипта для резервного копирования", line-numbers: true, format: Bash}
![`photo-backup.sh`](code/BashScripting/photo-backup.sh)

Команда резервного копирования слишком длинная. Из-за этого её трудно читать и изменять. Попробуем разбить её на две отдельные команды. Результат приведён в листинге 3-2.

{caption: "Листинг 3-2. Разделение команд `bsdtar` и `cp`", line-numbers: true, format: Bash}
![`photo-backup-commands.sh`](code/BashScripting/photo-backup-commands.sh)

Поведение нового скрипта отличается. Теперь команды не связаны коннектором `&&`. Из-за этого утилита `cp` будет вызываться независимо от результата работы `bsdtar`. Чтобы вернуться к исходному поведению, нам нужно завершать скрипт в случае ошибки `bsdtar`. Есть два способа это сделать. Первый вариант — использовать команду `exit`. Она завершает работу скрипта с кодом возврата, переданным в качестве параметра. Добавим `exit` в наш скрипт, как демонстрирует листинг 3-3.

{caption: "Листинг 3-3. Добавление вызова `exit`", line-numbers: true, format: Bash}
![`photo-backup-commands.sh`](code/BashScripting/photo-backup-exit.sh)

Мы внесли два изменения в команду вызова `bsdtar`. Сначала она соответствовала следующему выражению:
{line-numbers: false}
```
B && O1 || ! F1
```

После добавления вызова `exit` выражение стало выглядеть так:
{line-numbers: false}
```
B && O1 || (F1 && E)
```

Команда `exit` обозначена как `E`. Теперь в случае ошибки `bsdtar` будет вычисляться правый операнд коннектора `||`, который равен `(F1 && E)`. Команда `echo` всегда возвращает истину, поэтому интерпретатор выполнит правую часть коннектора `&&` то есть добавленную команду `exit`.

Есть более изящное решение чем явный вызов команды `exit`. Если вам нужно завершить скрипт после первой команды, вернувшей код возврата отличный от нуля, можно воспользоваться вызовом `set`. Он позволяет изменить параметры работы интерпретатора. В данном случае нас интересует параметр `-e`:
{line-numbers: false, format: Bash}
```
set -e
```

То же самое вы можете сделать, явно указав этот параметр при запуске Bash:
{line-numbers: false, format: Bash}
```
bash -e
```

[Одна из проблем параметра `-e`](http://mywiki.wooledge.org/BashFAQ/105) заключается в том, что он меняет поведение только текущего процесса Bash, но не порождённых им [дочерних процессов](https://en.wikipedia.org/wiki/Child_process), называемых **subshell**. Дело в том, что каждая команда в конвейере или коннекторе выполняется в отдельном subshell. Таким образом опция `set -e` никак не повлияет на их поведение. Поэтому в нашем случае такое решение не подойдёт.

### Параметризация

Предположим, что вы перенесли свои фотографии из каталога `~/photo` в `~/Documents/Photo`. В этом случае вам придётся поменять этот путь в скрипте `photo-backup.sh` согласно листингу 3-4.

{caption: "Листинг 3-4. Изменение пути каталога фотографий", line-numbers: true, format: Bash}
![`photo-backup-path.sh`](code/BashScripting/photo-backup-path.sh)

Каждый раз при смене каталога фотографий придётся редактировать скрипт. Это неудобно. Намного лучше было бы иметь универсальную программу, которая принимала бы путь до каталога в качестве входного параметра. На самом деле при старте скрипта Bash передаёт ему все входные параметры. Они доступны под именами `0`, `1`, `2` и т.д. в зависимости от их количества.

Рассмотрим пример. Запустим скрипт `photo-backup.sh` следующим образом:
{line-numbers: false, format: Bash}
```
./photo-backup.sh ~/Documents/Photo
```

В этом случае переменная с именем `0` будет содержать строку `./photo-backup.sh`, а переменная `1` - `~/Documents/Photo`. Все остальные переменные с именами `2` и далее будут пустыми. Если мы передаём два параметра, то последний из них будет храниться в переменной `2`, а последующие будут пустыми.

Перепишем наш скрипт так, чтобы путь для каталога фотографий читался из первого параметра. Результат приведён в листинге 3-5.

{caption: "Листинг 3-5. Чтение пути из первого параметра", line-numbers: true, format: Bash}
![`photo-backup-parameter-path.sh`](code/BashScripting/photo-backup-parameter-path.sh)

Обратите внимание, что при обращении к переменной `$1`, содержащей первый параметр, мы используем двойные кавычки. Если их не поставить, то скрипт не сможет корректно обработать пути, содержащие пробелы. Механизм разделения строк на слова в Bash называется [**word splitting**](http://mywiki.wooledge.org/WordSplitting).

Предположим, что ваши фотографии хранятся в каталоге `~/photo album`. Тогда скрипт следует вызывать следующим образом:
{line-numbers: false, format: Bash}
```
./photo-backup.sh "~/photo album"
```

Но если мы передадим в утилиту `bsdtar` параметр `$1` без кавычек, её вызов будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/photo.tar.bz2 ~/photo album && echo "bsdtar - OK" > results.txt || ! echo "bsdtar - FAILS" > results.txt
```

В этом случае `bsdtar` интерпретирует имя каталога `photo album` как два каталога с именами `photo` и `album`. Ни один из них не существует, поэтому скрипт завершится с ошибкой.

Почему кавычек вокруг имени каталога `"~/photo album"` оказалось недостаточно при вызове скрипта? Дело в том, что эти кавычки были обработаны и отброшены процессом Bash, который работает в режиме командного интерпретатора. Скрипт же исполняется в другом процессе Bash, который ничего не знает про эти кавычки.

Итак, что нам дала параметризация скрипта? На самом деле вместо программы для резервного копирования фотографий, мы получили универсальный скрипт для архивирования любых данных: документов, медиафайлов, исходного кода программ.

Единственная проблема, которая может возникнуть в ходе использования нашего скрипта, связана с именем архива. Предположим, что мы вызываем скрипт для фотографий и документов:
{line-numbers: true, format: Bash}
```
./photo-backup.sh ~/photo
./photo-backup.sh ~/Documents
```

В этом случае обе команды приведут к созданию архива с именем `photo.tar.bz2`, который будет скопирован на диск D. Причём архив с документами перезапишет архив с фотографиями. Это не то поведение, которое мы ожидаем. Попробуем исправить эту проблему. Для этого будем подставлять первый параметр скрипта не только в качестве целевого каталога, но и как имя архива. Отредактированный скрипт приведён в листинге 3-6.

{caption: "Листинг 3-6. Чтение имени архива из первого параметра", line-numbers: true, format: Bash}
![`photo-backup-parameter-name.sh`](code/BashScripting/photo-backup-parameter-name.sh)

Теперь имя архива, который будет сохранён на диске D, зависит от имени целевого каталога. Например, вы запустите скрипт следующим образом:
{line-numbers: true, format: Bash}
```
./photo-backup.sh ~/Documents
```

Тогда архив будет сохранён по пути `/d/Documents.tar.bz2`. При этом его имя не будет конфликтовать с именем архива фотографий `photo.tar.bz2`.

Последнее улучшение скрипта — это замена операции копирования на операцию переименования. Тогда ненужный промежуточный архив будет удаляться. Результат приведён в листинге 3-7.

{caption: "Листинг 3-7. Удаление временного архива", line-numbers: true, format: Bash}
![`photo-backup-mv.sh`](code/BashScripting/photo-backup-mv.sh)

Получив универсальный скрипт для резервного копирования, имеет смысл переименовать его с `photo-backup.sh` на что-то более говорящее вроде `make-backup.sh`.

### Сочетание с другими командами

Мы разработали универсальный скрипт для резервного копирования. Его можно исполнять не только самостоятельно, но и в сочетании с другими GNU утилитами и приложениями. Для удобства такого использования, имеет смысл интегрировать наш скрипт с Bash. Тогда мы сможем вызывать его по имени, а не только по относительному и абсолютному путям.

Мы уже знаем два способа интеграции приложения с Bash по опыту настройки Notepad++. Повторим их и рассмотрим ещё один, специфичный для скриптов:

1. Добавить путь до скрипта в переменную `PATH`. Для этого отредактируйте файл `~/.bash_profile`.

2. Определить `alias` с абсолютным путём до скрипта. Такое определение можно сделать в файле `~/.bashrc`.

3. Скопировать скрипт в каталог `/usr/local/bin`. Путь до него по умолчанию добавляется в переменную `PATH`. Если в вашем окружении MSYS2 этого каталога нет — создайте его.

После интеграции с Bash скрипт запускается по имени следующим образом:
{line-numbers: false, format: Bash}
```
make-backup.sh ~/photo
```

Как и любую самостоятельную Bash команду наш скрипт можно использовать в конструкциях с конвейерами и коннекторами.

Рассмотрим пример. Предположим, что вам нужно сделать резервную копию всех PDF документов из каталога `~/Documents`. Их мы можем найти следующей командой `find`:
{line-numbers: false, format: Bash}
```
find ~/Documents -type f -name *.pdf
```

Над каждым из найденных файлов выполним действие резервного копирования с помощью нашего скрипта:
{line-numbers: false, format: Bash}
```
find ~/Documents -type f -name *.pdf -exec ./make-backup.sh {} \;
```

I> Как вы помните, экранированная точка с запятой `\;` означает выполнение действия над каждым из указанных файлов.

В результате выполнения этой команды в корневой каталог диска D (`/d/`) будут скопированы архивы с каждым из найденных PDF файлов. То есть каждому документу будет соответствовать отдельный архив. Это неудобно. Было бы лучше собрать все найденные файлы в один архив.

Попробуем вызывать наш скрипт один раз сразу для всех файлов, найденных командой `find`:
{line-numbers: false, format: Bash}
```
find ~/Documents -type f -name *.pdf -exec ./make-backup.sh {} +
```

В результате этой команды будет скопирован только первый из найденных PDF документов. Почему это происходит?

Рассмотрим, как выглядит вызов утилиты `bsdtar` в нашем скрипте. Для простоты опустим выводы `echo` в лог-файл:
{line-numbers: false, format: Bash}
```
bsdtar -cjf "$1".tar.bz2 "$1"
```

Проблема заключается в том, что мы обрабатываем только первый параметр, переданный на вход скрипта. Он сохраняется в переменной с именем `1`. При этом игнорируются все дальнейшие параметры в переменных `2`, `3` и т.д. Но именно в них сохраняются результаты поиска утилиты `find`, когда мы указываем знак `+` после действия `-exec`.

Чтобы решить эту проблему, воспользуемся переменной с именем `@`. В ней интерпретатор сохраняет все параметры, переданные в скрипт. В этом случае нам придётся изменить вызов `bsdtar` на следующий:
{line-numbers: false, format: Bash}
```
bsdtar -cjf "$1".tar.bz2 "$@" && echo "bsdtar - OK" > results.txt || ! echo "bsdtar - FAILS" > results.txt
```

Теперь вместо первого параметра `$1` мы передаём на вход утилиты `bsdtar` все входные параметры скрипта `$@`. Обратите внимание, что в качестве имени архива будет использоваться имя первого PDF документа, найденного `find`.

Листинг 3-8 демонстрирует финальную версию скрипта, способную обработать произвольное число входных параметров.

{caption: "Листинг 3-8. Обработка произвольного числа входных параметров", line-numbers: true, format: Bash}
![`make-backup.sh`](code/BashScripting/make-backup.sh)

### Возможности скриптов

На примере задачи резервного копирования данных мы рассмотрели возможности Bash скриптов. Как вы помните, дополнительные требования задачи звучали следующим образом:

1. Долговременное хранение команды.
2. Удобство вызова.
3. Возможность её расширения.
4. Возможность сочетания с другими командами.

Наш финальный скрипт `make-backup.sh` удовлетворяет всем требованиям. Проверим каждый из этих пунктов:

1. Скрипт хранится на жёстком диске и это обеспечивает его долговременное хранение.

2. Скрипт легко интегрировать с Bash тремя различными способами. Благодаря этому, его так же удобно вызывать, как и любую GNU утилиту.

3. Скрипт представляет собой последовательность команд, каждая из которых начинается с новой строки. Его удобно читать и редактировать. Благодаря параметризации, его легко обобщить для решения однотипных задач.

4. За счёт интеграции с Bash скрипт удобно сочетать с другими командами, в том числе с помощью конвейеров и коннекторов.
## Зачем нужны скрипты?

В прошлой главе мы научились писать сложные Bash команды с использованием конвейеров и логических операторов.

Конвейеры объединяют несколько команд в одну. Так получается линейный алгоритм. Логические операторы добавляют в него ветвление. В результате получается настоящая программа.

Почему для программирования на Bash средств командного интерпретатора оказывается недостаточно? Bash-скрипты — это программы, хранящиеся на жёстком диске. Разберёмся, зачем они нужны.

### Команда резервного копирования

Для примера напишем команду резервного копирования фотографий на [внешний жёсткий диск](https://ru.wikipedia.org/wiki/Внешний_жёсткий_диск). Команда будет состоять из двух действий: архивирования и копирования. Предположим, что фотографии хранятся в каталоге `~/photo`, а `/d` — это точка монтирования внешнего диска. Тогда команда может быть такой:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/photo.tar.bz2 ~/photo && cp -f ~/photo.tar.bz2 /d
```

Благодаря логическому И (&&), копирование выполняется только после успешного архивирования. Если утилита bsdtar вернула ошибку, копирования не будет.

I> В нашем примере резервное копирование выполняется в два этапа: архивирование и копирование. Такое разделение действий нужно для демонстрации. То же самое поведение даст один вызов утилиты bsdtar. Укажите в нём путь до создаваемого архива на диске D. Например, так:
{line-numbers: false, format: Bash}
```
bsdtar -cjf /d/photo.tar.bz2 ~/photo
```

Предположим, что наша команда резервного копирования будет запускаться автоматически. (например, по расписанию). Тогда вы не сможете прочитать сообщение об ошибке, если что-то пойдёт не так. В таких случаях поможет вывод в лог-файл. Добавим этот вывод для вызова утилиты bsdtar. Получим:
{line-numbers: true, format: Bash}
```
bsdtar -cjf ~/photo.tar.bz2 ~/photo &&
echo "bsdtar - OK" > results.txt ||
echo "bsdtar - FAILS" > results.txt
```

Bash-команду можно разбить на несколько строк. Есть два способа переноса строк:

1. Перенос строки сразу после логического оператора (&& или ||).

2. Перенос строки после обратного слеша \. 

Второй вариант выглядит так:
{line-numbers: true, format: Bash}
```
bsdtar -cjf ~/photo.tar.bz2 ~/photo \
&& echo "bsdtar - OK" > results.txt \
|| echo "bsdtar - FAILS" > results.txt
```

Теперь выведем в лог-файл результат утилиты cp. Получим:
{line-numbers: true, format: Bash}
```
cp -f ~/photo.tar.bz2 /d &&
echo "cp - OK" >> results.txt ||
echo "cp - FAILS" >> results.txt
```

Резервное копирование должно выполняться одной командой. Поэтому попробуем объединить вызовы bsdtar и cp логическим И. Получится следующее:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/photo.tar.bz2 ~/photo &&
  echo "bsdtar - OK" > results.txt ||
  echo "bsdtar - FAILS" > results.txt &&
cp -f ~/photo.tar.bz2 /d &&
  echo "cp - OK" >> results.txt ||
  echo "cp - FAILS" >> results.txt
```

Что будет делать эта команда? Для удобства перепишем её в виде логического выражения. Заменим каждый вызов команды или утилиты на букву латинского алфавита. Получится следующее:
{line-numbers: false, format: Bash}
```
B && O1 || F1 && C && O2 || F2
```

Буквы B и C обозначают вызовы утилит bsdtar и cp. O1 и F1 — это вывод в лог-файл строк "bsdtar - OK" и "bsdtar - FAIL". Аналогично, O2 и F2 — это вывод результата cp.

Если B истинно, порядок исполнения команд очевиден. Последовательность действий будет такой:

1. B
2. O1
3. C
4. O2 или F2

Если же bsdtar вернёт ошибку, значение B будет ложь. Тогда выполнятся такие действия:

1. B
2. F1
3. C
4. O2 или F2

Операция копирования не имеет смысла, если архивирование завершилось с ошибкой. Лишние проблемы создаёт поведение утилиты bsdtar. Если указанного каталога или файла не существует, утилита выдаст пустой архив. В этом случае cp успешно его скопирует. После этого в лог файл запишется строка "cp - OK". Тогда лог-файл будет таким:
{line-numbers: true}
```
bsdtar - FAILS
cp - OK
```

Такой вывод только запутает пользователя.

Вернёмся к нашему выражению:
{line-numbers: false, format: Bash}
```
B && O1 || F1 && C && O2 || F2
```

Почему утилита cp вызывается после ошибки в bsdtar? Дело в том, что команда echo всегда выполняется успешно. Её код возврата всегда истинен. Это значит, что значения O1, F1, O2 и F2 — истина.

Рассмотрим только команду вызова bsdtar и вывод её результата в лог-файл. Ей соответствует следующая часть логического выражения:
{line-numbers: false, format: Bash}
```
B && O1 || F1
```

Это выражение всегда истинно. Заключим левую часть в скобки:
{line-numbers: false, format: Bash}
```
(B && O1) || F1
```

Теперь мы получили логическое ИЛИ для операндов (B && O1) и F1. F1 — всегда истина. Поэтому и всё выражение всегда истинно.

Проблему можно решить, если инвертировать результат вызова F1 с помощью логического НЕ. Оно обозначается как восклицательный знак !. Получим такое выражение:
{line-numbers: false}
```
B && O1 || ! F1 && C && O2 || F2
```

Теперь в случае ошибки утилиты bsdtar в лог-файл будет выведено "bsdtar - FAIL". Но оставшаяся часть выражения всё равно будет обработана. Операции C и O2 не будут выполнены. Они связаны логическим И с результатом F1, который всегда ложен. Но после них идёт действие F2. Оно будет выполнено.

Для удобства добавим к нашему выражению скобки. Получим:
{line-numbers: false}
```
(B && O1 || ! F1 && C && O2) || F2
```

Теперь очевидно, что если выражение в скобках ложно, Bash выполнит действие F2. Иначе ему не вывести значение всего выражения.

В результате выполнения всей команды в лог-файл будет выведено:
{line-numbers: true}
```
bsdtar - FAILS
cp - FAILS
```

Такой вывод лучше предыдущего. Теперь утилита cp не вызывается и пустой архив не копируется. Но представьте, что в нашей команде резервного копирования 100 действий. Если ошибка произойдёт на 50-ом действии, результаты всех оставшихся всё равно попадут в лог-файл. Этот вывод только помешает найти проблему. Лучшим решением было бы прекратить выполнение команды после первой же ошибки. Для этого сгруппируем вызовы утилит и выводы их результатов в лог-файл. Получим:
{line-numbers: false}
```
(B && O1 || ! F1) && (C && O2 || F2)
```

Проверим, что теперь произойдёт если B ложно. В этом случае выполнится действие F1. Его результат инвертируется. Поэтому вся левая часть выражения будет ложной:
{line-numbers: false}
```
(B && O1 || ! F1)
```

Дальше из-за короткого замыкания правый операнд логического И не будет вычислен. Это значит, что все действия в правой части выражения не выполнятся:
{line-numbers: false}
```
(C && O2 || F2)
```

Мы получили нужное нам поведение.

Добавим последний штрих. Результат действия F2 нужно инвертировать. Тогда всё выражение будет ложным, если C ложно. Это значит, что команда резервного копирования завершилась ошибкой, если утилита cp не смогла отработать. Звучит логично. Кроме того, это полезно при интеграции нашей команды с другими командами.

Конечный вариант нашего выражения будет таким:
{line-numbers: false}
```
(B && O1 || ! F1) && (C && O2 || ! F2)
```

Теперь вернёмся к реальному коду на Bash. Наша команда резервного копирования стала такой:
{line-numbers: true, format: Bash}
```
(bsdtar -cjf ~/photo.tar.bz2 ~/photo &&
  echo "bsdtar - OK" > results.txt ||
  ! echo "bsdtar - FAILS" > results.txt) &&
(cp -f ~/photo.tar.bz2 /d &&
  echo "cp - OK" >> results.txt ||
  ! echo "cp - FAILS" >> results.txt)
```

Как это часто бывает в программировании, такую команду несложно написать, но трудно прочитать и понять.

### Плохое техническое решение

Мы написали длинную и сложную Bash-команду резервного копирования. Если она выполняется регулярно, её надо где-то сохранить. Иначе каждый раз придётся набирать команду вручную в окне терминала.

Все выполненные в терминале команды автоматически сохраняются в файле истории. У каждого пользователя он свой по пути `~/.bash_history`. По комбинации клавиш Ctrl+R в этом файле можно быстро найти нужную команду.

Что если мы просто сохраним команду резервного копирования в файле истории? Там её можно будет быстро найти и исполнить. Это решение кажется надёжным и удобным. Но не торопитесь с выводами. Давайте рассмотрим возможные проблемы.

Прежде всего размер файла истории ограничен. По умолчанию сохраняются только 500 последних выполненных команд. Если превысить это число, то каждая новая команда будет записана вместо самой старой. Из-за этого команда резервного копирования может быть случайно удалена из истории.

Максимальный размер файла истории можно увеличить. Но сразу возникает вопрос: увеличить на сколько? Какой размер не выберем, есть риск его переполнения. Можно вообще снять ограничение на размер. Тогда будут сохраняться все введённые команды, а старые никогда не будут удаляться.

Кажется, нам удалось найти решение задачи: файл истории с неограниченным размером. Могут ли с ним возникнуть какие-то проблемы? Давайте подумает. Предположим, что вы используйте Bash год или два. Все введённые за это время команды попадут в файл `.bash_history`. Учтите, что одни и те же команды в нём дублируются. Например, каждая команда `cd ~` будет записана в этот файл, даже если она там уже есть. Скорее всего за год размер файла достигнет нескольких сотен мегабайт. При этом большая часть информации в нём не нужна. Нас интересует небольшой набор команд, которые мы используем регулярно. В результате возникает первая проблема: нерациональное использование места на жёстком диске.

Вы можете возразить, что хранить лишние две-три сотни мегабайт — не проблема для современных компьютеров. Да, это так. Но не забывайте, что по нажатию Ctrl+R Bash ищет нужную команду по всему файлу `.bash_history`. Чем он больше, тем дольше длится поиск. Со временем вы станете ждать десятки секунд даже на мощном компьютере. Дальше с ростом файла время ожидания станет только больше.

Разрастание файла истории увеличивает время поиска. Не только потому, что Bash приходится перебирать больше строк в нём. По нажатию Ctrl+R надо ввести начало искомой команды. Представьте, что история огромна. Тогда в ней много команд, которые начинаются одинаково. Это значит, что вам придётся набрать больше символов, чтобы найти из них нужную. Неудобство вызова команды — это вторая проблема нашего решения.

Предположим, у вас появились новые альбомы фотографий. Они хранятся не в каталоге `~/photo`, а например в `~/Documents/official_photo`. Наша команда резервного копирования работает только с путём `~/photo`. Чтобы скопировать фотографии из другого пути, команду надо переписать. Выполните новую команду. Теперь она тоже сохранилась в файле истории `.bash_history`. Это опять увеличит время её поиска. Итак, сложность расширения функций — третья проблема.

Возможно у вас уже есть несколько команд для резервного копирования. Одна копирует фотографии, а другая документы. Объединить их будет проблематично. Вам придётся написать новую команду, в которую войдут действия из уже существующих.

Какой можно сделать вывод? Файл истории не подходит для долговременного хранения команд. Причина всех возникших проблем одна. Мы пытаемся использовать механизм файла истории не по назначению. Он создавался не для этого. В результате мы пришли к плохому техническому решению.

От плохих решений не застрахован никто. Профессионалы с большим опытом тоже нередко к ним приходят. Почему? Причины бывают разные. В нашем случае сыграл роль недостаток знаний. Мы освоились с работой Bash в режиме командного интерпретатора. Эти знания мы применили для новой задачи. Но всех её требований не учли. Как оказалось, просто заархивировать и скопировать файлы недостаточно.

Полный список требований выглядит так:

1. Команда должна храниться неограниченно долго.
2. Команда должна быстро вызываться.
3. Нужна возможность для её расширения.
4. Нужна возможность для сочетания её с другими командами.

Для начала оценим свои знания Bash. Их просто недостаточно, чтобы удовлетворить всем этим требованиям. Все известные нам механизмы не подходят. Может быть нам бы помог Bash-скрипт? Предлагаю изучить его возможности. Затем проверим, подходит ли он для нашей задачи.

### Запуск скрипта

Сделаем скрипт на основе нашей команды для резервного копирования. Для этого выполните следующие действия:

1. Откройте редактор исходного кода и создайте в нём новый файл. Для Notepad++, интегрированного с Bash, команда запуска может выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
notepad++ ~/photo-backup.sh
```

2. Скопируйте в файл команду резервного копирования:
{line-numbers: false, format: Bash}
```
(bsdtar -cjf ~/photo.tar.bz2 ~/photo && echo "bsdtar - OK" > results.txt || ! echo "bsdtar - FAILS" > results.txt) && (cp -f ~/photo.tar.bz2 /d && echo "cp - OK" >> results.txt || ! echo "cp - FAILS" >> results.txt)
```

3. Сохраните измененный файл и закройте редактор.

В результате мы получим файл скрипта `photo-backup.sh` в домашнем каталоге пользователя. Чтобы его исполнить, запустите интерпретатор командой `bash` и передайте имя файла первым параметром:
{line-numbers: false, format: Bash}
```
bash photo-backup.sh
```

Мы только что написали и запустили наш первый Bash-скрипт. В общем случае он представляет собой последовательность команд, записанных в файл. Обратите внимание, что порядок их исполнения точно такой же, как если бы вы вводили их вручную в окно терминала.

Запуск скриптов с явным вызовом интерпретатора Bash неудобен. Можем ли мы запустить нашу программу так же, как и любую другую GNU утилиту по относительному или абсолютному пути? Можем, но для этого нам потребуется несколько действий:

1. В окне терминала выполните следующую команду:
{line-numbers: false, format: Bash}
```
chmod +x ~/photo-backup.sh
```

2. Откройте файл скрипта для редактирования и добавьте в его начало следующую строку:
{line-numbers: false, format: Bash}
```
#!/bin/bash
```

3. Сохраните изменённый файл и закройте редактор.

Теперь вы можете запускать скрипт по относительному или абсолютному путям.

Рассмотрим выполненные нами действия. Первое, что мешает нам запустить скрипт — это права доступа. По умолчанию все созданные пользователем файлы имеют следующие права:
{line-numbers: false}
```
-rw-rw-r--
```

Это значит, что владелец и его группа могут читать и изменять файл. Все остальные могут только читать. Команда `chmod` меняет права указанного файла. Передав ей опцию `+x`, мы разрешили всем пользователям исполнение нашего скрипта. В результате его права станут следующими:
{line-numbers: false}
```
-rwxrwxr-x
```

После этого шага, вы уже можете запустить файл и Bash будет интерпретировать его команды. Однако, возможна ситуация, когда вы используйте другой командный интерпретатор (например, [C shell](https://ru.wikipedia.org/wiki/Csh)). В этом случае он попытается исполнить Bash-скрипт, что вероятнее всего приведёт к ошибке. Чтобы явно указать интерпретатор, который должен выполнять скрипт, надо в начале файла ввести его абсолютный путь следующий за символами `#!`. Теперь ваша программа может быть запущена на любой системе, имеющей Bash.

I> Если в скрипте не указан интерпретатор для запуска, то утилита `file` определит его как обычный текстовый файл:
{line-numbers: false, format: Bash}
```
~/photo-backup.sh: ASCII text
```
После добавления строки `#!`, он же определяется как Bash-скрипт:
{line-numbers: false, format: Bash}
```
~/photo-backup.sh: Bourne-Again shell script, ASCII text executable
```

В некоторых системах Unix (например, FreeBSD) путь к Bash отличается от `/bin/bash`. Если вам важна переносимость скриптов, то вместо абсолютного пути до интерпретатора указывайте следующее:
{line-numbers: false, format: Bash}
```
#!/usr/bin/env bash
```

Что делает команда `/usr/bin/env bash`? Она запускает интерпретатор `bash`, используя все текущие переменные окружения. Благодаря этому, исполняемый файл `bash` будет найден в одном из путей переменной `PATH`.

### Последовательность команд

Сейчас наш скрипт выглядит как в листинге 3-1.

{caption: "Листинг 3-1. Исходный код скрипта для резервного копирования", line-numbers: true, format: Bash}
![`photo-backup.sh`](code/BashScripting/photo-backup.sh)

Команда резервного копирования слишком длинная. Из-за этого её трудно читать и изменять. Попробуем разбить её на две отдельные команды. Результат приведён в листинге 3-2.

{caption: "Листинг 3-2. Разделение команд `bsdtar` и `cp`", line-numbers: true, format: Bash}
![`photo-backup-commands.sh`](code/BashScripting/photo-backup-commands.sh)

Поведение изменённого скрипта отличается от исходного. Теперь команды не связаны оператором `&&`. Из-за этого утилита `cp` будет вызываться независимо от результата работы `bsdtar`. Чтобы вернуться к исходному поведению, нам нужно завершать скрипт в случае ошибки `bsdtar`. Для этого воспользуемся командой `exit`. Она завершает работу скрипта с кодом возврата, переданным в качестве параметра. Добавим `exit` в наш скрипт, как демонстрирует листинг 3-3.

{caption: "Листинг 3-3. Добавление вызова `exit`", line-numbers: true, format: Bash}
![`photo-backup-exit-subshell.sh`](code/BashScripting/photo-backup-exit-subshell.sh)

Мы внесли два изменения в команду вызова утилиты `bsdtar`. Сначала она соответствовала следующему выражению:
{line-numbers: false}
```
B && O1 || ! F1
```

После добавления вызова `exit` выражение стало выглядеть так:
{line-numbers: false}
```
B && O1 || (F1 ; E)
```

Команда `exit` обозначена как `E`. Теперь в случае ошибки `bsdtar` будет вычисляться правый операнд оператора `||`, который равен `(F1 ; E)`. В данном случае нам не важен результат команды `echo`, поэтому мы вспользовались разделителем `;`.

Но с нашим решением есть одна проблема. Каждый раз, когда в скрипте или команде встречаются круглые скобки `(` и `)`, интерпретатор Bash запускает сам себя в [дочернем процессе](https://en.wikipedia.org/wiki/Child_process), называемом **subshell**. В нём исполняются команды, указанные в скобках. После этого управление передаётся обратно породившему процессу Bash, который продолжат исполнение скрипта.

В нашем случае команда `exit` означает выход из subshell, но не из интерпретатора, выполняющего весь скрипт. Чтобы решить эту проблему, воспользуемся фигурными скобками `{` и `}`. Указанные в них команды будут выполняться в текущем процессе Bash без создания subshell. Исправленная версия скрипта приведена в листинге 3-4.

{caption: "Листинг 3-4. Вызов `exit` в том же процессе Bash", line-numbers: true, format: Bash}
![`photo-backup-exit.sh`](code/BashScripting/photo-backup-exit.sh)

I> Обратите внимание на обязательную точку с запятой `;` перед закрывающей фигурной скобкой `}`. Также обязательны пробелы после открывающей скобки `{` и перед закрывающей `}`.

Есть более изящное решение чем явный вызов команды `exit`. Если вам нужно завершить скрипт после первой команды, вернувшей код возврата отличный от нуля, можно воспользоваться встроенной командой `set`. Она позволяет изменить параметры работы интерпретатора. В данном случае нас интересует опция команды `-e`:
{line-numbers: false, format: Bash}
```
set -e
```

То же самое вы можете сделать, явно указав эту опцию при запуске Bash:
{line-numbers: false, format: Bash}
```
bash -e
```

[Одна из проблем параметра `-e`](http://mywiki.wooledge.org/BashFAQ/105) заключается в том, что он меняет поведение только текущего процесса Bash, но не порождённых им subshell. Дело в том, что каждая команда в конвейере или логическом операторе выполняется в отдельном subshell. Таким образом вызов `set -e` никак не повлияет на их поведение. Поэтому в нашем случае такое решение не подойдёт.

### Параметризация

Предположим, что вы перенесли свои фотографии из каталога `~/photo` в `~/Documents/Photo`. В этом случае вам придётся поменять этот путь в скрипте `photo-backup.sh` согласно листингу 3-5.

{caption: "Листинг 3-5. Изменение пути каталога фотографий", line-numbers: true, format: Bash}
![`photo-backup-path.sh`](code/BashScripting/photo-backup-path.sh)

Каждый раз при смене каталога фотографий придётся редактировать скрипт. Это неудобно. Намного лучше было бы иметь универсальную программу, которая принимала бы путь до каталога в качестве входного параметра. На самом деле при старте скрипта Bash передаёт ему все входные параметры. Они доступны под именами `0`, `1`, `2` и т.д. в зависимости от их количества. Эти параметры называются позиционными (**positional parameters**).

Рассмотрим пример. Запустим скрипт `photo-backup.sh` следующим образом:
{line-numbers: false, format: Bash}
```
./photo-backup.sh ~/Documents/Photo
```

В этом случае переменная с именем `0` будет содержать строку `./photo-backup.sh`, а переменная `1` — `~/Documents/Photo`. Все остальные переменные с именами `2` и далее будут пустыми. Если мы передаём два параметра, то последний из них будет храниться в переменной `2`, а последующие будут пустыми.

Перепишем наш скрипт так, чтобы путь до каталога фотографий читался из первого параметра. Результат приведён в листинге 3-6.

{caption: "Листинг 3-6. Чтение пути из первого параметра", line-numbers: true, format: Bash}
![`photo-backup-parameter-path.sh`](code/BashScripting/photo-backup-parameter-path.sh)

Обратите внимание, что при обращении к переменной `$1`, содержащей первый параметр, мы используем двойные кавычки. Если их не поставить, то скрипт не сможет корректно обработать пути, содержащие пробелы, из-за механизма word splitting.

Предположим, что ваши фотографии хранятся в каталоге `~/photo album`. Тогда скрипт следует вызывать следующим образом:
{line-numbers: false, format: Bash}
```
./photo-backup.sh "~/photo album"
```

Если мы передадим в утилиту `bsdtar` параметр `$1` без кавычек, её вызов в этом случае будет выглядеть так:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/photo.tar.bz2 ~/photo album && echo "bsdtar - OK" > results.txt || ! echo "bsdtar - FAILS" > results.txt
```

Тогда утилита `bsdtar` обработает строку `photo album` как имена двух каталогов `photo` и `album`. Ни один из них не существует, поэтому скрипт завершится с ошибкой.

Почему кавычек вокруг имени каталога `"~/photo album"` оказалось недостаточно при вызове скрипта? Дело в том, что эти кавычки были обработаны и отброшены процессом Bash, который работает в режиме командного интерпретатора. Скрипт же исполняется в другом процессе Bash, который ничего не знает про эти кавычки.

Итак, что нам дала параметризация скрипта? На самом деле вместо программы для резервного копирования фотографий, мы получили универсальный скрипт для архивирования любых данных: документов, медиафайлов, исходного кода программ.

Единственная проблема, которая может возникнуть в ходе использования нашего скрипта, связана с именем архива. Предположим, что мы вызываем скрипт для фотографий и документов:
{line-numbers: true, format: Bash}
```
./photo-backup.sh ~/photo
./photo-backup.sh ~/Documents
```

В этом случае обе команды приведут к созданию архива с именем `photo.tar.bz2`, который будет скопирован на диск D. Причём архив с документами перезапишет архив с фотографиями в каталоге `/d`. Это не то поведение, которое мы ожидаем. Попробуем исправить эту проблему. Для этого будем подставлять первый параметр скрипта не только в качестве целевого каталога, но и вместо имени архива. Отредактированный скрипт приведён в листинге 3-7.

{caption: "Листинг 3-7. Чтение имени архива из первого параметра", line-numbers: true, format: Bash}
![`photo-backup-parameter-name.sh`](code/BashScripting/photo-backup-parameter-name.sh)

Теперь имя архива, который будет сохранён на диске D, зависит от имени целевого каталога. Предположим, вы запустите скрипт следующим образом:
{line-numbers: true, format: Bash}
```
./photo-backup.sh ~/Documents
```

Тогда архив будет сохранён по пути `/d/Documents.tar.bz2`. При этом его имя не будет конфликтовать с именем архива фотографий `photo.tar.bz2`.

Последнее улучшение скрипта — это замена операции копирования на операцию переименования. Тогда ненужный промежуточный архив будет удаляться. Результат приведён в листинге 3-8.

{caption: "Листинг 3-8. Удаление временного архива", line-numbers: true, format: Bash}
![`photo-backup-mv.sh`](code/BashScripting/photo-backup-mv.sh)

Получив универсальный скрипт для резервного копирования, имеет смысл переименовать его вместо `photo-backup.sh` на что-то более говорящее вроде `make-backup.sh`.

### Сочетание с другими командами

Мы разработали универсальный скрипт для резервного копирования. Его можно исполнять не только самостоятельно, но и в сочетании с другими GNU утилитами и приложениями. Для удобства такого использования, имеет смысл интегрировать наш скрипт с Bash. Тогда мы сможем вызывать его по имени, а не только по относительному и абсолютному путям.

Мы уже знаем два способа интеграции приложения с Bash по опыту настройки Notepad++. Повторим их и рассмотрим ещё один способ, специфичный для скриптов:

1. Добавить путь до скрипта в переменную `PATH`. Для этого отредактируйте файл `~/.bash_profile`.

2. Определить псевдоним alias с абсолютным путём до скрипта. Такое определение можно сделать в файле `~/.bashrc`.

3. Скопировать скрипт в каталог `/usr/local/bin`. Путь до него по умолчанию добавляется в переменную `PATH`. Если в вашем окружении MSYS2 этого каталога нет — создайте его.

I> Для удаления объявленного ранее псевдонима используйте встроенную команду интерпретатора `unalias`. Для нашего примера её вызов будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
unalias make-backup.sh
```

После интеграции с Bash скрипт запускается по имени следующим образом:
{line-numbers: false, format: Bash}
```
make-backup.sh ~/photo
```

Наш скрипт можно использовать в конструкциях с конвейерами и логическими операторами также как любую встроенную команду Bash или GNU утилиту.

Рассмотрим пример. Предположим, что вам нужно сделать резервную копию всех PDF документов из каталога `~/Documents`. Эти документы мы можем найти следующим вызовом утилиты `find`:
{line-numbers: false, format: Bash}
```
find ~/Documents -type f -name "*.pdf"
```

Над каждым из найденных файлов выполним действие резервного копирования с помощью нашего скрипта:
{line-numbers: false, format: Bash}
```
find ~/Documents -type f -name "*.pdf" -exec ./make-backup.sh {} \;
```

I> Как вы помните, экранированная точка с запятой `\;` означает выполнение действия над каждым из указанных файлов.

В результате выполнения этой команды в корневой каталог диска D (`/d/`) будут скопированы архивы с каждым из найденных PDF файлов. То есть каждому документу будет соответствовать отдельный архив. Это неудобно. Было бы лучше собрать все найденные файлы в один архив.

Попробуем вызывать наш скрипт один раз сразу для всех файлов, найденных командой `find`:
{line-numbers: false, format: Bash}
```
find ~/Documents -type f -name *.pdf -exec ./make-backup.sh {} +
```

В результате этой команды будет скопирован только первый из найденных PDF документов. Почему это происходит? Рассмотрим, как выглядит вызов утилиты `bsdtar` в нашем скрипте. Для простоты опустим выводы `echo` в лог-файл:
{line-numbers: false, format: Bash}
```
bsdtar -cjf "$1".tar.bz2 "$1"
```

Проблема заключается в том, что мы обрабатываем только первый позиционный параметр, переданный на вход скрипта. Он сохраняется в переменной с именем `1`. При этом игнорируются все дальнейшие параметры в переменных `2`, `3` и т.д. Но именно в них передаются результаты поиска утилиты `find`, когда мы указываем знак `+` после действия `-exec`.

Чтобы решить эту проблему, воспользуемся переменной с именем `@`. В ней интерпретатор сохраняет все параметры, переданные в скрипт. В этом случае нам придётся изменить вызов `bsdtar` на следующий:
{line-numbers: false, format: Bash}
```
bsdtar -cjf "$1".tar.bz2 "$@" && echo "bsdtar - OK" > results.txt || ! echo "bsdtar - FAILS" > results.txt
```

Теперь вместо первого параметра `$1` мы передаём на вход утилиты `bsdtar` все входные параметры скрипта `$@`. Обратите внимание, что в качестве имени архива всё равно будет использоваться имя первого параметра `$1`.

Листинг 3-9 демонстрирует финальную версию скрипта, который обрабатывает произвольное число входных параметров.

{caption: "Листинг 3-9. Обработка произвольного числа входных параметров", line-numbers: true, format: Bash}
![`make-backup.sh`](code/BashScripting/make-backup.sh)

В Bash есть ещё одна переменная `$*`, которая очень похожа на `$@`. Их отличие в том, что строка в `$*`, заключённая в двойные кавычки, интерпретируется как одно слово. Если вы используете переменную `$@`, она в этом случае интерпретируется как набор слов. Предположим, наш скрипты вызывается так:
{line-numbers: false, format: Bash}
```
make-backup.sh "one two three"
```
В этом случае при чтении `"$*"` в скрипте мы получим:
{line-numbers: false, format: Bash}
```
"one two three"
```
Параметр же `"$@"` будет равен:
{line-numbers: false, format: Bash}
```
"one" "two" "three"
```
W> Всегда предпочитайте использовать `"$@"`, кроме случая когда вам нужно представить все входные параметры одним словом.

### Возможности скриптов

На примере задачи резервного копирования данных мы рассмотрели некоторые возможности Bash-скриптов. Как вы помните, требования задачи звучали следующим образом:

1. Долговременное хранение команды.
2. Удобство вызова.
3. Возможность её расширения.
4. Возможность сочетания с другими командами.

Наш финальный скрипт `make-backup.sh` удовлетворяет всем этим требованиям. Проверим каждый из этих пунктов:

1. Скрипт хранится на жёстком диске и это обеспечивает его долговременное хранение.

2. Скрипт легко интегрировать с Bash тремя различными способами. Благодаря этому, его так же удобно вызывать, как и любую GNU утилиту.

3. Скрипт представляет собой последовательность команд, каждая из которых начинается с новой строки. Его удобно читать и редактировать. Благодаря параметризации, его легко обобщить для решения однотипных задач.

4. За счёт интеграции с Bash скрипт удобно сочетать с другими командами, в том числе с помощью конвейеров и логических операторов.

Если вам нужна любая из этих возможностей, напишите Bash-скрипт.
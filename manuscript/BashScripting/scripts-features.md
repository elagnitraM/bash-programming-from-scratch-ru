## Зачем нужны скрипты?

В прошлой главе мы научились писать сложные Bash команды с использованием конвейеров и логических операторов.

Конвейеры позволяют объединить несколько команд в одну и получить линейный алгоритм. Логические операторы добавляют в него ветвление. Таким образом сложное поведение достигнуто только средствами командного интерпретатора.

Может возникнуть вопрос: зачем объединять набор команд в программу, хранящуюся на жёстком диске? Это разумное сомнение. Предлагаю разобрать его подробнее.

### Команда для резервного копирования

Напишем команду для резервного копирования фотографий на [внешний жёсткий диск](https://ru.wikipedia.org/wiki/Внешний_жёсткий_диск). Она будет состоять всего из двух действий: архивирования и копирования. Предположим, что фотографии хранятся в каталоге `~/photo`, а `/d` — это точка монтирования внешнего диска. Тогда команда может выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/photo.tar.bz2 ~/photo && cp -f ~/photo.tar.bz2 /d
```

Благодаря оператору `&&`, копирование выполняется только в случае успешного архивирования.

I> В нашем примере мы выполняем резервное копирование в два этапа: архивирование и копирование. Такое разделение действий нужно для образовательных целей. На самом деле вы можете выполнить резервное копирование одним вызовом утилиты `bsdtar`. Для этого просто укажите путь до архива на диске D. Например так:
{line-numbers: false, format: Bash}
```
bsdtar -cjf /d/photo.tar.bz2 ~/photo
```

Для проверки корректности добавим вывод результатов каждой операции в лог-файл. Мы уже знаем, как это сделать с помощью команды `echo` и логических операторов:
{line-numbers: true, format: Bash}
```
bsdtar -cjf ~/photo.tar.bz2 ~/photo && echo "bsdtar - OK" > results.txt || echo "bsdtar - FAILS" > results.txt
cp -f ~/photo.tar.bz2 /d && echo "cp - OK" >> results.txt || echo "cp - FAILS" >> results.txt
```

Вопрос в том, как нам объединить эти две команды в одну? Попробуем прямолинейное решение с оператором `&&` между ними:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/photo.tar.bz2 ~/photo && echo "bsdtar - OK" > results.txt || echo "bsdtar - FAILS" > results.txt && cp -f ~/photo.tar.bz2 /d && echo "cp - OK" >> results.txt || echo "cp - FAILS" >> results.txt
```

Что будет делать эта команда? Для простоты рассмотрения перепишем её в виде логического выражения, заменив каждый вызов на буквы латинского алфавита:
{line-numbers: false, format: Bash}
```
B && O1 || F1 && C && O2 || F2
```

Буквы `B` и `C` обозначают вызовы утилит `bsdtar` и `cp`. `O1` и`F1` — это вывод в лог-файл "OK" и "FAIL" соответственно для результата работы `bsdtar`. Аналогично, `O2` и `F2` — это вывод результата `cp`.

В случае истинности `B` проблем с порядком исполнения команд не возникнет. Будет выполнена следующая последовательность действий:

1. B
2. O1
3. C
4. O2 или F2

Однако, если `B` ложно, произойдёт ошибка. В этом случае будет выполнено следующее:

1. B
2. F1
3. C
4. O2 или F2

Очевидно, что операция копирования не имеет смысла, если архивирование завершилось с ошибкой. Ситуация усугубляется тем, что утилита `bsdtar` создаёт пустой архив, если целевого каталога или файла не существует. В этом случае `cp` успешно скопирует его и запишет в лог-файл "cp - OK". В результате `results.txt` будет выглядеть следующим образом:
{line-numbers: true}
```
tar - FAILS
cp - OK
```

Такой вывод только запутает пользователя.

Причина ошибки порядка выполнения в том, что вызов `F1` (команда `echo`) всегда возвращает истину. Это приводит к тому, что выражение `B && O1 || F1` истинно в случае ошибки `bsdtar` и дальнейшие команды продолжат исполняться. Всё что нам нужно сделать — это инвертировать результат вызова `F1` с помощью логического НЕ, которое в Bash обозначается как `!`:
{line-numbers: false}
```
B && O1 || ! F1 && C && O2 || F2
```

Теперь в случае ошибки утилиты `bsdtar` в лог-файл будет выведено "bsdtar - FAIL". Но оставшаяся часть выражения всё равно будет обработана. Операции `C` и `O2` не будут выполнены, потому что связаны логическим И с результатом `F1`, который всегда ложен. При этом операнд `F2` будет вычислен. На самом деле наше выражение выглядит теперь так:
{line-numbers: false}
```
(B && O1 || ! F1 && C && O2) || F2
```

В результате выполнения этой команды в лог файл будет выведено:
{line-numbers: true}
```
tar - FAILS
cp - FAILS
```

Такое поведение лучше предыдущего. Теперь утилита `cp` не вызывается и пустой архив не копируется. Но представьте, что мы пишем команду в которой около 100 операций. Если ошибка произойдёт, например, на 50-ой, вывод всех оставшихся всё равно попадёт в лог-файл. Это затруднит поиск проблемы. Правильным поведением в этом случае было бы прекращение выполнения всей команды сразу после первой же ошибки. Чтобы добиться этого поведения, нам нужно сгруппировать вызов каждой утилиты и соответствующий ей вывод в лог-файл следующим образом:
{line-numbers: false}
```
(B && O1 || ! F1) && (C && O2 || F2)
```

Рассмотрим, что произойдёт если `B` ложно. В этом случае отработает `F1` и вернёт ложь, благодаря отрицанию `!`. В результате всё выражение `(B && O1 || ! F1)` будет ложным. Тогда из-за короткого замыкания оператор `&&` не станет вычислять свой правый операнд, равный выражению `(C && O2 || F2)`. Таким образом мы получим именно то поведение, которое нам нужно.

Добавим последний штрих. Имеет смысл также инвертировать вызов `F2` с помощью логического НЕ. Благодаря этому, вся наша команда вернёт ложь, если значение `B` истинно, а `C` ложно. Такое поведение может быть полезно в случае интеграции нашей команды с другими или расширения её функций. В результате получим:
{line-numbers: false}
```
(B && O1 || ! F1) && (C && O2 || ! F2)
```

Если мы вернёмся к реальному коду на Bash, наша команда станет выглядеть так:
{line-numbers: false, format: Bash}
```
(bsdtar -cjf ~/photo.tar.bz2 ~/photo && echo "bsdtar - OK" > results.txt || ! echo "bsdtar - FAILS" > results.txt) && (cp -f ~/photo.tar.bz2 /d && echo "cp - OK" >> results.txt || ! echo "cp - FAILS" >> results.txt)
```

Как это часто бывает в программировании, такую команду несложно написать, но достаточно трудно прочитать и понять.

### Неверное техническое решение

Мы написали достаточно длинную команду резервного копирования. Предположим, что её надо выполнять регулярно. Тогда нам потребуется где-то её сохранить, чтобы не набирать каждый раз в окне терминала.

Мы знаем, что все выполненные Bash команды автоматически сохраняются в файле истории `~/.bash_history`. Поиск по нему осуществляется по комбинации Ctrl+R. Таким образом мы сможем легко найти нашу команду резервного копирования, исполненную ранее.  Это решение может показаться вам надёжным и удобным. Но не торопитесь с выводами. Давайте рассмотрим связанные с ним возможные проблемы.

Прежде всего размер истории Bash ограничен. По умолчанию сохраняются только 500 последних выполненных команд. Если превысить это число, то каждая новая команда будет записана вместо самой старой. Таким образом возникает риск случайно потерять то, что нам нужно.

Можно увеличить максимальный размер истории. Но сразу возникает вопрос: увеличить на сколько? Какой бы большой размер мы не выбрали, рано или поздно появляется риск его переполнения. Есть вариант вообще снять ограничение на размер. Тогда будут сохраняться все введённые команды, а старые никогда не будут удаляться.

Кажется, нам удалось решить проблему и найти приемлемое техническое решение. Имеет ли оно какие-то побочные эффекты? Давайте подумает над этим вопросом. Предположим, что вы используйте Bash год или два. Все команды, введённые вами за это время, попадут в файл `.bash_history`. Учтите, что одни и те же команды в нём дублируются. То есть, например, каждая команда `cd ~` будет записана в этот файл, независимо от того есть уже она в нём или нет. Можно предположить, что за год этот файл достигнет значительного размера около нескольких сотен мегабайт. При этом большая часть сохранённой в нём информации окажется не нужна. Нас интересует только несколько команд, которые мы используем регулярно. В результате мы получим первый побочный эффект: нерациональное использование места на жёстком диске.

Вы можете возразить, что хранить лишние две-три сотни мегабайт — это не проблема для современных компьютеров. Да, это так. Но не забывайте, что по нажатию Ctrl+R Bash ищет нужную команду по всему файлу `.bash_history`. Чем он больше, тем больше надо времени на этот поиск. Рано или поздно он станет занимать десятки секунд даже на мощном компьютере. Дальше с ростом файла это время будет только увеличиваться.

Раздувание файла истории приводит к увеличению времени поиска. Это связано не только с тем, что Bash приходится перебирать больше строк. Поиск по Ctrl+R позволяет вам ввести начало нужной команды. Представьте себе, что история огромна. В этом случае в ней много сохранённых команд, которые начинаются одинаково. В результате вам придётся набирать больше символов, чтобы найти из них нужную. Неудобство вызова команды — это второй побочный эффект нашего решения.

Предположим, что у нас появились новые альбомы фотографий. Они хранятся не в каталоге `~/photo`, а например в `~/Documents/official_photo`. К сожалению, наша команда резервного копирования работает только с одним предопределённым путём. Чтобы она стала поддерживать другие, необходимо её переписать и добавить новые шаги для архивации и копирования каталога `~/Documents/official_photo`. В результате отредактированная команда также попадёт в историю `.bash_history`. Это опять же увеличит время на её поиск. Итак, сложность расширения функций — третий побочный эффект.

Если вы решите объединить нашу команду резервного копирования фотографий с аналогичной ей, которая копирует документы, это будет проблематично. Опять же понадобиться новая команда, которая сочетает в себе две существующие.

Какой можно сделать вывод из рассмотренных нами потенциальных проблем? История команд не подходит для долговременного хранения. Настоящая причина всех возникших при этом сложностей в том, что мы попытались использовать механизм для целей, к которым он не был предназначен. В результате мы пришли к техническому решению, которое неудобно в использовании и сопровождении.

Неверные технические решения распространены не только среди начинающих программистов. Профессионалы с большим опытом тоже их совершают и достаточно часто. В чём причина таких решений? На самом деле этих причин много. В нашем случае она заключается в недостатке знанияй. Мы освоились с работой Bash в режиме командного интерпретатора. Но применяя полученные знания для новой задачи резервного копирования, мы не учли в полной мере её требований. Как оказалось, кроме непосредственного копирования, необходимо обеспечить следующее:

1. Долговременное хранение команды.
2. Удобство вызова.
3. Возможность её расширения.
4. Возможность сочетания с другими командами.

Чтобы удовлетворить этим требованиям, наших знаний просто недостаточно. Все известные нам на данный момент механизмы не подходят. Но, вероятно, Bash скрипт поможет нам выйти из этого затруднения. Предлагаю изучить его возможности, а затем проверить, помогут ли новые знания в решении поставленной задачи.

### Запуск скрипта

Сделаем скрипт на основе нашей команды для резервного копирования. Для этого выполните следующие действия:

1. Откройте редактор исходного кода и создайте в нём новый файл. Для Notepad++, интегрированного с Bash, команда запуска может выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
notepad++ ~/photo-backup.sh
```

2. Скопируйте в файл команду резервного копирования:
{line-numbers: false, format: Bash}
```
(bsdtar -cjf ~/photo.tar.bz2 ~/photo && echo "bsdtar - OK" > results.txt || ! echo "bsdtar - FAILS" > results.txt) && (cp -f ~/photo.tar.bz2 /d && echo "cp - OK" >> results.txt || ! echo "cp - FAILS" >> results.txt)
```

3. Сохраните измененный файл и закройте редактор.

В результате мы получим файл скрипта `photo-backup.sh` в домашнем каталоге пользователя. Чтобы его исполнить, запустите интерпретатор командой `bash` и передайте имя файла первым параметром:
{line-numbers: false, format: Bash}
```
bash photo-backup.sh
```

Мы только что написали и запустили наш первый Bash-скрипт. В общем случае он представляет собой последовательность команд, записанных в файл. Обратите внимание, что порядок их исполнения точно такой же, как если бы вы вводили их вручную в окно терминала.

Запуск скриптов с явным вызовом интерпретатора Bash неудобен. Можем ли мы запустить нашу программу так же, как и любую другую GNU утилиту по относительному или абсолютному пути? Можем, но для этого нам потребуется несколько действий:

1. В окне терминала выполните следующую команду:
{line-numbers: false, format: Bash}
```
chmod +x ~/photo-backup.sh
```

2. Откройте файл скрипта для редактирования и добавьте в его начало следующую строку:
{line-numbers: false, format: Bash}
```
#!/bin/bash
```

3. Сохраните изменённый файл и закройте редактор.

Теперь вы можете запускать скрипт по относительному или абсолютному путям.

Рассмотрим выполненные нами действия. Первое, что мешает нам запустить скрипт — это права доступа. По умолчанию все созданные пользователем файлы имеют следующие права:
{line-numbers: false}
```
-rw-rw-r--
```

Это значит, что владелец и его группа могут читать и изменять файл. Все остальные могут только читать. Команда `chmod` меняет права указанного файла. Передав ей опцию `+x`, мы разрешили всем пользователям исполнение нашего скрипта. В результате его права станут следующими:
{line-numbers: false}
```
-rwxrwxr-x
```

После этого шага, вы уже можете запустить файл и Bash будет интерпретировать его команды. Однако, возможна ситуация, когда вы используйте другой командный интерпретатор (например, [C shell](https://ru.wikipedia.org/wiki/Csh)). В этом случае он попытается исполнить Bash-скрипт, что вероятнее всего приведёт к ошибке. Чтобы явно указать интерпретатор, который должен выполнять скрипт, надо в начале файла ввести его абсолютный путь следующий за символами `#!`. Теперь ваша программа может быть запущена на любой системе, имеющей Bash.

I> Если в скрипте не указан интерпретатор для запуска, то утилита `file` определит его как обычный текстовый файл:
{line-numbers: false, format: Bash}
```
~/photo-backup.sh: ASCII text
```
После добавления строки `#!`, он же определяется как Bash-скрипт:
{line-numbers: false, format: Bash}
```
~/photo-backup.sh: Bourne-Again shell script, ASCII text executable
```

В некоторых системах Unix (например, FreeBSD) путь к Bash отличается от `/bin/bash`. Если вам важна переносимость скриптов, то вместо абсолютного пути до интерпретатора указывайте следующее:
{line-numbers: false, format: Bash}
```
#!/usr/bin/env bash
```

Что делает команда `/usr/bin/env bash`? Она запускает интерпретатор `bash`, используя все текущие переменные окружения. Благодаря этому, исполняемый файл `bash` будет найден в одном из путей переменной `PATH`.

### Последовательность команд

Сейчас наш скрипт выглядит как в листинге 3-1.

{caption: "Листинг 3-1. Исходный код скрипта для резервного копирования", line-numbers: true, format: Bash}
![`photo-backup.sh`](code/BashScripting/photo-backup.sh)

Команда резервного копирования слишком длинная. Из-за этого её трудно читать и изменять. Попробуем разбить её на две отдельные команды. Результат приведён в листинге 3-2.

{caption: "Листинг 3-2. Разделение команд `bsdtar` и `cp`", line-numbers: true, format: Bash}
![`photo-backup-commands.sh`](code/BashScripting/photo-backup-commands.sh)

Поведение изменённого скрипта отличается от исходного. Теперь команды не связаны оператором `&&`. Из-за этого утилита `cp` будет вызываться независимо от результата работы `bsdtar`. Чтобы вернуться к исходному поведению, нам нужно завершать скрипт в случае ошибки `bsdtar`. Для этого воспользуемся командой `exit`. Она завершает работу скрипта с кодом возврата, переданным в качестве параметра. Добавим `exit` в наш скрипт, как демонстрирует листинг 3-3.

{caption: "Листинг 3-3. Добавление вызова `exit`", line-numbers: true, format: Bash}
![`photo-backup-exit-subshell.sh`](code/BashScripting/photo-backup-exit-subshell.sh)

Мы внесли два изменения в команду вызова утилиты `bsdtar`. Сначала она соответствовала следующему выражению:
{line-numbers: false}
```
B && O1 || ! F1
```

После добавления вызова `exit` выражение стало выглядеть так:
{line-numbers: false}
```
B && O1 || (F1 ; E)
```

Команда `exit` обозначена как `E`. Теперь в случае ошибки `bsdtar` будет вычисляться правый операнд оператора `||`, который равен `(F1 ; E)`. В данном случае нам не важен результат команды `echo`, поэтому мы вспользовались разделителем `;`.

Но с нашим решением есть одна проблема. Каждый раз, когда в скрипте или команде встречаются круглые скобки `(` и `)`, интерпретатор Bash запускает сам себя в [дочернем процессе](https://en.wikipedia.org/wiki/Child_process), называемом **subshell**. В нём исполняются команды, указанные в скобках. После этого управление передаётся обратно породившему процессу Bash, который продолжат исполнение скрипта.

В нашем случае команда `exit` означает выход из subshell, но не из интерпретатора, выполняющего весь скрипт. Чтобы решить эту проблему, воспользуемся фигурными скобками `{` и `}`. Указанные в них команды будут выполняться в текущем процессе Bash без создания subshell. Исправленная версия скрипта приведена в листинге 3-4.

{caption: "Листинг 3-4. Вызов `exit` в том же процессе Bash", line-numbers: true, format: Bash}
![`photo-backup-exit.sh`](code/BashScripting/photo-backup-exit.sh)

I> Обратите внимание на обязательную точку с запятой `;` перед закрывающей фигурной скобкой `}`. Также обязательны пробелы после открывающей скобки `{` и перед закрывающей `}`.

Есть более изящное решение чем явный вызов команды `exit`. Если вам нужно завершить скрипт после первой команды, вернувшей код возврата отличный от нуля, можно воспользоваться встроенной командой `set`. Она позволяет изменить параметры работы интерпретатора. В данном случае нас интересует опция команды `-e`:
{line-numbers: false, format: Bash}
```
set -e
```

То же самое вы можете сделать, явно указав эту опцию при запуске Bash:
{line-numbers: false, format: Bash}
```
bash -e
```

[Одна из проблем параметра `-e`](http://mywiki.wooledge.org/BashFAQ/105) заключается в том, что он меняет поведение только текущего процесса Bash, но не порождённых им subshell. Дело в том, что каждая команда в конвейере или логическом операторе выполняется в отдельном subshell. Таким образом вызов `set -e` никак не повлияет на их поведение. Поэтому в нашем случае такое решение не подойдёт.

### Параметризация

Предположим, что вы перенесли свои фотографии из каталога `~/photo` в `~/Documents/Photo`. В этом случае вам придётся поменять этот путь в скрипте `photo-backup.sh` согласно листингу 3-5.

{caption: "Листинг 3-5. Изменение пути каталога фотографий", line-numbers: true, format: Bash}
![`photo-backup-path.sh`](code/BashScripting/photo-backup-path.sh)

Каждый раз при смене каталога фотографий придётся редактировать скрипт. Это неудобно. Намного лучше было бы иметь универсальную программу, которая принимала бы путь до каталога в качестве входного параметра. На самом деле при старте скрипта Bash передаёт ему все входные параметры. Они доступны под именами `0`, `1`, `2` и т.д. в зависимости от их количества. Эти параметры называются позиционными (**positional parameters**).

Рассмотрим пример. Запустим скрипт `photo-backup.sh` следующим образом:
{line-numbers: false, format: Bash}
```
./photo-backup.sh ~/Documents/Photo
```

В этом случае переменная с именем `0` будет содержать строку `./photo-backup.sh`, а переменная `1` — `~/Documents/Photo`. Все остальные переменные с именами `2` и далее будут пустыми. Если мы передаём два параметра, то последний из них будет храниться в переменной `2`, а последующие будут пустыми.

Перепишем наш скрипт так, чтобы путь до каталога фотографий читался из первого параметра. Результат приведён в листинге 3-6.

{caption: "Листинг 3-6. Чтение пути из первого параметра", line-numbers: true, format: Bash}
![`photo-backup-parameter-path.sh`](code/BashScripting/photo-backup-parameter-path.sh)

Обратите внимание, что при обращении к переменной `$1`, содержащей первый параметр, мы используем двойные кавычки. Если их не поставить, то скрипт не сможет корректно обработать пути, содержащие пробелы, из-за механизма word splitting.

Предположим, что ваши фотографии хранятся в каталоге `~/photo album`. Тогда скрипт следует вызывать следующим образом:
{line-numbers: false, format: Bash}
```
./photo-backup.sh "~/photo album"
```

Если мы передадим в утилиту `bsdtar` параметр `$1` без кавычек, её вызов в этом случае будет выглядеть так:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/photo.tar.bz2 ~/photo album && echo "bsdtar - OK" > results.txt || ! echo "bsdtar - FAILS" > results.txt
```

Тогда утилита `bsdtar` обработает строку `photo album` как имена двух каталогов `photo` и `album`. Ни один из них не существует, поэтому скрипт завершится с ошибкой.

Почему кавычек вокруг имени каталога `"~/photo album"` оказалось недостаточно при вызове скрипта? Дело в том, что эти кавычки были обработаны и отброшены процессом Bash, который работает в режиме командного интерпретатора. Скрипт же исполняется в другом процессе Bash, который ничего не знает про эти кавычки.

Итак, что нам дала параметризация скрипта? На самом деле вместо программы для резервного копирования фотографий, мы получили универсальный скрипт для архивирования любых данных: документов, медиафайлов, исходного кода программ.

Единственная проблема, которая может возникнуть в ходе использования нашего скрипта, связана с именем архива. Предположим, что мы вызываем скрипт для фотографий и документов:
{line-numbers: true, format: Bash}
```
./photo-backup.sh ~/photo
./photo-backup.sh ~/Documents
```

В этом случае обе команды приведут к созданию архива с именем `photo.tar.bz2`, который будет скопирован на диск D. Причём архив с документами перезапишет архив с фотографиями в каталоге `/d`. Это не то поведение, которое мы ожидаем. Попробуем исправить эту проблему. Для этого будем подставлять первый параметр скрипта не только в качестве целевого каталога, но и вместо имени архива. Отредактированный скрипт приведён в листинге 3-7.

{caption: "Листинг 3-7. Чтение имени архива из первого параметра", line-numbers: true, format: Bash}
![`photo-backup-parameter-name.sh`](code/BashScripting/photo-backup-parameter-name.sh)

Теперь имя архива, который будет сохранён на диске D, зависит от имени целевого каталога. Предположим, вы запустите скрипт следующим образом:
{line-numbers: true, format: Bash}
```
./photo-backup.sh ~/Documents
```

Тогда архив будет сохранён по пути `/d/Documents.tar.bz2`. При этом его имя не будет конфликтовать с именем архива фотографий `photo.tar.bz2`.

Последнее улучшение скрипта — это замена операции копирования на операцию переименования. Тогда ненужный промежуточный архив будет удаляться. Результат приведён в листинге 3-8.

{caption: "Листинг 3-8. Удаление временного архива", line-numbers: true, format: Bash}
![`photo-backup-mv.sh`](code/BashScripting/photo-backup-mv.sh)

Получив универсальный скрипт для резервного копирования, имеет смысл переименовать его вместо `photo-backup.sh` на что-то более говорящее вроде `make-backup.sh`.

### Сочетание с другими командами

Мы разработали универсальный скрипт для резервного копирования. Его можно исполнять не только самостоятельно, но и в сочетании с другими GNU утилитами и приложениями. Для удобства такого использования, имеет смысл интегрировать наш скрипт с Bash. Тогда мы сможем вызывать его по имени, а не только по относительному и абсолютному путям.

Мы уже знаем два способа интеграции приложения с Bash по опыту настройки Notepad++. Повторим их и рассмотрим ещё один способ, специфичный для скриптов:

1. Добавить путь до скрипта в переменную `PATH`. Для этого отредактируйте файл `~/.bash_profile`.

2. Определить псевдоним alias с абсолютным путём до скрипта. Такое определение можно сделать в файле `~/.bashrc`.

3. Скопировать скрипт в каталог `/usr/local/bin`. Путь до него по умолчанию добавляется в переменную `PATH`. Если в вашем окружении MSYS2 этого каталога нет — создайте его.

I> Для удаления объявленного ранее псевдонима используйте встроенную команду интерпретатора `unalias`. Для нашего примера её вызов будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
unalias make-backup.sh
```

После интеграции с Bash скрипт запускается по имени следующим образом:
{line-numbers: false, format: Bash}
```
make-backup.sh ~/photo
```

Наш скрипт можно использовать в конструкциях с конвейерами и логическими операторами также как любую встроенную команду Bash или GNU утилиту.

Рассмотрим пример. Предположим, что вам нужно сделать резервную копию всех PDF документов из каталога `~/Documents`. Эти документы мы можем найти следующим вызовом утилиты `find`:
{line-numbers: false, format: Bash}
```
find ~/Documents -type f -name "*.pdf"
```

Над каждым из найденных файлов выполним действие резервного копирования с помощью нашего скрипта:
{line-numbers: false, format: Bash}
```
find ~/Documents -type f -name "*.pdf" -exec ./make-backup.sh {} \;
```

I> Как вы помните, экранированная точка с запятой `\;` означает выполнение действия над каждым из указанных файлов.

В результате выполнения этой команды в корневой каталог диска D (`/d/`) будут скопированы архивы с каждым из найденных PDF файлов. То есть каждому документу будет соответствовать отдельный архив. Это неудобно. Было бы лучше собрать все найденные файлы в один архив.

Попробуем вызывать наш скрипт один раз сразу для всех файлов, найденных командой `find`:
{line-numbers: false, format: Bash}
```
find ~/Documents -type f -name *.pdf -exec ./make-backup.sh {} +
```

В результате этой команды будет скопирован только первый из найденных PDF документов. Почему это происходит? Рассмотрим, как выглядит вызов утилиты `bsdtar` в нашем скрипте. Для простоты опустим выводы `echo` в лог-файл:
{line-numbers: false, format: Bash}
```
bsdtar -cjf "$1".tar.bz2 "$1"
```

Проблема заключается в том, что мы обрабатываем только первый позиционный параметр, переданный на вход скрипта. Он сохраняется в переменной с именем `1`. При этом игнорируются все дальнейшие параметры в переменных `2`, `3` и т.д. Но именно в них передаются результаты поиска утилиты `find`, когда мы указываем знак `+` после действия `-exec`.

Чтобы решить эту проблему, воспользуемся переменной с именем `@`. В ней интерпретатор сохраняет все параметры, переданные в скрипт. В этом случае нам придётся изменить вызов `bsdtar` на следующий:
{line-numbers: false, format: Bash}
```
bsdtar -cjf "$1".tar.bz2 "$@" && echo "bsdtar - OK" > results.txt || ! echo "bsdtar - FAILS" > results.txt
```

Теперь вместо первого параметра `$1` мы передаём на вход утилиты `bsdtar` все входные параметры скрипта `$@`. Обратите внимание, что в качестве имени архива всё равно будет использоваться имя первого параметра `$1`.

Листинг 3-9 демонстрирует финальную версию скрипта, который обрабатывает произвольное число входных параметров.

{caption: "Листинг 3-9. Обработка произвольного числа входных параметров", line-numbers: true, format: Bash}
![`make-backup.sh`](code/BashScripting/make-backup.sh)

В Bash есть ещё одна переменная `$*`, которая очень похожа на `$@`. Их отличие в том, что строка в `$*`, заключённая в двойные кавычки, интерпретируется как одно слово. Если вы используете переменную `$@`, она в этом случае интерпретируется как набор слов. Предположим, наш скрипты вызывается так:
{line-numbers: false, format: Bash}
```
make-backup.sh "one two three"
```
В этом случае при чтении `"$*"` в скрипте мы получим:
{line-numbers: false, format: Bash}
```
"one two three"
```
Параметр же `"$@"` будет равен:
{line-numbers: false, format: Bash}
```
"one" "two" "three"
```
W> Всегда предпочитайте использовать `"$@"`, кроме случая когда вам нужно представить все входные параметры одним словом.

### Возможности скриптов

На примере задачи резервного копирования данных мы рассмотрели некоторые возможности Bash-скриптов. Как вы помните, требования задачи звучали следующим образом:

1. Долговременное хранение команды.
2. Удобство вызова.
3. Возможность её расширения.
4. Возможность сочетания с другими командами.

Наш финальный скрипт `make-backup.sh` удовлетворяет всем этим требованиям. Проверим каждый из этих пунктов:

1. Скрипт хранится на жёстком диске и это обеспечивает его долговременное хранение.

2. Скрипт легко интегрировать с Bash тремя различными способами. Благодаря этому, его так же удобно вызывать, как и любую GNU утилиту.

3. Скрипт представляет собой последовательность команд, каждая из которых начинается с новой строки. Его удобно читать и редактировать. Благодаря параметризации, его легко обобщить для решения однотипных задач.

4. За счёт интеграции с Bash скрипт удобно сочетать с другими командами, в том числе с помощью конвейеров и логических операторов.

Если вам нужна любая из этих возможностей, напишите Bash-скрипт.
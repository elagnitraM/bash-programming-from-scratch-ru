## Условные операторы

Работая с утилитой find, мы впервые познакомились с условными конструкциями. Затем мы выяснили, что у Bash есть собственные логические операторы И (&&) и ИЛИ (||). Это не единственные формы ветвления в языке Bash.

В этом разделе мы рассмотрим операторы if и case. Они часто используются в скриптах. Эти операторы взаимозаменяемы. Но каждый из них лучше справляется с определёнными задачами.

### Оператор if

Представьте, что вы пишете однострочную команду. При этом вы стараетесь сделать её как можно компактнее. Короткая команда удобнее длинной. Её проще набрать и меньше вероятность ошибиться.

Теперь представьте, что вы пишете скрипт. Он хранится на жёстком диске. При этом вы вызываете его регулярно и иногда изменяете. Здесь компактность не так важна. В первую очередь скрипт должен быть удобен для чтения и редактирования.

Операторы && и || хорошо подходят для однострочных команд. Но для скриптов есть альтернативы получше. На самом деле всё зависит от конкретного случая. Иногда операторы && и || вписываются в код скрипта без проблем. Но зачастую они приводят к трудночитаемому коду. Поэтому лучше заменять их на операторы if или case. Рассмотрим эти случаи подробнее.

Ещё раз обратимся к скрипту для резервного копирования из листинга 3-9. Вызов утилиты bsdtar в этом скрипте выглядит так:
{line-numbers: false, format: Bash}
```
bsdtar -cjf "$1".tar.bz2 "$@" &&
  echo "bsdtar - OK" > results.txt ||
  { echo "bsdtar - FAILS" > results.txt ; exit 1 ; }
```

Чтобы улучшить читаемость скрипта, мы разбили вызовы утилит bsdtar и mv на отдельные команды. Это помогло, но лишь отчасти. Вызов bsdtar всё ещё слишком длинный. При его изменении легко допустить ошибку. Такой подверженный ошибкам код называется **хрупким** (fragile). Это верный признак плохого технического решения, принятого при его разработке.

Распишем алгоритм вызова bsdtar по шагам:

1. Прочитать из переменной `$@` список файлов и каталогов. Архивировать и сжать их.

2. Если архивирование и сжатие прошло успешно, записать в лог-файл строку "bsdtar - OK".

3. Если произошла ошибка, записать в лог-файл строку "bsdtar - FAILS" и завершить работу скрипта.

Вопросы вызывает третий пункт. При успешном завершении bsdtar выполняется только одно действие. В случае же ошибки — действий два и они объединены в [**блок команд**](https://ru.wikipedia.org/wiki/Блок_(программирование)) с помощью [фигурных скобок](https://www.gnu.org/software/bash/manual/html_node/Command-Grouping.html) { и }.

Конструкция if введена в язык Bash как раз для удобства работы с блоками команд. В общем случае она выглядит так:
{line-numbers: true}
```
if УСЛОВИЕ
then
    ДЕЙСТВИЕ
fi
```

Эту конструкцию можно записать и в одну строку. Для этого перед then и fi добавьте по точке с запятой:
{line-numbers: false}
```
if УСЛОВИЕ; then ДЕЙСТВИЕ; fi
```

УСЛОВИЕ и ДЕЙСТВИЕ в операторе if представляют собой команду или блок команд. Если УСЛОВИЕ завершилось успешно с кодом возврата 0, будут выполнены команды, соответствующие ДЕЙСТВИЮ.

Рассмотрим следующий пример конструкции if:
{line-numbers: true, format: Bash}
```
if cmp file1.txt file2.txt &> /dev/null
then
    echo "Файлы file1.txt и file2.txt идентичны"
fi
```

Здесь в качестве УСЛОВИЯ вызывается утилита cmp. Она побайтово сравнивает содержимое двух файлов. Если они отличаются, cmp напечатает в стандартный поток вывода позицию первого различающегося символа. При этом код возврата утилиты будет отличным от нуля. Если содержимое файлов совпадает — утилита вернёт ноль.

В конструкции if нас интересует только код возврата утилиты cmp. Поэтому мы перенаправляем её вывод в файл [`/dev/null`](https://ru.wikipedia.org/wiki//dev/null). Это специальный системный файл. Запись в него всегда проходит успешно, а все записанные данные удаляются.

Итак, если содержимое файлов `file1.txt` и `file2.txt` совпадает, утилита cmp вернёт код ноль. Тогда условие конструкции if будет истинно. В этом случае команда echo выведет сообщение на экран.

Мы рассмотрели пример, когда действие совершается при выполнении условия. Но бывают случаи, когда с помощью условия выбирается одно из двух действий. Именно так работает конструкция if-else. В общем виде она выглядит так:
{line-numbers: true}
```
if УСЛОВИЕ
then
    ДЕЙСТВИЕ_1
else
    ДЕЙСТВИЕ_2
fi
```

Запись if-else в одну строку выглядит так:
{line-numbers: false}
```
if УСЛОВИЕ; then ДЕЙСТВИЕ_1; else ДЕЙСТВИЕ_2; fi
```

В этой конструкции блок команд ДЕЙСТВИЕ_2 выполнится, если УСЛОВИЕ вернёт код ошибки отличный от нуля. В противном случае выполнится блок ДЕЙСТВИЕ_1.

Конструкцию if-else можно дополнить условиями и действиями с помощью блоков elif. Рассмотрим пример. Предположим, в зависимости от значения переменной вы выбираете одно из трёх действий. Следующая конструкция if даст такое поведение:
{line-numbers: true}
```
if УСЛОВИЕ_1
then
    ДЕЙСТВИЕ_1
elif УСЛОВИЕ_2
then
    ДЕЙСТВИЕ_2
else
    ДЕЙСТВИЕ_3
fi
```

Количество блоков elif неограниченно. Добавляйте их в конструкцию if-else столько, сколько вам нужно.

Дополним наш пример сравнения двух файлов. Будем выводить сообщение не только при их совпадении, но и при их различии. Для этого воспользуемся конструкцией if-else. Получится следующее:
{line-numbers: true, format: Bash}
```
if cmp file1.txt file2.txt &> /dev/null
then
    echo "Файлы file1.txt и file2.txt идентичны"
else
    echo "Файлы file1.txt и file2.txt различаются"
fi
```

Вернёмся к нашему скрипту резервного копирования. В нём в зависимости от результата утилиты bsdtar выполняется блок команд. Поэтому операторы && и || стоит заменить на конструкцию if.

Перепишем вызов и обработку результата bsdtar. Для этого применим конструкцию if-else. Получится следующее:
{line-numbers: true, format: Bash}
```
if bsdtar -cjf "$1".tar.bz2 "$@"
then
    echo "bsdtar - OK" > results.txt
else
    echo "bsdtar - FAILS" > results.txt
    exit 1
fi
```

Согласитесь, что теперь читать и редактировать код стало проще. Его можно упростить ещё. Применим технику [**раннего возврата**](https://habr.com/ru/post/348074/) и заменим конструкцию if-else на if:
{line-numbers: true, format: Bash}
```
if ! bsdtar -cjf "$1".tar.bz2 "$@"
then
    echo "bsdtar - FAILS" > results.txt
    exit 1
fi

echo "bsdtar - OK" > results.txt
```

Поведение кода осталось таким же. С помощью логического отрицания ! мы инвертировали результат утилиты bsdtar. Теперь если она завершится с ошибкой, условие оператора if станет истинным. В этом случае выводится сообщение "bsdtar - FAILS" и вызывается команда exit. Если утилита bsdtar отработает корректно, блок команд конструкции if не выполнится. В результате в лог-файл напечатается строка "bsdtar - OK".

Рассмотрим технику раннего возврата. Это полезный приём, который сделает ваш код проще и понятнее для чтения. Его идея в том, чтобы в случае ошибки завершить программу как можно раньше. Если этого не сделать, вам не избежать **вложенных конструкций if**.

Рассмотрим пример. Представьте, что некоторый алгоритм состоит из пяти действий. Каждое последующее действие выполняется только при успешном завершении предыдущего. Этот алгоритм можно реализовать с помощью вложенных конструкций if. Например, так:
{line-numbers: true}
```
if ДЕЙСТВИЕ_1
then
    if ДЕЙСТВИЕ_2
    then
        if ДЕЙСТВИЕ_3
        then
            if ДЕЙСТВИЕ_4
            then
                ДЕЙСТВИЕ_5
            fi
        fi
    fi
fi
```

Такое вложение выглядит запутанным. Добавьте в него блоки else с обработкой ошибок и читать код станет ещё сложнее.

Вложенные операторы if — это серьёзная проблема для читаемости кода. Она решается техникой раннего возврата. Применим её для нашего алгоритма. Получим следующее:
{line-numbers: true}
```
if ! ДЕЙСТВИЕ_1
then
    # обработка ошибки
fi

if ! ДЕЙСТВИЕ_2
then
    # обработка ошибки
fi

if ! ДЕЙСТВИЕ_3
then
    # обработка ошибки
fi

if ! ДЕЙСТВИЕ_4
then
    # обработка ошибки
fi

ДЕЙСТВИЕ_5
```

Поведение программы не изменилось. Алгоритм по-прежнему состоит из пяти действий. Ошибка при выполнении любого из них прерывает работу программы. Но благодаря раннему возврату, код стал проще и понятнее.

В последнем примере мы впервые использовали [**комментарии**](https://ru.wikipedia.org/wiki/Комментарии_(программирование)). Они выглядят так: "# обработка ошибки". Комментарий — это строка или её часть, которую игнорирует интерпретатор. В Bash комментарием является всё, что идёт после символа решётка #.

Польза комментариев — это предмет бесконечных споров в сообществе программистов. Они нужны для пояснений к коду. Однако, некоторые считают, что наличие комментариев — это признак непонятного, плохо написанного кода. Если вы только начинаете изучать программирование, обязательно используйте их. Комментируйте сложные конструкции в своих скриптах, смысл которых вы можете забыть. В будущем это поможет вспомнить, как эти конструкции работают.

Предположим, что каждому действию алгоритма соответствует одна короткая команда. Все ошибки обрабатываются командой exit без вывода в лог-файл. В этом случае конструкции if можно заменить на оператор ||. При этом код останется простым и понятным. Он будет выглядеть, например, так:
{line-numbers: true}
```
ДЕЙСТВИЕ_1 || exit 1
ДЕЙСТВИЕ_2 || exit 1
ДЕЙСТВИЕ_3 || exit 1
ДЕЙСТВИЕ_4 || exit 1
ДЕЙСТВИЕ_5
```

Операторы && и || выразительнее чем if только тогда, когда действия и обработка ошибок выполняются короткими командами.

Перепишем скрипт резервного копирования с использованием конструкции if. Листинг 3-11 демонстрирует результат.

{caption: "Листинг 3-11. Скрипт с ранним возвратом", line-numbers: true, format: Bash}
![`make-backup-if.sh`](code/BashScripting/make-backup-if.sh)

В скрипте мы заменили операторы && и || в вызове bsdtar на конструкцию if. Поведение скрипта при этом не изменилось.

В общем случае логические операторы и конструкция if не эквивалентны. Рассмотрим пример. Предположим, есть выражение из трёх команд A, B и C:
{line-numbers: false}
```
A && B || C
```

Может показаться, что следующая конструкция if-else даст такое же поведение:
{line-numbers: false}
```
if A
then
    B
else
    C
fi
```

В этой конструкции если A истинно, то выполняется B. Иначе выполняется C. Но в выражении с операторами && и || поведение иное! В нём если A истинно, выполняется B. Далее выполнение C зависит от результата B. Если B истинно, C выполняться не будет. Если же B ложно, C исполнится. Таким образом исполнение C зависит и от результата A, и от результата B. В конструкции if-else такой зависимости нет.

{caption: "Упражнение 3-4. Использование оператора if", format: text, line-numbers: false}
```
Нам дана Bash команда. Она ищет строку "123" в файлах каталога с именем target. Если в файле встречается строка, он копируется в текущий каталога. Если строки в файле нет, он удаляется из каталога target.

Команда выглядит следующим образом:
( grep -RlZ "123" target | xargs -0 cp -t . && echo "cp - OK" || ! echo "cp - FAILS" ) && ( grep -RLZ "123" target | xargs -0 rm && echo "rm - OK" || echo "rm - FAILS" )

Сделайте из этой команды скрипт. Замените операторы && и || на конструкции if-else.
```

### Оператор [[

Мы познакомились с оператором `if`. В качестве условия в нём вызывается встроенная команда Bash или сторонняя утилита. Мы уже знаем, как работать с файловой системой. Поэтому способ комбинации `if`, например, с командой `grep` достаточно очевиден.

При вызове утилиты `grep` в качестве условия конструкции `if` используйте параметр `-q`. Благодаря ему, `grep` не будет ничего выводить в stdout, а вместо этого вернёт код 0 при первом вхождении искомой строки или шаблона. Например:
{line-numbers: true, format: Bash}
```
if grep -q -R "General Public License" /usr/share/doc/bash
then
    echo "Bash распространяется под лицензией GPL"
fi
```

Но что делать, если нам требуется проверять условия не связанные с файловой системой, а, например, сравнивать строки или числа? Для работы со строками в Bash есть специальный оператор `[[`. Двойные квадратные скобки являются [**зарезервированным словом**](https://ru.wikipedia.org/wiki/Зарезервированное_слово) интерпретатора.

W> Оператора `[[` нет в Bourne shell. Если в вашем случае важна POSIX-совместимость, вам придётся воспользоваться устаревшим оператором [`test`](http://mywiki.wooledge.org/BashFAQ/031) или его синонимом `[`. Никогда не используйте его в Bash! Возможности `test` по сравнению с `[[` ограничены, а правильные способы применения неочевидны.

Начнём с простого примера использования `[[`. Предположим, что нам надо сравнить две строки. В этом случае условие `if` будет выглядеть следующим образом:
{line-numbers: true, format: Bash}
```
if [[ "abc" = "abc" ]]
then
    echo "Строки равны"
fi
```

Выполнив этот код, вы увидите сообщение, что строки равны. Подобная проверка не слишком полезна. Обычно приходится сравнивать значение какой-то переменной со строкой. В этом случае оператор `[[` будет выглядеть так:
{line-numbers: true, format: Bash}
```
if [[ "$var" = "abc" ]]
then
    echo "Переменная равна строке abc"
fi
```

В рассмотренных нами примерах двойные кавычки необязательны. При подстановке переменной в выражение `[[` globbing и world splitting не выполняются. То есть интерпретатор не пытается самостоятельно обработать значение `var`, а использует его как есть. Ошибка может произойти, если в строке, с которой сравнивается переменная, встречаются пробелы. Например, в следующем случае:
{line-numbers: true, format: Bash}
```
if [[ "$var" = abc def ]]
then
    echo "Переменная равна строке abc def"
fi
```

Чтобы избежать подобных ошибок при работе со строками лучше всегда использовать кавычки:
{line-numbers: true, format: Bash}
```
if [[ "$var" = "abc def" ]]
then
    echo "Переменная равна строке abc def"
fi
```

Вы также можно сравнивать значения двух переменных друг с другом. Например так:
{line-numbers: true, format: Bash}
```
if [[ "$var" = "$filename" ]]
then
    echo "Переменные равны"
fi
```

В таблице 3-8 приведены все операции сравнения строк, допустимые в операторе `[[`.

{caption: "Таблица 3-8. Операции сравнения строк `[[`", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| > | Строка больше в порядке [**лексикографической сортировки**](https://ru.wikipedia.org/wiki/Лексикографический_порядок). | [[ "bb" > "aa" ]] && echo "Строка bb больше чем aa" |
|  | | |
| < | Строка меньше в порядке лексикографической сортировки. | [[ "ab" < "ac" ]] && echo "Строка ab меньше чем ac" |
|  | | |
| = или == | Строки равны. | [[ "abc" = "abc" ]] && echo "Строки равны" |
|  | | |
| != | Строки не равны. | [[ "abc" != "ab" ]] && echo "Строки не равны" |
|  | | |
| -z | Строка пустая. | [[ -z "$var" ]] && echo "Строка пустая" |
|  | | |
| -n | Строка не пустая. | [[ -n "$var" ]] && echo "Строка не пустая" |
|  | | |
| = или == | Поиск подстроки по шаблону. В этом случае шаблон не заключается в кавычки. | [[ "$filename" = READ* ]] && echo "Имя файла начинается с READ" |
|  | | |
| != | Проверка, что шаблон не встречается в строке. В этом случае шаблон не заключается в кавычки. | [[ "$filename" != READ* ]] && echo "Имя файла не начинается с READ" |
|  | | |
| =~ | Поиск подстроки по [**регулярному выражению**](https://www.opennet.ru/docs/RUS/bash_scripting_guide/c11895.html). | [[ "$filename" =~ ^READ.* ]] && echo "Имя файла начинается с READ" |

Для построения выражений с несколькими условиями в операторе `[[` вы можете воспользоваться логическими операциями, приведёнными в таблице 3-9.

{caption: "Таблица 3-9. Логические операции `[[`", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| && | Логическое И. | [[ -n "$var" && "$var" < "abc" ]] && echo "Строка не пустая и меньше чем abc" |
| \|\| | Логическое ИЛИ. | [[ "abc" < "$var" \|\| -z "$var" ]] && echo "Строка больше чем abс или пустая" |
| ! | Логическое НЕ. | [[ ! "abc" < "$var" ]] && echo "Строка не больше чем abc" |

Выражения в операторе `[[` можно группировать с помощью круглых скобок. Например, следующим образом:
{line-numbers: false, format: Bash}
```
[[ (-n "$var" && "$var" < "abc") || -z "$var" ]] && echo "Строка не пустая и меньше чем abc или строка пустая"
```

Кроме сравнения строк, оператор `[[` позволяет проверять файлы на различные условия. Наиболее часто используемые из них приведены в таблице 3-10.

{caption: "Таблица 3-10. Операции проверки файлов `[[`", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| -e | Файл существует. | [[ -e "$filename" ]] && echo "Файл $filename существует" |
|  | | |
| -f | Проверяемый объект является обычным файлом (не каталогом и не [**файлом устройства**](https://ru.wikipedia.org/wiki/Специальный_файл_устройства)). | [[ -f "~/README.txt" ]] && echo "README.txt - это обычный файл" |
|  | | |
| -d | Проверяемый объект является каталогом. | [[ -f "/usr/bin" ]] && echo "/usr/bin - это каталог" |
|  | | |
| -s | Файл не пустой. | [[ -s "$filename" ]] && echo "Файл $filename не пустой" |
|  | | |
| -r | Файл существует и доступен для чтения пользователю, запустившему скрипт. | [[ -r "$filename" ]] && echo "Файл $filename существует и доступен для чтения" |
|  | | |
| -w | Файл существует и доступен для записи пользователю, запустившему скрипт. | [[ -w "$filename" ]] && echo "Файл $filename существует и доступен для записи" |
|  | | |
| -x | Файл существует и доступен для исполнения пользователю, запустившему скрипт. | [[ -x "$filename" ]] && echo "Файл $filename существует и доступен для исполнения" |
|  | | |
| -N | Файл существует и был модифицирован с момента последнего чтения. | [[ -N "$filename" ]] && echo "Файл $filename существует и был модифицирован" |
|  | | |
| -nt | Файл слева от оператора новее, чем файл справа. Либо файл слева существует, а справа - нет. | [[ "$file1" -nt "$file2" ]] && echo "Файл $file1 новее чем $file2" |
|  | | |
| -ot | Файл слева от оператора старее, чем файл справа. Либо файл справа существует, а слева - нет. | [[ "$file1" -ot "$file2" ]] && echo "Файл $file1 старее чем $file2" |
|  | | |
| -ef | Слева и справа от оператора указан путь до одного и того же существующего файла. Если ваша система поддерживает **жёсткие ссылки**, то ссылки слева и справа от оператора указывают на один и тот же файл. | [[ "$file1" -ef "$file2" ]] && echo "Файлы $file1 и $file2 совпадают" |

Оператор `[[` позволяет сравнивать не только строки, но и целые числа. Таблица 3-11 демонстрирует соответствующие операции.

{caption: "Таблица 3-11. Операции сравнения целых чисел `[[`", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| -eq | Равно. | [[ "$var" -eq 5 ]] && echo "Переменная равна 5" |
| -ne | Не равно. | [[ "$var" -ne 5 ]] && echo "Переменная не равна 5" |
| -gt | Больше (>). | [[ "$var" -gt 5 ]] && echo "Переменная больше 5" |
| -ge | Больше или равно. | [[ "$var" -ge 5 ]] && echo "Переменная больше или равна 5" |
| -lt | Меньше (<). | [[ "$var" -lt 5 ]] && echo "Переменная меньше 5" |
| -le | Меньше или равно. | [[ "$var" -le 5 ]] && echo "Переменная меньше или равна 5" |

Таблица 3-11 вызывает вопросы. Очевидно, что запоминать операции сравнения чисел неудобно. Почему вместо двухбуквенных сокращений нельзя использовать привычные знаки сравнения (`<`, `>` и `=`)? Перед тем как ответить на этот вопрос, обратимся к истории оператора `[[`.

Как было замечено ранее, оператор `[[` появился в Bash на замену устаревшего `test`. В первой версии Bourne shell 1979 года `test` был сторонней утилитой. Только начиная с версии System III shell 1981 года, он стал встроенной командой интерпретатора. Но это изменение не затронуло синтаксис `test`. Дело в том, что к этому времени было написано достаточно кода и новая версия интерпретатора должна была его поддерживать.

Работа с `test` в качестве внешней утилиты накладывает ограничения. Прежде всего они связаны с входными параметрами. Рассмотрим типичный вызов `test` для сравнения значения переменной `var` с числом:
{line-numbers: false, format: Bash}
```
test "$var" -eq 5
```

Эта команда не вызывает вопросов. В утилиту `test` передаются три разделённые пробелами параметра: значение переменной `var`, ключ `-eq` и число 5. Если мы скомбинируем этот вызов с конструкцией `if`, получим следующее:
{line-numbers: true, format: Bash}
```
if test "$var" -eq 5
then
    echo "Переменная равна 5"
fi
```

В Bourne shell был введён синоним `[` для `test`. Единственное отличие между ними — это требование закрывающей скобки `]`, которая не нужна для `test`. С помощью синонима мы можем переписать наше выражение `if` так:
{line-numbers: true, format: Bash}
```
if [ "$var" -eq 5 ]
then
    echo "Переменная равна 5"
fi
```

Синоним `[` ввели для лучшей читаемости кода. Благодаря ему, конструкция `if` в Bourne shell стала больше походить на свои аналоги из других языков программирования (например C). Проблема в том, что скобки и выражение в них эквивалентно вызову `test`. Этот факт легко упустить из виду, особенно имея опыт программирования на других языках. Такое несоответствие ожидаемого поведения (конструкция языка) и реального (вызов `test`) является источником большинства ошибок, связанных с использованием оператора `[`.

Например, часто встречается ошибка, когда между `[` и следующим далее символом не ставится пробел:
{line-numbers: true, format: Bash}
```
if ["$var" -eq 5]
then
    echo "Переменная равна 5"
fi
```

Просто замените скобку на `test` и ошибки сразу станет очевидна:
{line-numbers: true, format: Bash}
```
if test"$var" -eq 5
then
    echo "Переменная равна 5"
fi
```

Между именем команды и её параметрами всегда должен стоять пробел.

Вернёмся к нашему исходному вопросу касательно знаков сравнения для чисел. Представьте себе следующий вызов `test`:
{line-numbers: false, format: Bash}
```
test "$var" > 5
```

Как вы помните, символ `>` является сокращением для перенаправления стандартного потока вывода `1>`. Поэтому команда выше выполнит следующие шаги:

1. Вызовет встроенную команду `test` и передаст ей на вход переменную `var`.

2. Перенаправит вывод `test` в файл с именем `5` в текущем каталоге.

Это совсем не то поведение, которое мы ожидали. Подобную ошибку легко совершить и крайне сложно обнаружить. Чтобы её избежать и были введены двухбуквенные операции для сравнения чисел. Эти операции перекочевали в новый оператор `[[` Bash. По идее, ничто не мешало заменить их на знаки сравнения. Но такое решение усложнило бы портирование старого кода с Bourne shell на Bash. Рассмотрим пример.

Представьте, что у вас есть следующая конструкция `if`:
{line-numbers: true, format: Bash}
```
if [ "$var1" -gt 5 -o 4 -lt "$var2" ]
then
    echo "Переменная var1 больше 5 или var2 больше 4"
fi
```

Намного безопаснее поставить по дополнительной скобке в начале и в конце выражения, чем менять `-gt` на `>`, а `-lt` на `<`. При таких заменах легко допустить ошибку.

В случае сравнения строк задачи обеспечить обратную совместимость не стояло. Первоначальная утилита `test` вообще не поддерживала знаков `<` и `>`. Такая поддержка появилась для строк, но только в расширении POSIX-стандарта. Там знаки сравнения приходилось экранировать `/<` и `/>`. Из стандарта они были портированы в оператор `[[`, но уже без экранирования.

{caption: "Упражнение 3-5. Использование оператора `[[`", format: text, line-numbers: false}
```
Напишите скрипт для сравнения двух каталогов с именами dir1 и dir2. На экран должны выводится все файлы, которые есть в одном каталоге, но отсутствуют в другом.
```

### Оператор case

В программировании часто требуется выполнить определённый код в зависимости от какого-либо значения. Именно эту задачу решают условные конструкции. Мы уже познакомились с оператором `if`. Ещё в Bash есть условная конструкция `case`. В некоторых случаях использовать её удобнее чем `if`.

Рассмотрим пример. Предположим, что вы пишете скрипт, который должен архивировать ваши документы. У него есть три режима работы: архивация со сжатием, архивация без сжатия и разархивация. Нужное действие выбирается с помощью опции скрипта. В таблице 3-12 приведён возможный вариант соответствия опций и режимов.

{caption: "Таблица 3-12. Опции скрипта архивации", width: "50%"}
| Опция | Режим работы |
| --- | --- |
| `-a` | Архивация без сжатия |
| `-c` | Архивация со сжатием |
| `-x` | Разархивация |

I> В своих скриптах старайтесь всегда следовать [POSIX-соглашению](https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html) и [GNU-расширению](https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html) к нему о формате опций и параметров утилит командной строки.

Значение переданной в скрипт опции можно проверить в конструкции `if`. Например так, как демонстрирует листинг 3-12.

{caption: "Листинг 3-12. Скрипт архивации документов", line-numbers: true, format: Bash}
![`archiving.sh`](code/BashScripting/archiving.sh)

Позиционный параметр `$1` присваивается переменной `operation` для удобства. Дальше в зависимости от её значения вызывается утилита `bsdtar` с теми или иными параметрами. Такое же поведение можно добиться с помощью конструкции `case`.

Листинг 3-13 демонстрирует скрипт `archiving-case.sh` для архивации, переписанный с использованием `case`.

{caption: "Листинг 3-13. Скрипт архивации документов", line-numbers: true, format: Bash}
![`archiving-case.sh`](code/BashScripting/archiving-case.sh)

Выполнить скрипт можно одним из следующих способов:
{line-numbers: true, format: Bash}
```
./archiving-case.sh -a
./archiving-case.sh -b
./archiving-case.sh -x
```

Передача в скрипт любых других параметров приведёт к выводу сообщения об ошибке и завершению с кодом возврата равным единице.

W> Не забывайте вызывать встроенную команду `exit` с ненулевым параметром при обработке ошибок в ваших скриптах.

В общем случае конструкция `case` позволяет сравнить переданную в неё строку со списком шаблонов. В зависимости от совпадения с шаблоном выбирается один из блоков `case`. Каждый такой блок состоит из следующих элементов:

1. Шаблон или список шаблонов, разделённых символом `|`.

2. Правая скобка `)`.

3. Набор команд, которые выполняются при совпадении шаблона и переданной в `case` строки.

4. Два знака точка с запятой `;;`, которые означают окончание набора команд.

Проверка шаблонов происходит последовательно. Если переданная в конструкцию `case` строка соответствует нескольким шаблонам, будет выбран первый из списка.

Шаблон `*` без кавычек соответствует любой строке. Обычно он используется в конце списка, чтобы обработать случай, когда ни один из шаблонов не подошёл. Как правило, это означает ошибку.

На первый взгляд может показаться, что рассмотренные нами конструкции `if` и `case` эквивалентны. Но это не так. Они всего лишь позволяют добиться одинакового поведения.

Для удобства дальнейшего рассмотрения, запишем конструкции `if` и `case` из нашего примера в общем виде. Вариант с `if` будет выглядеть следующим образом:
{line-numbers: true}
```
if УСЛОВИЕ_1
then
    ДЕЙСТВИЕ_1
elif УСЛОВИЕ_2
then
    ДЕЙСТВИЕ_2
elif УСЛОВИЕ_3
then
    ДЕЙСТВИЕ_3
else
    ДЕЙСТВИЕ_4
fi
```

Вариант с `case` выглядит так:
{line-numbers: true}
```
case СТРОКА in
    ШАБЛОН_1)
        ДЕЙСТВИЕ_1
        ;;

    ШАБЛОН_2)
        ДЕЙСТВИЕ_2
        ;;

    ШАБЛОН_3)
        ДЕЙСТВИЕ_3
        ;;

    ШАБЛОН_4)
        ДЕЙСТВИЕ_4
        ;;
esac
```

Благодаря записи конструкций в общем виде стали очевидны их различия. Прежде всего, `if` проверяет результаты вычислений логических выражений. В отличие от этого конструкция `case` сравнивает значение переданной в неё строки с несколькими шаблонами.

Ещё раз обратите внимание на этот момент. Передавать в `case` логическое выражение нет никакого смысла. Это позволит вам обработать только два случая: когда выражение истинно и когда — ложно. Конструкция `if` намного удобнее для такой проверки.

Второе различие `if` и `case` заключается в количестве условий. В `if` каждая ветвь конструкции (`if`, `elif` и `else`) проверяет новое логическое выражение. В общем случае эти выражения никак не связаны. В нашем примере они проверяют значения одной и той же переменной, но это частный случай. Конструкция `case` работает с одной-единственной переданной в неё строкой.

Операторы `if` и `case` принципиально отличаются. Они не взаимозаменяемы. В каждом конкретном случае следует использовать ту или иную конструкцию в зависимости от характера проверки. Следующие вопросы помогут вам сделать правильный выбор:

* Сколько условий надо проверить?

* Требуются ли составные логические выражения или достаточно сравнения одной строки?

Блоки `case` можно отделять друг от друга двумя знаками точка с запятой `;;` или точкой с запятой и амперсандом `;&`. Синтаксис с амперсандом допустим в Bash, но не является частью POSIX-стандарта. Он позволяет исполнить команды следующего блока `case`. Это может быть полезно, если требуется начать выполнение алгоритма с определённого шага в зависимости от какого-то условия. Также синтаксис с амперсандом позволяет избежать дублирования кода.

Рассмотрим пример. Напишем скрипт, который выполняет архивацию PDF документов пользователя и копирует полученный файл в специальный каталог. Для выбора действия в скрипт передаётся опция (например, `-a` для архивации и `-c` для копирования). Допустим, что для удобства копирование надо выполнять всегда после архивации. В этом случае возникнет дублирование кода.

Листинг 3-14 демонстрирует конструкцию `case`, в которой команда копирования файла архива дублируется.

{caption: "Листинг 3-14. Скрипт архивации и копирования PDF документов", line-numbers: true, format: Bash}
![`copy-archiving-duplication.sh`](code/BashScripting/copy-archiving-duplication.sh)

Если между блоками обработки опций `-a` и `-c` поставить разделитель `;&`, дублирования кода удастся избежать. Исправленный скрипт приведён в листинге 3-15.

{caption: "Листинг 3-15. Скрипт копирования и архивации PDF документов", line-numbers: true, format: Bash}
![`copy-archiving.sh`](code/BashScripting/copy-archiving.sh)

Разделитель `;&` может быть полезным, но несмотря на это постарайтесь использовать его только в случае крайней необходимости. Проблема в том, что визуально его легко спутать с разделителем `;;` и неправильно прочитать код.

### Альтернатива оператору case

Задача, решаемая конструкцией `case`, близка задаче, решаемой ассоциативными массивами. Массивы устанавливают соответствие между данными (ключ-значение), а конструкция `case` между данными и командами (значение-действие). Как правило, оперировать данными намного удобнее чем кодом. Их проще изменять и контролировать их корректность. Поэтому в некоторых случаях имеет смысл заменять конструкцию `case` на ассоциативный массив. По сравнению с другими языками программирования в Bash очень просто конвертировать данные в команды.

Рассмотрим пример. Напишем скрипт-обёртку для утилит архивации. В зависимости от переданной в скрипт опции будет вызвана либо программа `bsdtar`, либо `tar`. Листинг 3-16 демонстрирует реализацию такого скрипта с помощью конструкции `case`.

{caption: "Листинг 3-16. Скрипт-обёртка для утилит `bsdtar` и `tar`", line-numbers: true, format: Bash}
![`tar-wrapper.sh`](code/BashScripting/tar-wrapper.sh)

В этом скрипте для первых двух блоков `case` мы использовали список шаблонов. Команды первого блока будут выполнены при совпадении значения переменной `utility` со строкой `-b` или `--bsdtar`. Аналогично вхождение во второй блок произойдёт при совпадении переменной с `-t` или `--tar`.

Скрипт можно запустить, например, следующей командой:
{line-numbers: false, format: Bash}
```
./tar-wrapper.sh --tar -cvf documents.tar.bz2 Documents
```

В этом случае будет вызвана утилита `tar`. Для работы с `bsdtar` достаточно заменить опцию `--tar` на `-b` или `--bsdtar`:
{line-numbers: false, format: Bash}
```
./tar-wrapper.sh -b -cvf documents.tar.bz2 Documents
```

Для передачи аргументов утилите архивации мы используем специальный параметр `$@`. Он не является массивом, но поддерживает синтаксис, соответствующий подстановке нескольких следующих подряд элементов массива. В нашем случае мы указываем подстановку всех элементов начиная со второго.

Перепишем наш скрипт-обёртку с помощью ассоциативного массива. Прежде всего разберёмся в механизмах Bash для конвертации данных в команды. Суть такой конвертации заключается в том, чтобы сохранить команду и её параметры в качестве значения какой-либо переменной. Затем это значение должно быть обработано интерпретатором не как данные, а как команда.

Выполним рассмотренный алгоритм конвертации по шагам в командном интерпретаторе Bash. Сначала объявим переменную, значение которой соответствует команде вызова утилиты `ls`:
{line-numbers: false, format: Bash}
```
ls_command="ls"
```

Теперь передадим значение этой переменной интерпретатору в качестве команды:
{line-numbers: false, format: Bash}
```
$ls_command
```

В результате выполнения на экран будет выведено содержимое текущего каталога. Что произошло? Bash выполнил подстановку параметра, после которой команда стала выглядеть так:
{line-numbers: false, format: Bash}
```
ls
```

После подстановки Bash просто исполнил получившуюся команду.

Может возникнуть вопрос: почему в примере не используются двойные кавычки `"` при подстановке переменной `ls_command`? Чтобы ответить на него, добавим опцию для утилиты `ls`. Например, следующим образом:
{line-numbers: false, format: Bash}
```
ls_command="ls -l"
```

Теперь подстановка с двойными кавычками приведёт к ошибке:
{line-numbers: true, format: Bash}
```
$ "$ls_command"
ls -l: command not found
```

Проблема заключается в том, что двойные кавычки предотвращают word splitting. В результате после подстановки получится следующая команда:
{line-numbers: false, format: Bash}
```
"ls -l"
```

Другими словами Bash должен выполнить команду или утилиту с именем `ls -l` (ls пробел минус l), вызванную без параметров. Как вы помните, POSIX-стандарт допускает пробелы в именах файлов. Поэтому `ls -l` является корректным именем исполняемого файла.

Мы столкнулись с одним из редких случаев, когда подстановка переменных должна выполняться без использования двойных кавычек.

Проблему использования двойных кавычек при выполнении значения переменной можно решить встроенной командой интерпретатора `eval`. `eval` формирует команду для исполнения из полученных аргументов. При этом word splitting выполняется независимо от наличия двойных кавычек.

Применим `eval` для выполнения значения переменной `ls_command` следующим образом:
{line-numbers: false, format: Bash}
```
eval "$ls_command"
```

W> Во многих руководствах по Bash вы можете найти информацию о том, что обработка значений переменных в качестве команд и использование команды `eval` — это плохая практика. В общем случае это так. Использование `eval` может привести к серьёзным ошибкам и уязвимостям. Будьте осторожны при её использовании и никогда не передавайте в `eval` необработанные данные, введённые пользователем.

Теперь мы готовы переписать скрипт-обёртку над утилитой архивации с использованием ассоциативного массива. Листинг 3-17 демонстрирует результат.

{caption: "Листинг 3-17. Скрипт-обёртка для утилит `bsdtar` и `tar`", line-numbers: true, format: Bash}
![`tar-wrapper-array.sh`](code/BashScripting/tar-wrapper-array.sh)

Для обработки некорректных параметров скрипта нам понадобилась конструкция `if`. В ней вычисляются два логических выражения:

1. Проверка, что позиционный параметр `$1` (сохранённый в переменной `option`) не пустой.

2. Проверка, что в ассоциативном массиве `utils` существует элемент, соответствующий позиционному параметру `$1`. 

Во втором выражении мы использовали опцию `-v` оператора `[[`. В этом случае возвращается истина, если переменная была объявлена (при этом она может быть равна пустой строке).

Пример со скриптом-обёрткой продемонстрировал, что использование ассоциативного массива вместо конструкции `case` позволяет писать более компактный и удобный для чтения код. Поэтому всегда рассматривайте возможность такой замены в своих программах.

{caption: "Упражнение 3-6. Использование `case`", format: text, line-numbers: false}
```
Предположим, что в домашнем каталоге пользователя есть два конфигурационных файла: .bashrc-home и .bashrc-work. Напишите скрипт для переключения между ними.
Эта задача может решаться копированием соответствующего файла по пути ~/.bashrc или созданием символьной ссылки.
После решения задачи с помощью конструкции case попробуйте реализовать вариант с ассоциативным массивом.
```
## Условные операторы

Условные конструкции знакомы нам из опыта работы с утилитой `find`. В языке Bash есть собственные логические операторы `&&` и `||`. Кроме них есть и другие формы ветвления, каждая из которых предназначена для определённой цели. Рассмотрим инструкции `if` и `case`, которые часто оказываются полезны при разработке скриптов.

### Оператор if

Когда мы пишем однострочную команду и скрипт, то руководствуемся разными требованиями. В первом случае важна компактность. Согласитесь, что короткую команду проще набирать и шанс допустить ошибку меньше. В случае скриптов, важнее наглядность и удобство чтения.

Операторы `&&` и `||` хорошо подходят для однострочных команд. Но когда речь заходит о скриптах, у них появляются более удобные альтернативы. На самом деле всё зависит от конкретного случая. Иногда `&&` и `||` отлично вписываются в код скрипта, а иногда их следует заменить на более удобные конструкции. Рассмотрим эти случаи подробнее.

Ещё раз обратимся к нашему скрипту для резервного копирования из листинга 3-9. Его вторая строка выглядит следующим образом:
{line-numbers: false, format: Bash}
```
bsdtar -cjf "$1".tar.bz2 "$@" && echo "bsdtar - OK" > results.txt || { echo "bsdtar - FAILS" > results.txt ; exit 1 ; }
```

Мы разбили вызовы утилит `bsdtar` и `mv` на две отдельные команды. Это помогло, но лишь отчасти. Вызов `bsdtar` всё ещё слишком длинный, из-за чего его неудобно читать и изменять. Это верный сигнал о том, что при его написании было принято неверное техническое решение.

Распишем алгоритм вызова `bsdtar` по шагам:

1. Выполнить архивирование и сжатие всех файлов и каталогов из переменной `$@`.

2. Если команда завершилась успешно, записать в лог-файл строку "bsdtar - OK".

3. Если при работе `bsdtar` произошла ошибка, записать в лог-файл строку "bsdtar - FAILS" и завершить работу скрипта.

Вопросы вызывает третий пункт. Обратите внимание, что при успешном завершении `bsdtar` выполняется только одно действие. В случае же ошибки — действий два и они объединены в [**блок команд**](https://ru.wikipedia.org/wiki/Блок_(программирование)) с помощью [фигурных скобок](https://www.gnu.org/software/bash/manual/html_node/Command-Grouping.html). 

Конструкция `if` была введена как раз для удобства работы с блоками команд. В общем случае она выглядит следующим образом:
{line-numbers: true}
```
if УСЛОВИЕ
then
    ДЕЙСТВИЕ
fi
```

Если требуется записать `if` в одну строку, после `if УСЛОВИЕ` и `then ДЕЙСТВИЕ` следует поставить точки с запятой:
{line-numbers: false}
```
if УСЛОВИЕ; then ДЕЙСТВИЕ; fi
```

УСЛОВИЕ и ДЕЙСТВИЕ в операторе `if` представляют собой команду или блок команд. Если УСЛОВИЕ завершилось успешно с кодом 0, будут выполнены команды, соответствующие ДЕЙСТВИЮ.

Рассмотрим простой пример:
{line-numbers: true, format: Bash}
```
if cmp file1.txt file2.txt &> /dev/null
then
    echo "Файлы file1.txt и file2.txt идентичны"
fi
```

В качестве УСЛОВИЯ мы вызываем утилиту `cmp`. Она побайтово сравнивает содержимое двух файлов, переданных на вход. Если они отличаются, `cmp` печатает в стандартный поток вывода позицию первого различающегося символа. В данном случае нас интересует только код возврата утилиты. Поэтому мы перенаправляем её вывод в файл [`/dev/null`](https://ru.wikipedia.org/wiki//dev/null). Запись в `dev/null` всегда происходит успешно, а все записанные данные удаляются.

Итак, если файлы `file1.txt` и `file2.txt` имеют одинаковое содержимое, команда `echo` выведет соответствующее сообщение на экран.

Если в случае невыполнения условия требуется выполнить какие-то действия, воспользуйтесь конструкцией `if-else`:
{line-numbers: true}
```
if УСЛОВИЕ
then
    ДЕЙСТВИЕ 1
else
    ДЕЙСТВИЕ 2
fi
```

Запись `if-else` в одну строку выглядит так:
{line-numbers: false}
```
if УСЛОВИЕ; then ДЕЙСТВИЕ 1; else ДЕЙСТВИЕ 2; fi
```

В этой конструкции блок команд, обозначенный как ДЕЙСТВИЕ 2, будет выполняться, если УСЛОВИЕ вернёт код ошибки отличный от 0. В противном случае исполнится ДЕЙСТВИЕ 1.

Конструкция `if-else` может быть дополнена условиями и действиями с помощью блоков `elif`. Например, представьте себе, что в зависимости от значения переменной вы выбираете одно из трёх действий. В этом случае оператор `if` будет выглядеть так:
{line-numbers: true}
```
if УСЛОВИЕ 1
then
    ДЕЙСТВИЕ 1
elif УСЛОВИЕ 2
then
    ДЕЙСТВИЕ 2
else
    ДЕЙСТВИЕ 3
fi
```

Обратите внимание, что допустимое количество блоков `elif` не ограничено.

Воспользуемся конструкцией `if-else`, чтобы добавить в наш пример сравнения файлов вывод сообщения об их различии:
{line-numbers: true, format: Bash}
```
if cmp file1.txt file2.txt &> /dev/null
then
    echo "Файлы file1.txt и file2.txt идентичны"
else
    echo "Файлы file1.txt и file2.txt различаются"
fi
```

Вернёмся к нашему скрипту резервного копирования. Как мы выяснили, если при выполнении кого-то условия следует выполнить блок команд, предпочтительнее использовать конструкцию `if`, а не операторы `&&` и `||`. В нашем случае блок команд включает вывод сообщения об ошибке в лог-файл и вызов `exit`.

Перепишем вызов `bsdtar` с использованием `if`:
{line-numbers: true, format: Bash}
```
if bsdtar -cjf "$1".tar.bz2 "$@"
then
    echo "bsdtar - OK" > results.txt
else
    echo "bsdtar - FAILS" > results.txt
    exit 1
fi
```

Согласитесь, что теперь читать код стало намного удобнее. На самом деле мы можем его упростить. Применим технику [**раннего возврата**](https://habr.com/ru/post/348074/) и заменим конструкцию `if-else` на `if`:
{line-numbers: true, format: Bash}
```
if ! bsdtar -cjf "$1".tar.bz2 "$@"
then
    echo "bsdtar - FAILS" > results.txt
    exit 1
fi

echo "bsdtar - OK" > results.txt
```

Что изменилось? Поведение нашего кода осталось без изменений. С помощью логического отрицания `!` мы инвертируем результат вызова утилиты `bsdtar`. Поэтому если он завершится с ошибкой, условие оператора `if` будет истинным. В этом случае будет выведено сообщение "bsdtar - FAILS" и вызвана команда `exit`. Если утилита `bsdtar` отработает корректно, произойдёт вывод "bsdtar - OK".

Идея техники раннего возврата заключается в том, чтобы в случае ошибки завершить программу как можно раньше. Благодаря этому, мы избегаем многократных вложений операторов `if`. Рассмотрим пример. Представьте, что у нас есть алгоритм состоящий из пяти действий. Каждое последующее должно выполняться только при успешном завершении предыдущего. Мы можем реализовать этот алгоритм с помощью конструкции `if` таким образом:
{line-numbers: true}
```
if ДЕЙСТВИЕ 1
then
    if ДЕЙСТВИЕ 2
    then
        if ДЕЙСТВИЕ 3
        then
            if ДЕЙСТВИЕ 4
            then
                ДЕЙСТВИЕ 5
            fi
        fi
    fi
fi
```

Эта программа выглядит запутанной. Добавьте в неё `else` с выводами сообщений об ошибках для каждого действия и читать её станет ещё сложнее. Ранний возврат решает проблему наглядности вложенных условий. Перепишем наш алгоритм с применением этой техники:
{line-numbers: true}
```
if ! ДЕЙСТВИЕ 1
then
    # обработка ошибки
fi

if ! ДЕЙСТВИЕ 2
then
    # обработка ошибки
fi

if ! ДЕЙСТВИЕ 3
then
    # обработка ошибки
fi

if ! ДЕЙСТВИЕ 4
then
    # обработка ошибки
fi

ДЕЙСТВИЕ 5
```

I> Строка скрипта начинающаяся с символа решётка `#` является [**комментарием**](https://ru.wikipedia.org/wiki/Комментарии_(программирование)). Это значит, что она будет проигнорирована интерпретатором. Комментарии используются для пояснений к коду и объяснения намерений программиста.

Обратите внимание, что применение конструкции `if` в данном случае оправданно, только если обработка ошибки состоит из блока команд. Если же достаточно просто вызова `exit`, предпочтительнее использовать оператор `||`:
{line-numbers: true}
```
ДЕЙСТВИЕ 1 || exit 1
ДЕЙСТВИЕ 2 || exit 1
ДЕЙСТВИЕ 3 || exit 1
ДЕЙСТВИЕ 4 || exit 1
ДЕЙСТВИЕ 5
```

Листинг 3-11 демонстрирует скрипт резервного копирования, переписанный с использованием конструкции `if`.

{caption: "Листинг 3-11. Скрипт с ранним возвратом", line-numbers: true, format: Bash}
![`make-backup-if.sh`](code/BashScripting/make-backup-if.sh)

В нашем скрипте резервного копирования мы можем заменить логические операторы `&&` и `||` на конструкцию `if`, но в общем случае они не эквивалентны. Рассмотрим пример. Предположим, что у нас есть выражение из трёх команд A, B и C:
{line-numbers: false}
```
A && B || C
```

Можно предположить, что следующая конструкция `if-else` даст то же самое поведение:
{line-numbers: false}
```
if A
then
    B
else
    C
fi
```

В этой `if-else` конструкции если A истинно, то выполняется B. Иначе выполняется C.

Но в выражении с логическими операторами `&&` и `||` поведение иное! Если A истинно, выполняется B. Далее выполнение C зависит от результата B. Если B истинно, C выполняться не будет. Если же B ложно, C исполнится. Таким образом исполнение C зависит и от результата A, и от результата B. В конструкции `if-else` такой зависимости нет.

{caption: "Упражнение 3-4. Использование оператора if", format: text, line-numbers: false}
```
Нам дана команда, которая проверяет файлы в каталоге с именем target на наличие в них строки "123". Файлы, в которых она встречается, копируются в текущий каталога. Если строки в файле не обнаружено, он удаляется из каталога target.

Команда выглядит следующим образом:
( grep -RlZ "123" target | xargs -0 cp -t . && echo "cp - OK" || ! echo "cp - FAILS" ) && ( grep -RLZ "123" target | xargs -0 rm && echo "rm - OK" || echo "rm - FAILS" )

Напишите скрипт, в котором логические операторы && и || заменены на конструкции if-else.
```

### Оператор [[

Мы познакомились с оператором `if`. В качестве условия в нём вызывается встроенная команда Bash или сторонняя утилита. Мы уже знаем, как работать с файловой системой. Поэтому способ комбинации `if`, например, с командой `grep` достаточно очевиден.

При вызове утилиты `grep` в качестве условия конструкции `if` используйте параметр `-q`. Благодаря ему, `grep` не будет ничего выводить в stdout, а вместо этого вернёт код 0 при первом вхождении искомой строки или шаблона. Например:
{line-numbers: true, format: Bash}
```
if grep -q -R "General Public License" /usr/share/doc/bash
then
    echo "Bash распространяется под лицензией GPL"
fi
```

Но что делать, если нам требуется проверять условия не связанные с файловой системой, а, например, сравнивать строки или числа? Для работы со строками в Bash есть специальный оператор `[[`. Обратите внимание, что это не внешняя утилита, а [**зарезервированное слово**](https://ru.wikipedia.org/wiki/Зарезервированное_слово) интерпретатора.

W> Оператора `[[` нет в Bourne shell. Если в вашем случае важна POSIX-совместимость, вам придётся воспользоваться устаревшим оператором [`test`](http://mywiki.wooledge.org/BashFAQ/031) или его синонимом `[`. Никогда не используйте его в Bash! Возможности `test` по сравнению с `[[` ограничены, а правильные способы применения неочевидны.

Начнём с простого примера использования `[[`. Предположим, что нам надо сравнить две строки. В этом случае условие `if` будет выглядеть следующим образом:
{line-numbers: true, format: Bash}
```
if [[ "abc" = "abc" ]]
then
    echo "Строки равны"
fi
```

Выполнив этот код, вы увидите сообщение, что строки равны. Подобная проверка не слишком полезна. Обычно приходится сравнивать значение какой-то переменной со строкой. В этом случае оператор `[[` будет выглядеть так:
{line-numbers: true, format: Bash}
```
if [[ "$var" = "abc" ]]
then
    echo "Переменная равна строке abc"
fi
```

В рассмотренных нами примерах двойные кавычки необязательны. При подстановке переменной в выражение `[[` globbing и world splitting не выполняются. То есть интерпретатор не пытается самостоятельно обработать значение `var`, а использует его как есть. Ошибка может произойти, если в строке, с которой сравнивается переменная, встречаются пробелы. Например, в следующем случае:
{line-numbers: true, format: Bash}
```
if [[ "$var" = abc def ]]
then
    echo "Переменная равна строке abc def"
fi
```

Чтобы избежать подобных ошибок при работе со строками лучше всегда использовать кавычки:
{line-numbers: true, format: Bash}
```
if [[ "$var" = "abc def" ]]
then
    echo "Переменная равна строке abc def"
fi
```

Вы также можно сравнивать значения двух переменных друг с другом. Например так:
{line-numbers: true, format: Bash}
```
if [[ "$var" = "$filename" ]]
then
    echo "Переменные равны"
fi
```

В таблице 3-8 приведены все операции сравнения строк, допустимые в операторе `[[`.

{caption: "Таблица 3-8. Операции сравнения строк `[[`", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| > | Строка больше в порядке [**лексикографической сортировки**](https://ru.wikipedia.org/wiki/Лексикографический_порядок). | [[ "bb" > "aa" ]] && echo "Строка bb больше чем aa" |
|  | | |
| < | Строка меньше в порядке лексикографической сортировки. | [[ "ab" < "ac" ]] && echo "Строка ab меньше чем ac" |
|  | | |
| = или == | Строки равны. | [[ "abc" = "abc" ]] && echo "Строки равны" |
|  | | |
| != | Строки не равны. | [[ "abc" != "ab" ]] && echo "Строки не равны" |
|  | | |
| -z | Строка пустая. | [[ -z "$var" ]] && echo "Строка пустая" |
|  | | |
| -n | Строка не пустая. | [[ -n "$var" ]] && echo "Строка не пустая" |
|  | | |
| = или == | Поиск подстроки по шаблону. Обратите внимание, что шаблон не заключается в кавычки. | [[ "$filename" = READ* ]] && echo "Имя файла начинается с READ" |
|  | | |
| != | Проверка, что шаблон не встречается в строке. Обратите внимание, что шаблон не заключается в кавычки. | [[ "$filename" != READ* ]] && echo "Имя файла не начинается с READ" |
|  | | |
| =~ | Поиск подстроки по [**регулярному выражению**](https://www.opennet.ru/docs/RUS/bash_scripting_guide/c11895.html). | [[ "$filename" =~ ^READ.* ]] && echo "Имя файла начинается с READ" |

Для построения выражений с несколькими условиями в операторе `[[` вы можете воспользоваться логическими операциями, приведёнными в таблице 3-9.

{caption: "Таблица 3-9. Логические операции `[[`", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| && | Логическое И. | [[ -n "$var" && "$var" < "abc" ]] && echo "Строка не пустая и меньше чем abc" |
| \|\| | Логическое ИЛИ. | [[ "abc" < "$var" \|\| -z "$var" ]] && echo "Строка больше чем abс или пустая" |
| ! | Логическое НЕ. | [[ ! "abc" < "$var" ]] && echo "Строка не больше чем abc" |

Выражения в операторе `[[` можно группировать с помощью круглых скобок. Например, следующим образом:
{line-numbers: false, format: Bash}
```
[[ (-n "$var" && "$var" < "abc") || -z "$var" ]] && echo "Строка не пустая и меньше чем abc или строка пустая"
```

Кроме сравнения строк, оператор `[[` позволяет проверять файлы на различные условия. Наиболее часто используемые из них приведены в таблице 3-10.

{caption: "Таблица 3-10. Операции проверки файлов `[[`", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| -e | Файл существует. | [[ -e "$filename" ]] && echo "Файл $filename существует" |
|  | | |
| -f | Проверяемый объект является обычным файлом (не каталогом и не [**файлом устройства**](https://ru.wikipedia.org/wiki/Специальный_файл_устройства)). | [[ -f "~/README.txt" ]] && echo "README.txt - это обычный файл" |
|  | | |
| -d | Проверяемый объект является каталогом. | [[ -f "/usr/bin" ]] && echo "/usr/bin - это каталог" |
|  | | |
| -s | Файл не пустой. | [[ -s "$filename" ]] && echo "Файл $filename не пустой" |
|  | | |
| -r | Файл существует и доступен для чтения пользователю, запустившему скрипт. | [[ -r "$filename" ]] && echo "Файл $filename существует и доступен для чтения" |
|  | | |
| -w | Файл существует и доступен для записи пользователю, запустившему скрипт. | [[ -w "$filename" ]] && echo "Файл $filename существует и доступен для записи" |
|  | | |
| -x | Файл существует и доступен для исполнения пользователю, запустившему скрипт. | [[ -x "$filename" ]] && echo "Файл $filename существует и доступен для исполнения" |
|  | | |
| -N | Файл существует и был модифицирован с момента последнего чтения. | [[ -N "$filename" ]] && echo "Файл $filename существует и был модифицирован" |
|  | | |
| -nt | Файл слева от оператора новее, чем файл справа. Либо файл слева существует, а справа - нет. | [[ "$file1" -nt "$file2" ]] && echo "Файл $file1 новее чем $file2" |
|  | | |
| -ot | Файл слева от оператора старее, чем файл справа. Либо файл справа существует, а слева - нет. | [[ "$file1" -ot "$file2" ]] && echo "Файл $file1 старее чем $file2" |
|  | | |
| -ef | Слева и справа от оператора указан путь до одного и того же существующего файла. Если ваша система поддерживает **жёсткие ссылки**, то ссылки слева и справа от оператора указывают на один и тот же файл. | [[ "$file1" -ef "$file2" ]] && echo "Файлы $file1 и $file2 совпадают" |

Оператор `[[` позволяет сравнивать не только строки, но и целые числа. Таблица 3-11 демонстрирует соответствующие операции.

{caption: "Таблица 3-11. Операции сравнения целых чисел `[[`", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| -eq | Равно. | [[ "$var" -eq 5 ]] && echo "Переменная равна 5" |
| -ne | Не равно. | [[ "$var" -ne 5 ]] && echo "Переменная не равна 5" |
| -gt | Больше (>). | [[ "$var" -gt 5 ]] && echo "Переменная больше 5" |
| -ge | Больше или равно. | [[ "$var" -ge 5 ]] && echo "Переменная больше или равна 5" |
| -lt | Меньше (<). | [[ "$var" -lt 5 ]] && echo "Переменная меньше 5" |
| -le | Меньше или равно. | [[ "$var" -le 5 ]] && echo "Переменная меньше или равна 5" |

Таблица 3-11 вызывает вопросы. Очевидно, что запоминать операции сравнения чисел неудобно. Почему вместо двухбуквенных сокращений нельзя использовать привычные знаки сравнения (`<`, `>` и `=`)? Перед тем как ответить на этот вопрос, обратимся к истории оператора `[[`.

Как было замечено ранее, оператор `[[` появился в Bash на замену устаревшего `test`. В первой версии Bourne shell 1979 года `test` был сторонней утилитой. Только начиная с версии System III shell 1981 года, он стал встроенной командой интерпретатора. Но это изменение не затронуло синтаксис `test`. Дело в том, что к этому времени было написано достаточно кода и новая версия интерпретатора должна была его поддерживать.

Работа с `test` в качестве внешней утилиты накладывает ограничения. Прежде всего они связаны с входными параметрами. Рассмотрим типичный вызов `test` для сравнения значения переменной `var` с числом:
{line-numbers: false, format: Bash}
```
test "$var" -eq 5
```

Эта команда не вызывает вопросов. В утилиту `test` передаются три разделённые пробелами параметра: значение переменной `var`, ключ `-eq` и число 5. Если мы скомбинируем этот вызов с конструкцией `if`, получим следующее:
{line-numbers: true, format: Bash}
```
if test "$var" -eq 5
then
    echo "Переменная равна 5"
fi
```

В Bourne shell был введён синоним `[` для `test`. Единственное отличие между ними — это требование закрывающей скобки `]`, которая не нужна для `test`. С помощью синонима мы можем переписать наше выражение `if` так:
{line-numbers: true, format: Bash}
```
if [ "$var" -eq 5 ]
then
    echo "Переменная равна 5"
fi
```

Синоним `[` ввели для лучшей читаемости кода. Благодаря ему, конструкция `if` в Bourne shell стала больше походить на свои аналоги из других языков программирования (например C). Проблема в том, что скобки и выражение в них эквивалентно вызову `test`. Этот факт легко упустить из виду, особенно имея опыт программирования на других языках. Такое несоответствие ожидаемого поведения (конструкция языка) и реального (вызов `test`) является источником большинства ошибок, связанных с использованием оператора `[`.

Например, часто встречается ошибка, когда между `[` и следующим далее символом не ставится пробел:
{line-numbers: true, format: Bash}
```
if ["$var" -eq 5]
then
    echo "Переменная равна 5"
fi
```

Просто замените скобку на `test` и ошибки сразу станет очевидна:
{line-numbers: true, format: Bash}
```
if test"$var" -eq 5
then
    echo "Переменная равна 5"
fi
```

Между именем команды и её параметрами всегда должен стоять пробел.

Вернёмся к нашему исходному вопросу касательно знаков сравнения для чисел. Представьте себе следующий вызов `test`:
{line-numbers: false, format: Bash}
```
test "$var" > 5
```

Как вы помните, символ `>` является сокращением для перенаправления стандартного потока вывода `1>`. Поэтому команда выше выполнит следующие шаги:

1. Вызовет встроенную команду `test` и передаст ей на вход переменную `var`.

2. Перенаправит вывод `test` в файл с именем `5` в текущем каталоге.

Это совсем не то поведение, которое мы ожидали. Подобную ошибку легко совершить и крайне сложно обнаружить. Чтобы её избежать и были введены двухбуквенные операции для сравнения чисел. Эти операции перекочевали в новый оператор `[[` Bash. По идее, ничто не мешало заменить их на знаки сравнения. Но такое решение усложнило бы портирование старого кода с Bourne shell на Bash. Рассмотрим пример.

Представьте, что у вас есть следующая конструкция `if`:
{line-numbers: true, format: Bash}
```
if [ "$var1" -gt 5 -o 4 -lt "$var2" ]
then
    echo "Переменная var1 больше 5 или var2 больше 4"
fi
```

Намного безопаснее поставить по дополнительной скобке в начале и в конце выражения, чем менять `-gt` на `>`, а `-lt` на `<`. При таких заменах легко допустить ошибку.

В случае сравнения строк задачи обеспечить обратную совместимость не стояло. Первоначальная утилита `test` вообще не поддерживала знаков `<` и `>`. Такая поддержка появилась для строк, но только в расширении POSIX-стандарта. Там знаки сравнения приходилось экранировать `/<` и `/>`. Из стандарта они были портированы в оператор `[[`, но уже без экранирования.

{caption: "Упражнение 3-5. Использование оператора `[[`", format: text, line-numbers: false}
```
Напишите скрипт для сравнения двух каталогов с именами dir1 и dir2. На экран должны выводится все файлы, которые есть в одном каталоге, но отсутствуют в другом.
```

### Оператор case

В программировании часто требуется выполнить опеределённый код в зависимости от какого-либо значения.

Рассмотрим пример. Предположим, что вы пишете скрипт, который должен архивировать ваши документы. У него есть три режима работы: архивация со сжатием, архивация без зжатия и разархивация. Поведение скрипта определяется опцией командной строки. Значение этой опции можно проверять в конструкции `if` следующим образом:
{line-numbers: true, format: Bash}
```
operation="$1"

if [[ "$operation" == "a" ]]
then
    bsdtar -c -f documents.tar ~/Documents
elif [[ "$operation" == "c" ]]
then
    bsdtar -c -j -f documents.tar.bz2 ~/Documents
elif [[ "$operation" == "x" ]]
then
    bsdtar -x -f documents.tar*
else
    echo "Указана недопустимая опция"
fi
```

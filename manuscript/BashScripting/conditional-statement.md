## Условные операторы

Условные конструкции знакомы нам из опыта работы с утилитой `find`. В языке Bash есть собственные логические операторы `&&` и `||`. Кроме них есть и другие формы ветвления, каждая из которых предназначена для определённой цели. Рассмотрим инструкции `if` и `case`, которые часто оказываются полезны при разработке скриптов.

### Оператор if

Когда мы пишем однострочную команду и скрипт, то руководствуемся разными требованиями. В первом случае важна компактность. Согласитесь, что короткую команду проще набирать и шанс допустить ошибку меньше. В случае скриптов, важнее наглядность и удобство чтения.

Операторы `&&` и `||` хорошо подходят для однострочных команд. Но когда речь заходит о скриптах, у них появляются более удобные альтернативы. На самом деле всё зависит от конкретного случая. Иногда `&&` и `||` отлично вписываются в код скрипта, а иногда их следует заменить на более удобные конструкции. Рассмотрим эти случаи подробнее.

Ещё раз обратимся к нашему скрипту для резервного копирования из листинга 3-9. Его вторая строка выглядит следующим образом:
{line-numbers: false, format: Bash}
```
bsdtar -cjf "$1".tar.bz2 "$@" && echo "bsdtar - OK" > results.txt || { echo "bsdtar - FAILS" > results.txt ; exit 1 ; }
```

Мы разбили вызовы утилит `bsdtar` и `mv` на две отдельные команды. Это помогло, но лишь отчасти. Вызов `bsdtar` всё ещё слишком длинный, из-за чего его неудобно читать и изменять. Это верный сигнал о том, что при его написании было принято неверное техническое решение.

Распишем алгоритм вызова `bsdtar` по шагам:

1. Выполнить архивирование и сжатие всех файлов и каталогов из переменной `$@`.

2. Если команда завершилась успешно, записать в лог-файл строку "bsdtar - OK".

3. Если при работе `bsdtar` произошла ошибка, записать в лог-файл строку "bsdtar - FAILS" и завершить работу скрипта.

Вопросы вызывает третий пункт. Обратите внимание, что при успешном завершении `bsdtar` выполняется только одно действие. В случае же ошибки — действий два и они объединены в [**блок команд**](https://ru.wikipedia.org/wiki/Блок_(программирование)) с помощью [фигурных скобок](https://www.gnu.org/software/bash/manual/html_node/Command-Grouping.html). 

Конструкция `if` была введена как раз для удобства работы с блоками команд. В общем случае она выглядит следующим образом:
{line-numbers: true}
```
if УСЛОВИЕ
then
    ДЕЙСТВИЕ
fi
```

Если требуется записать `if` в одну строку, после `if УСЛОВИЕ` и `then ДЕЙСТВИЕ` следует поставить точки с запятой:
{line-numbers: false}
```
if УСЛОВИЕ; then ДЕЙСТВИЕ; fi
```

УСЛОВИЕ и ДЕЙСТВИЕ в операторе `if` представляют собой команду или блок команд. Если УСЛОВИЕ завершилось успешно с кодом 0, будут выполнены команды, соответствующие ДЕЙСТВИЮ.

Рассмотрим простой пример:
{line-numbers: true, format: Bash}
```
if cmp file1.txt file2.txt &> /dev/null
then
    echo "Файлы file1.txt и file2.txt идентичны"
fi
```

В качестве УСЛОВИЯ мы вызываем утилиту `cmp`. Она побайтово сравнивает содержимое двух файлов, переданных на вход. Если они отличаются, `cmp` печатает в стандартный поток вывода позицию первого различающегося символа. В данном случае нас интересует только код возврата утилиты. Поэтому мы перенаправляем её вывод в файл [`/dev/null`](https://ru.wikipedia.org/wiki//dev/null). Запись в `dev/null` всегда происходит успешно, а все записанные данные удаляются.

Итак, если файлы `file1.txt` и `file2.txt` имеют одинаковое содержимое, команда `echo` выведет соответствующее сообщение на экран.

Если в случае невыполнения условия требуется выполнить какие-то действия, воспользуйтесь конструкцией `if-else`:
{line-numbers: true}
```
if УСЛОВИЕ
then
    ДЕЙСТВИЕ 1
else
    ДЕЙСТВИЕ 2
fi
```

Запись `if-else` в одну строку выглядит так:
{line-numbers: false}
```
if УСЛОВИЕ; then ДЕЙСТВИЕ 1; else ДЕЙСТВИЕ 2; fi
```

В этой конструкции блок команд, обозначенный как ДЕЙСТВИЕ 2, будет выполняться, если УСЛОВИЕ вернёт код ошибки отличный от 0. В противном случае исполнится ДЕЙСТВИЕ 1.

Конструкция `if-else` может быть дополнена условиями и действиями с помощью блоков `elif`. Например, представьте себе, что в зависимости от значения переменной вы выбираете одно из трёх действий. В этом случае оператор `if` будет выглядеть так:
{line-numbers: true}
```
if УСЛОВИЕ 1
then
    ДЕЙСТВИЕ 1
elif УСЛОВИЕ 2
then
    ДЕЙСТВИЕ 2
else
    ДЕЙСТВИЕ 3
fi
```

Обратите внимание, что допустимое количество блоков `elif` не ограничено.

Воспользуемся конструкцией `if-else`, чтобы добавить в наш пример сравнения файлов вывод сообщения об их различии:
{line-numbers: true, format: Bash}
```
if cmp file1.txt file2.txt &> /dev/null
then
    echo "Файлы file1.txt и file2.txt идентичны"
else
    echo "Файлы file1.txt и file2.txt различаются"
fi
```

Вернёмся к нашему скрипту резервного копирования. Как мы выяснили, если при выполнении кого-то условия следует выполнить блок команд, предпочтительнее использовать конструкцию `if`, а не операторы `&&` и `||`. В нашем случае блок команд включает вывод сообщения об ошибке в лог-файл и вызов `exit`.

Перепишем вызов `bsdtar` с использованием `if`:
{line-numbers: true, format: Bash}
```
if bsdtar -cjf "$1".tar.bz2 "$@"
then
    echo "bsdtar - OK" > results.txt
else
    echo "bsdtar - FAILS" > results.txt
    exit 1
fi
```

Согласитесь, что теперь читать код стало намного удобнее. На самом деле мы можем его упростить. Применим технику [**раннего возврата**](https://habr.com/ru/post/348074/) и заменим конструкцию `if-else` на `if`:
{line-numbers: true, format: Bash}
```
if ! bsdtar -cjf "$1".tar.bz2 "$@"
then
    echo "bsdtar - FAILS" > results.txt
    exit 1
fi

echo "bsdtar - OK" > results.txt
```

Что изменилось? Поведение нашего кода осталось без изменений. С помощью логического отрицания `!` мы инвертируем результат вызова утилиты `bsdtar`. Поэтому если он завершится с ошибкой, условие оператора `if` будет истинным. В этом случае будет выведено сообщение "bsdtar - FAILS" и вызвана команда `exit`. Если утилита `bsdtar` отработает корректно, произойдёт вывод "bsdtar - OK".

Идея техники раннего возврата заключается в том, чтобы в случае ошибки завершить программу как можно раньше. Благодаря этому, мы избегаем многократных вложений операторов `if`. Рассмотрим пример. Представьте, что у нас есть алгоритм состоящий из пяти действий. Каждое последующее должно выполняться только при успешном завершении предыдущего. Мы можем реализовать этот алгоритм с помощью конструкции `if` таким образом:
{line-numbers: true}
```
if ДЕЙСТВИЕ 1
then
    if ДЕЙСТВИЕ 2
    then
        if ДЕЙСТВИЕ 3
        then
            if ДЕЙСТВИЕ 4
            then
                ДЕЙСТВИЕ 5
            fi
        fi
    fi
fi
```

Эта программа выглядит запутанной. Добавьте в неё `else` с выводами сообщений об ошибках для каждого действия и читать её станет ещё сложнее. Ранний возврат решает проблему наглядности вложенных условий. Перепишем наш алгоритм с применением этой техники:
{line-numbers: true}
```
if ! ДЕЙСТВИЕ 1
then
    # обработка ошибки
fi

if ! ДЕЙСТВИЕ 2
then
    # обработка ошибки
fi

if ! ДЕЙСТВИЕ 3
then
    # обработка ошибки
fi

if ! ДЕЙСТВИЕ 4
then
    # обработка ошибки
fi

ДЕЙСТВИЕ 5
```

I> Строка скрипта начинающаяся с символа решётка `#` является [**комментарием**](https://ru.wikipedia.org/wiki/Комментарии_(программирование)). Это значит, что она будет проигнорирована интерпретатором. Комментарии используются для пояснений к коду и объяснения намерений программиста.

Обратите внимание, что применение конструкции `if` в данном случае оправданно, только если обработка ошибки состоит из блока команд. Если же достаточно просто вызова `exit`, предпочтительнее использовать оператор `||`:
{line-numbers: true}
```
ДЕЙСТВИЕ 1 || exit 1
ДЕЙСТВИЕ 2 || exit 1
ДЕЙСТВИЕ 3 || exit 1
ДЕЙСТВИЕ 4 || exit 1
ДЕЙСТВИЕ 5
```

Листинг 3-11 демонстрирует скрипт резервного копирования, переписанный с использованием конструкции `if`.

{caption: "Листинг 3-11. Скрипт с ранним возвратом", line-numbers: true, format: Bash}
![`make-backup-if.sh`](code/BashScripting/make-backup-if.sh)

В нашем скрипте резервного копирования мы можем заменить логические операторы `&&` и `||` на конструкцию `if`, но в общем случае они не эквивалентны. Рассмотрим пример. Предположим, что у нас есть выражение из трёх команд A, B и C:
{line-numbers: false}
```
A && B || C
```

Можно предположить, что следующая конструкция `if-else` даст то же самое поведение:
{line-numbers: false}
```
if A
then
    B
else
    C
fi
```

В этой `if-else` конструкции если A истинно, то выполняется B. Иначе выполняется C.

Но в выражении с логическими операторами `&&` и `||` поведение иное! Если A истинно, выполняется B. Далее выполнение C зависит от результата B. Если B истинно, C выполняться не будет. Если же B ложно, C исполнится. Таким образом исполнение C зависит и от результата A, и от результата B. В конструкции `if-else` такой зависимости нет.

{caption: "Упражнение 3-4. Использование оператора if", format: text, line-numbers: false}
```
Нам дана команда, которая проверяет файлы в каталоге с именем target на наличие в них строки "123". Файлы, в которых она встречается, копируются в текущий каталога. Если строки в файле не обнаружено, он удаляется из каталога target.

Команда выглядит следующим образом:
( grep -RlZ "123" target | xargs -0 cp -t . && echo "cp - OK" || ! echo "cp - FAILS" ) && ( grep -RLZ "123" target | xargs -0 rm && echo "rm - OK" || echo "rm - FAILS" )

Напишите скрипт, в котором логические операторы && и || заменены на конструкции if-else.
```

### Оператор [[

Мы познакомились с оператором `if`. В качестве условия в нём вызывается встроенная команда Bash или сторонняя утилита. Мы уже знаем, как работать с файловой системой. Поэтому способ комбинации `if`, например, с командой `grep` достаточно очевиден.

При вызове утилиты `grep` в качестве условия конструкции `if` используйте параметр `-q`. Благодаря ему, `grep` не будет ничего выводить в stdout, а вместо этого вернёт код 0 при первом вхождении искомой строки или шаблона. Например:
{line-numbers: true, format: Bash}
```
if grep -q -R "General Public License" /usr/share/doc/bash
then
    echo "Bash распространяется под лицензией GPL"
fi
```

Но что делать, если нам требуется проверять условия не связанные с файловой системой, а, например, сравнивать строки или числа? Для работы со строками в Bash есть специальный оператор `[[`. Обратите внимание, что это не внешняя утилита, а [**зарезервированное слово**](https://ru.wikipedia.org/wiki/Зарезервированное_слово) интерпретатора.

W> Оператора `[[` нет в Bourne shell. Если в вашем случае важна POSIX-совместимость, вам придётся воспользоваться устаревшим оператором [`test`](http://mywiki.wooledge.org/BashFAQ/031) или его синонимом `[`. Никогда не используйте его в Bash! Возможности `test` по сравнению с `[[` ограничены, а правильные способы применения неочевидны.

Начнём с простого примера использования `[[`. Предположим, что нам надо сравнить две строки. В этом случае условие `if` будет выглядеть следующим образом:
{line-numbers: true, format: Bash}
```
if [[ "abc" = "abc" ]]
then
    echo "Строки равны"
fi
```

Выполнив этот код, вы увидите сообщение, что строки равны. Подобная проверка не слишком полезна. Обычно приходится сравнивать значение какой-то переменной со строкой. В этом случае оператор `[[` будет выглядеть так:
{line-numbers: true, format: Bash}
```
if [[ "$var" = "abc" ]]
then
    echo "Переменная равна строке abc"
fi
```

В рассмотренных нами примерах двойные кавычки необязательны. При подстановке переменной в выражение `[[` globbing и world splitting не выполняются. То есть интерпретатор не пытается самостоятельно обработать значение `var`, а использует его как есть. Ошибка может произойти, если в строке, с которой сравнивается переменная, встречаются пробелы. Например, в следующем случае:
{line-numbers: true, format: Bash}
```
if [[ "$var" = abc def ]]
then
    echo "Переменная равна строке abc def"
fi
```

Чтобы избежать подобных ошибок при работе со строками лучше всегда использовать кавычки:
{line-numbers: true, format: Bash}
```
if [[ "$var" = "abc def" ]]
then
    echo "Переменная равна строке abc def"
fi
```

Вы также можно сравнивать значения двух переменных друг с другом. Например так:
{line-numbers: true, format: Bash}
```
if [[ "$var" = "$filename" ]]
then
    echo "Переменные равны"
fi
```

В таблице 3-8 приведены все операции сравнения строк, допустимые в операторе `[[`.

{caption: "Таблица 3-8. Операции сравнения строк `[[`", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| > | Строка больше в порядке [**лексикографической сортировки**](https://ru.wikipedia.org/wiki/Лексикографический_порядок). | [[ "bb" > "aa" ]] && echo "Строка bb больше чем aa" |
|  | | |
| < | Строка меньше в порядке лексикографической сортировки. | [[ "ab" < "ac" ]] && echo "Строка ab меньше чем ac" |
|  | | |
| = или == | Строки равны. | [[ "abc" = "abc" ]] && echo "Строки равны" |
|  | | |
| != | Строки не равны. | [[ "abc" != "ab" ]] && echo "Строки не равны" |
|  | | |
| -z | Строка пустая. | [[ -z "$var" ]] && echo "Строка пустая" |
|  | | |
| -n | Строка не пустая. | [[ -n "$var" ]] && echo "Строка не пустая" |
|  | | |
| = или == | Поиск подстроки по шаблону. Обратите внимание, что шаблон не заключается в кавычки. | [[ "$filename" = READ* ]] && echo "Имя файла начинается с READ" |
|  | | |
| != | Проверка, что шаблон не встречается в строке. Обратите внимание, что шаблон не заключается в кавычки. | [[ "$filename" != READ* ]] && echo "Имя файла не начинается с READ" |
|  | | |
| =~ | Поиск подстроки по [**регулярному выражению**](https://www.opennet.ru/docs/RUS/bash_scripting_guide/c11895.html). | [[ "$filename" =~ ^READ.* ]] && echo "Имя файла начинается с READ" |

Для построения выражений с несколькими условиями в операторе `[[` вы можете воспользоваться логическими операциями, приведёнными в таблице 3-9.

{caption: "Таблица 3-9. Логические операции `[[`", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| && | Логическое И. | [[ -n "$var" && "$var" < "abc" ]] && echo "Строка не пустая и меньше чем abc" |
| \|\| | Логическое ИЛИ. | [[ "abc" < "$var" \|\| -z "$var" ]] && echo "Строка больше чем abс или пустая" |
| ! | Логическое НЕ. | [[ ! "abc" < "$var" ]] && echo "Строка не больше чем abc" |

Выражения в операторе `[[` можно группировать с помощью круглых скобок. Например, следующим образом:
{line-numbers: false, format: Bash}
```
[[ (-n "$var" && "$var" < "abc") || -z "$var" ]] && echo "Строка не пустая и меньше чем abc или строка пустая"
```

Кроме сравнения строк, оператор `[[` позволяет проверять файлы на различные условия. Наиболее часто используемые из них приведены в таблице 3-10.

{caption: "Таблица 3-10. Операции проверки файлов `[[`", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| -e | Файл существует. | [[ -e "$filename" ]] && echo "Файл $filename существует" |
|  | | |
| -f | Проверяемый объект является обычным файлом (не каталогом и не [**файлом устройства**](https://ru.wikipedia.org/wiki/Специальный_файл_устройства)). | [[ -f "~/README.txt" ]] && echo "README.txt - это обычный файл" |
|  | | |
| -d | Проверяемый объект является каталогом. | [[ -f "/usr/bin" ]] && echo "/usr/bin - это каталог" |
|  | | |
| -s | Файл не пустой. | [[ -s "$filename" ]] && echo "Файл $filename не пустой" |
|  | | |
| -r | Файл существует и доступен для чтения пользователю, запустившему скрипт. | [[ -r "$filename" ]] && echo "Файл $filename существует и доступен для чтения" |
|  | | |
| -w | Файл существует и доступен для записи пользователю, запустившему скрипт. | [[ -w "$filename" ]] && echo "Файл $filename существует и доступен для записи" |
|  | | |
| -x | Файл существует и доступен для исполнения пользователю, запустившему скрипт. | [[ -x "$filename" ]] && echo "Файл $filename существует и доступен для исполнения" |
|  | | |
| -N | Файл существует и был модифицирован с момента последнего чтения. | [[ -N "$filename" ]] && echo "Файл $filename существует и был модифицирован" |
|  | | |
| -nt | Файл слева от оператора новее, чем файл справа. Либо файл слева существует, а справа - нет. | [[ "$file1" -nt "$file2" ]] && echo "Файл $file1 новее чем $file2" |
|  | | |
| -ot | Файл слева от оператора старее, чем файл справа. Либо файл справа существует, а слева - нет. | [[ "$file1" -ot "$file2" ]] && echo "Файл $file1 старее чем $file2" |
|  | | |
| -ef | Слева и справа от оператора указан путь до одного и того же существующего файла. Если ваша система поддерживает **жёсткие ссылки**, то ссылки слева и справа от оператора указывают на один и тот же файл. | [[ "$file1" -ef "$file2" ]] && echo "Файлы $file1 и $file2 совпадают" |

Оператор `[[` позволяет сравнивать не только строки, но и целые числа. Таблица 3-11 демонстрирует соответствующие операции.

{caption: "Таблица 3-11. Операции сравнения целых чисел `[[`", width: "100%"}
| Операция | Описание | Пример |
| --- | --- | --- |
| -eq | Равно. | [[ "$var" -eq 5 ]] && echo "Переменная равна 5" |
| -ne | Не равно. | [[ "$var" -ne 5 ]] && echo "Переменная не равна 5" |
| -gt | Больше (>). | [[ "$var" -gt 5 ]] && echo "Переменная больше 5" |
| -ge | Больше или равно. | [[ "$var" -ge 5 ]] && echo "Переменная больше или равна 5" |
| -lt | Меньше (<). | [[ "$var" -lt 5 ]] && echo "Переменная меньше 5" |
| -le | Меньше или равно. | [[ "$var" -le 5 ]] && echo "Переменная меньше или равна 5" |

Таблица 3-11 вызывает вопросы. Очевидно, что запоминать операции сравнения чисел неудобно. Почему вместо двухбуквенных сокращений нельзя использовать привычные знаки сравнения (`<`, `>` и `=`)? Перед тем как ответить на этот вопрос, обратимся к истории оператора `[[`.

Как было замечено ранее, оператор `[[` появился в Bash на замену устаревшего `test`. В первой версии Bourne shell 1979 года `test` был сторонней утилитой. Только начиная с версии System III shell 1981 года, он стал встроенной командой интерпретатора. Но это изменение не затронуло синтаксис `test`. Дело в том, что к этому времени было написано достаточно кода и новая версия интерпретатора должна была его поддерживать.

Работа с `test` в качестве внешней утилиты накладывает ограничения. Прежде всего они связаны с входными параметрами. Рассмотрим типичный вызов `test` для сравнения значения переменной `var` с числом:
{line-numbers: false, format: Bash}
```
test "$var" -eq 5
```

Эта команда не вызывает вопросов. В утилиту `test` передаются три разделённые пробелами параметра: значение переменной `var`, ключ `-eq` и число 5. Если мы скомбинируем этот вызов с конструкцией `if`, получим следующее:
{line-numbers: true, format: Bash}
```
if test "$var" -eq 5
then
    echo "Переменная равна 5"
fi
```

В Bourne shell был введён синоним `[` для `test`. Единственное отличие между ними — это требование закрывающей скобки `]`, которая не нужна для `test`. С помощью синонима мы можем переписать наше выражение `if` так:
{line-numbers: true, format: Bash}
```
if [ "$var" -eq 5 ]
then
    echo "Переменная равна 5"
fi
```

Синоним `[` ввели для лучшей читаемости кода. Благодаря ему, конструкция `if` в Bourne shell стала больше походить на свои аналоги из других языков программирования (например C). Проблема в том, что скобки и выражение в них эквивалентно вызову `test`. Этот факт легко упустить из виду, особенно имея опыт программирования на других языках. Такое несоответствие ожидаемого поведения (конструкция языка) и реального (вызов `test`) является источником большинства ошибок, связанных с использованием оператора `[`.

Например, часто встречается ошибка, когда между `[` и следующим далее символом не ставится пробел:
{line-numbers: true, format: Bash}
```
if ["$var" -eq 5]
then
    echo "Переменная равна 5"
fi
```

Просто замените скобку на `test` и ошибки сразу станет очевидна:
{line-numbers: true, format: Bash}
```
if test"$var" -eq 5
then
    echo "Переменная равна 5"
fi
```

Между именем команды и её параметрами всегда должен стоять пробел.

Вернёмся к нашему исходному вопросу касательно знаков сравнения для чисел. Представьте себе следующий вызов `test`:
{line-numbers: false, format: Bash}
```
test "$var" > 5
```

Как вы помните, символ `>` является сокращением для перенаправления стандартного потока вывода `1>`. Поэтому команда выше выполнит следующие шаги:

1. Вызовет встроенную команду `test` и передаст ей на вход переменную `var`.

2. Перенаправит вывод `test` в файл с именем `5` в текущем каталоге.

Это совсем не то поведение, которое мы ожидали. Подобную ошибку легко совершить и крайне сложно обнаружить. Чтобы её избежать и были введены двухбуквенные операции для сравнения чисел. Эти операции перекочевали в новый оператор `[[` Bash. По идее, ничто не мешало заменить их на знаки сравнения. Но такое решение усложнило бы портирование старого кода с Bourne shell на Bash. Рассмотрим пример.

Представьте, что у вас есть следующая конструкция `if`:
{line-numbers: true, format: Bash}
```
if [ "$var1" -gt 5 -o 4 -lt "$var2" ]
then
    echo "Переменная var1 больше 5 или var2 больше 4"
fi
```

Намного безопаснее поставить по дополнительной скобке в начале и в конце выражения, чем менять `-gt` на `>`, а `-lt` на `<`. При таких заменах легко допустить ошибку.

В случае сравнения строк задачи обеспечить обратную совместимость не стояло. Первоначальная утилита `test` вообще не поддерживала знаков `<` и `>`. Такая поддержка появилась для строк, но только в расширении POSIX-стандарта. Там знаки сравнения приходилось экранировать `/<` и `/>`. Из стандарта они были портированы в оператор `[[`, но уже без экранирования.

{caption: "Упражнение 3-5. Использование оператора `[[`", format: text, line-numbers: false}
```
Напишите скрипт для сравнения двух каталогов с именами dir1 и dir2. На экран должны выводится все файлы, которые есть в одном каталоге, но отсутствуют в другом.
```

### Оператор case

В программировании часто требуется выполнить определённый код в зависимости от какого-либо значения. Именно эту задачу решают условные конструкции. Мы уже познакомились с оператором `if`. Ещё в Bash есть условная конструкция `case`. В некоторых случаях использовать её удобнее чем `if`.

Рассмотрим пример. Предположим, что вы пишете скрипт, который должен архивировать ваши документы. У него есть три режима работы: архивация со сжатием, архивация без сжатия и разархивация. Нужное действие выбирается с помощью опции скрипта. Таблица 3-12 приводит возможный вариант соответствия опций и режимов.

{caption: "Таблица 3-12. Опции скрипта архивации", width: "50%"}
| Опция | Режим работы |
| --- | --- |
| `a` | Архивация без сжатия |
| `c` | Архивация со сжатием |
| `d` | Разархивация |

Значение переданной в скрипт опции можно проверить в конструкции `if`. Например так, как демонстрирует листинг 3-12.

{caption: "Листинг 3-12. Скрипт архивации документов", line-numbers: true, format: Bash}
![`archiving.sh`](code/BashScripting/archiving.sh)

Позиционный параметр `$1` присваивается переменной `operation` для удобства. Дальше в зависимости от её значения вызывается утилита `bsdtar` с теми или иными параметрами. Такое же поведение можно добиться с помощью конструкции `case`.

Листинг 3-13 демонстрирует скрипт архивации, переписанный с использованием `case`.

{caption: "Листинг 3-13. Скрипт архивации документов", line-numbers: true, format: Bash}
![`archiving-case.sh`](code/BashScripting/archiving-case.sh)

В общем случае конструкция `case` позволяет сравнить переданную в неё строку со списком шаблонов. В зависимости от совпадения с шаблоном выбирается один из блоков `case`. Каждый такой блок состоит из следующих элементов:

1. Шаблон или список шаблонов, разделённых символом `|`.

2. Правая скобка `)`.

3. Набор команд, которые выполняются при совпадении шаблона и переданной в `case` строки.

4. Два знака точка с запятой `;;`, которые означают окончание набора команд.

Проверка шаблонов происходит последовательно. Если переданная в конструкцию `case` строка соответствует нескольким шаблонам, будет выбран первый из списка.

Шаблон `*` соответствует любой строке. Обычно он используется в конце списка, чтобы обработать случай, когда ни один из шаблонов не подошёл. Как правило, это означает ошибку.

На первый взгляд может показаться, что рассмотренные нами конструкции `if` и `case` эквивалентны. Но это не так. Они всего лишь позволяют добиться одинакового поведения.

Для удобства дальнейшего рассмотрения, запишем конструкции `if` и `case` из нашего примера в общем виде. Вариант с `if` будет выглядеть следующим образом:
{line-numbers: true}
```
if УСЛОВИЕ 1
then
    ДЕЙСТВИЕ 1
elif УСЛОВИЕ 2
then
    ДЕЙСТВИЕ 2
elif УСЛОВИЕ 3
then
    ДЕЙСТВИЕ 3
else
    ДЕЙСТВИЕ 4
fi
```

Вариант с `case` выглядит так:
{line-numbers: true}
```
case СТРОКА in
    ШАБЛОН 1)
        ДЕЙСТВИЕ 1
        ;;

    ШАБЛОН 2)
        ДЕЙСТВИЕ 2
        ;;

    ШАБЛОН 3)
        ДЕЙСТВИЕ 3
        ;;

    ШАБЛОН 4)
        ДЕЙСТВИЕ 4
        ;;
esac
```

Благодаря записи конструкций в общем виде стали очевидны их различия. Прежде всего, `if` проверяет результат вычисления логических выражений. В отличие от этого конструкция `case` сравнивает значение переданной в неё строки с несколькими шаблонами.

Ещё раз обратите внимание на этот момент. Передавать в `case` логическое выражение нет никакого смысла. Это позволит вам обработать только два случая: когда выражение истинно и когда — ложно. Конструкция `if` намного удобнее для такой проверки.

Второе различие `if` и `case` заключается в количестве условий. В `if` каждая ветвь конструкции (`if`, `elif` и `else`) проверяет новое логическое выражение. В общем случае эти выражения никак не связаны. В нашем примере они проверяют значения одной и той же переменной, но это частный случай. Конструкция `case` работает с одной-единственной переданной в неё строкой.

Операторы `if` и `case` принципиально отличаются. Они не взаимозаменяемы. В каждом конкретном случае следует использовать ту или иную конструкцию в зависимости от характера проверки. Следующие вопросы помогут вам сделать правильный выбор:

* Сколько условий надо проверить?
* Требуются ли составные логические выражения или достаточно сравнения одной строки?

Блоки `case` можно отделять друг от друга двумя знаками точка с запятой `;;` или точкой с запятой и амперсандом `;&`. Синтаксис с амперсандом допустим в Bash, но не является частью POSIX-стандарта. Он позволяет исполнить команды следующего блока `case`. Это может быть полезно, если требуется начать выполнение алгоритма с определённого шага в зависимости от какого-то условия. Также синтаксис с амперсандом позволяет избежать дублирования кода.

Рассмотрим пример. Напишем скрипт, который выполняет архивацию PDF документов пользователя и копирует полученный файл в специальный каталог. Для выбора действия в скрипт передаётся опция (например, `a` для архивации и `c` для копирования). Допустим, что для удобства копирование надо выполнять всегда после архивации. В этом случае возникнет дублирование кода.

Листинг 3-14 демонстрирует конструкцию `case`, в которой команда копирования файла архива дублируется.

{caption: "Листинг 3-14. Скрипт архивации и копирования PDF документов", line-numbers: true, format: Bash}
![`copy-archiving-duplication.sh`](code/BashScripting/copy-archiving-duplication.sh)

Если разделить блоки обработки опций `a` и `c` разделителем `;&`, дублирования кода удастся избежать. Исправленный скрипт приведён в листинге 3-15.

{caption: "Листинг 3-15. Скрипт копирования и архивации PDF документов", line-numbers: true, format: Bash}
![`copy-archiving.sh`](code/BashScripting/copy-archiving.sh)

Разделитель `;&` может быть полезным, но несмотря на это постарайтесь использовать его только в случае крайней необходимости. Проблема в том, что визуально его легко спутать с разделителем `;;` и неправильно прочитать код.

### Альтернатива оператору case

Задача, решаемая конструкцией `case`, близка задаче, решаемой ассоциативными массивами. Массивы устанавливают соответствие между данными (ключ-значение), а конструкция `case` между данными и командами (значение-действие). Как правило, оперировать данными намного удобнее чем кодом. Их проще изменять и контролировать их корректность. Поэтому в некоторых случаях имеет смысл заменять конструкцию `case` на ассоциативный массив. По сравнению с другими языками программирования в Bash очень просто конвертировать данные в команды.

Рассмотрим пример. Напишем скрипт-обёртку для утилит архивации. В зависимости от переданной в скрипт опции будет вызвана либо программа `bsdtar`, либо `tar`. Листинг 3-16 демонстрирует реализацию такого скрипта с помощью конструкции `case`.

{caption: "Листинг 3-16. Скрипт-обёртка для утилит `bsdtar` и `tar`", line-numbers: true, format: Bash}
![`tar-wrapper.sh`](code/BashScripting/tar-wrapper.sh)

Скрипт можно запустить, например, следующей командой:
{line-numbers: false, format: Bash}
```
./tar-wrapper.sh t -cvf documents.tar.bz2 Documents
```

В этом случае будет вызвана утилита `tar`. Для работы с `bsdtar` достаточно заменить опцию `t` на `b`:
{line-numbers: false, format: Bash}
```
./tar-wrapper.sh b -cvf documents.tar.bz2 Documents
```

Обратите внимание, что специальный параметр `$@` не является массивом. Однако, он поддерживает синтаксис, соответствующий подстановке нескольких следующих подряд элементов массива. В нашем случае мы указали подстановку всех элементов начиная со второго.

Перепишем наш скрипт-обёртку с помощью ассоциативного массива. Прежде всего разберёмся в механизмах Bash для конвертации данных в команды. Суть такой конвертации заключается в том, чтобы сохранить команду и её параметры в качестве значения какой-либо переменной. Затем это значение должно быть обработано интерпретатором не как данные, а как команда.

Выполним по шагам рассмотренный алгоритм конвертации в командном интерпретаторе Bash. Сначала объявим переменную, значение которой соответствует команде вызова утилиты `ls`:
{line-numbers: false, format: Bash}
```
ls_command="ls"
```

Теперь передадим значение этой переменной интерпретатору в качестве команды:
{line-numbers: false, format: Bash}
```
$ls_command
```

В результате выполнения на экран будет выведено содержимое текущего каталога. Что произошло? Bash выполнил подстановку параметра, после которой команда стала выглядеть так:
{line-numbers: false, format: Bash}
```
ls
```

После подстановки Bash просто исполнил получившуюся команду.

Может возникнуть вопрос: почему в примере не используются двойные кавычки `"` при подстановке переменной `ls_command`? Чтобы ответить на этот вопрос, добавим в значение переменной опции для утилиты `ls`. Например, следующим образом:
{line-numbers: false, format: Bash}
```
ls_command="ls -l"
```

Теперь подстановка с двойными кавычками приведёт к ошибке:
{line-numbers: true, format: Bash}
```
$ "$ls_command"
ls -l: command not found
```

Проблема заключается в том, что двойные кавычки предотвращают word splitting. В результате после подстановки получится следующая команда:
{line-numbers: false, format: Bash}
```
"ls -l"
```

Другими словами Bash должен выполнить команду или утилиту с именем `ls -l` (ls пробел минус l), вызванную без параметров. Как вы помните, POSIX-стандарт допускает пробелы в именах файлов. Поэтому `ls -l` является корректным именем исполняемого файла.

Мы столкнулись с одним из редких случаев, когда подстановка переменных должна выполняться без использования двойных кавычек.

Проблему использования двойных кавычек при подстановке переменной, значение которой необходимо выполнить, можно решить, если применить встроенную команду интерпретатора `eval`. `eval` формирует команду для исполнения из полученных аргументов. При этом выполняется word splitting независимо от наличия двойных кавычек. В этом случае наш вызов утилиты `ls` с опцией `-l` будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
eval "$ls_command"
```

W> Во многих руководствах по Bash вы можете найти информацию о том, что обработка значений переменных в качестве команд и использование команды `eval` — это плохая практика. В общем случае это так. Использование `eval` может привести к серьёзным ошибкам и уязвимостям. Будьте осторожны при её использовании и никогда не передавайте в `eval` необработанные данные, введённые пользователем.

Теперь мы готовы переписать скрипт-обёртку над утилитой архивации с использованием ассоциативного массива. Листинг 3-17 демонстрирует результат.

{caption: "Листинг 3-17. Скрипт-обёртка для утилит `bsdtar` и `tar`", line-numbers: true, format: Bash}
![`tar-wrapper-array.sh`](code/BashScripting/tar-wrapper-array.sh)

Для обработки некорректных параметров скрипта нам понадобилась конструкция `if`. В ней вычисляются следующие два логических выражения:

1. Проверка, что позиционный параметр `$1` не пустой.

2. Проверка, что в ассоциативном массиве `utils` существует элемент, соответствующий позиционному параметру `$1`. 

Во втором выражении мы использовали опцию `-v` оператора `[[`. Она позволяет проверить, была ли переменная уже объявлена (при этом она может быть равна пустой строке). В этом случае выражение будет истинно.

Пример со скриптом-обёрткой продемонстрировал, что использование ассоциативного массива вместо конструкции `case` позволяет писать более компактный и удобный для чтения код. Поэтому всегда рассматривайте возможность такой замены в своих программах.

{caption: "Упражнение 3-6. Использование `case`", format: text, line-numbers: false}
```
Предположим, что в домашнем каталоге пользователя есть два конфигурационных файла: .bashrc-home и .bashrc-work. Напишите скрипт для переключения между ними.
Эта задача может решаться копированием соответствующего файла по пути ~/.bashrc или созданием символьной ссылки.
После решения задачи с помощью конструкции case попробуйте реализовать вариант с ассоциативным массивом.
```
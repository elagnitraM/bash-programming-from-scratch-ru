# Ответы

## Общая информация

##### Упражнение 1-1. Перевод чисел из BIN в HEX

{line-numbers: false}
```
* 10100110100110 = 0010 1001 1010 0110 = 2 9 A 6 = 29A6

* 1011000111010100010011 = 0010 1100 0111 0101 0001 0011 = 2 C 7 5 1 3 = 2C7513

* 1111101110001001010100110000000110101101 = 1111 1011 1000 1001 0101 0011 0000 0001 1010 1101 = F B 8 9 5 3 0 1 A D = FB895301AD
```

##### Упражнение 1-2. Перевод чисел из HEX в BIN

{line-numbers: false}
```
* FF00AB02 = F F 0 0 A B 0 2 = 1111 1111 0000 0000 1010 1011 0000 0010 = 11111111000000001010101100000010

* 7854AC1 = 7 8 5 4 A C 1 = 0111 1000 0101 0100 1010 1100 0001 = 111100001010100101011000001

* 1E5340ACB38 = 1 E 5 3 4 0 A C B 3 8 = 0001 1110 0101 0011 0100 0000 1010 1100 1011 0011 1000 = 11110010100110100000010101100101100111000
```

## Командный интерпретатор Bash

##### Упражнение 2-1. Шаблоны поиска

Правильный ответ следующий:

* `README.md`

Строка `00_README.txt` не подходит. Согласно шаблону `*ME.??`, после точки идут два символа. В строке `00_README.txt` их три.

В строке `README` нет точки. Поэтому она тоже не подходит.

##### Упражнение 2-2. Шаблоны поиска

Шаблону поиска `*/doc?openssl*` соответствуют три строки:

* `/usr/share/doc/openssl/IPAddressChoice_new.html`
* `/usr/share/doc_openssl/IPAddressChoice_new.html`
* `/doc/openssl`

Строка `doc/openssl` не подходит. В ней нет символа / перед `doc`.

##### Упражнение 2-3. Поиск файлов утилитой find

Вот команда для поиска текстовых файлов в системных каталогах:
{line-numbers: false, format: Bash}
```
find /usr -name "*.txt"
```

Текстовые файлы хранятся только в `/usr`. Поэтому нет смысла проверять остальные системные каталоги.

Подсчитаем число строк в найденных файлах. Для этого добавим действие с вызовом утилиты wc:
{line-numbers: false, format: Bash}
```
find /usr -name "*.txt" -exec wc -l {} +
```

Чтобы найти все текстовые файлы на диске, начните поиск с корневого каталога. Например, так:
{line-numbers: false, format: Bash}
```
find / -name "*.txt"
```

Если к этому вызову добавить действие с утилитой wc, произойдёт ошибка. То есть следующая команда не сработает:
{line-numbers: false, format: Bash}
```
find / -name "*.txt" -exec wc -l {} +
```

Проблема связана с ошибкой на иллюстрации 2-17. Её текст передаётся утилите wc. Утилита рассматривает каждое полученное на вход слово как путь до файла. Текст ошибки — это не пути. Поэтому wc завершит свою работу.

##### Упражнение 2-4. Поиск файлов утилитой grep

Информацию о лицензиях приложений надо искать в системном каталоге с документацией `/usr/share/doc`.

В документации на приложение с лицензией [GNU General Public License](https://ru.wikipedia.org/wiki/GNU_General_Public_License) встречается строка "General Public License". Найдём такие документы следующей командой:
{line-numbers: false, format: Bash}
```
grep -Rl "General Public License" /usr/share/doc
```

Также проверим файлы каталога `/usr/share/licenses`:
{line-numbers: false, format: Bash}
```
grep -Rl "General Public License" /usr/share/licenses
```

В окружении MSYS2 есть два каталога установки приложений: `/mingw32` и `/mingw64`. Они не соответствуют POSIX-стандарту. Проверим установленные в них программы следующими командами:
{line-numbers: true, format: Bash}
```
grep -Rl "General Public License" /mingw32/share/doc
grep -Rl "General Public License" /mingw64/share
```

Чтобы найти приложения с лицензией MIT, строка поиска такая: "MIT license". Для Apache лицензии подойдёт строка "Apache license", а для BSD — "BSD license".

##### Упражнение 2-6. Работа с файлами и каталогами

Для начала создайте каталоги для каждого года и месяца. Например, так:
{line-numbers: true, format: Bash}
```
mkdir -p ~/photo/2019/11
mkdir -p ~/photo/2019/12
mkdir -p ~/photo/2020/01
```

Предположим, что ваши фотографии хранятся в каталоге `D:\Photo`. С помощью утилиты find найдём в нём файлы, созданные в ноябре 2019 года. Чтобы проверить дату создания файла, используйте параметр `-newermt`. Например:
{line-numbers: false, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01
```

Эта команда ищет файлы в каталоге `/d/Photo`. Он соответствует пути `D:\Photo` в Windows-окружении.

Первое выражение `-newermt 2019-11-01` означает выбрать все файлы, изменённые начиная с 1 ноября 2019 года. За ним следует выражение `! -newermt 2019-12-01`. Оно означает — все файлы, модифицированные начиная с 1 декабря 2019 года. Восклицательный знак перед ним означает отрицание. Между выражениями нет условия. Утилита find подставит логическое И. В результате получится выражение: "файлы, созданные после 1 ноября 2019 года, но не позднее 30 ноября 2019 года". Другими словами — "файлы за ноябрь месяц".

Мы написали команду поиска файлов. Добавим к ней действие копирования. Получим следующее:
{line-numbers: false, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01 -exec cp {} ~/photo/2019/11 \;
```

Эта команда скопирует файлы за ноябрь 2019 года в каталог `~/photo/2019/11`.

Вот аналогичные команды для копирования файлов за декабрь и январь:
{line-numbers: true, format: Bash}
```
find /d/Photo -type f -newermt 2019-12-01 ! -newermt 2020-01-01 -exec cp {} ~/photo/2019/12 \;
find /d/Photo -type f -newermt 2020-01-01 ! -newermt 2020-02-01 -exec cp {} ~/photo/2020/01 \;
```

Предположим, что файлы в каталоге `D:\Photo` не нужны. Тогда действие копирования замените на переименование. Получатся такие команды:
{line-numbers: true, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01 -exec mv {} ~/photo/2019/11 \;
find /d/Photo -type f -newermt 2019-12-01 ! -newermt 2020-01-01 -exec mv {} ~/photo/2019/12 \;
find /d/Photo -type f -newermt 2020-01-01 ! -newermt 2020-02-01 -exec mv {} ~/photo/2020/01 \;
```

Обратите внимание на масштабируемость нашего решения. Количество файлов в в каталоге `D:\Photo` не имеет значения. Чтобы разбить их на три месяца, нужно три команды.

##### Упражнение 2-7. Конвейеры и перенаправление потоков ввода-вывода

Выясним, как работает утилита bsdtar. Вызовите её с опцией `--help`. На экран выведется справка. Из неё следует, что для создания [**архива**](https://ru.wikipedia.org/wiki/Архив_(информатика)) каталога утилите передаются опции `-c` и `-f`. Затем идёт имя архива. Вот пример вызова утилиты:
{line-numbers: false, format: Bash}
```
bsdtar -c -f test.tar test
```

Эта команда создаст архив с именем `test.tar`. В нём окажется всё содержимое каталога `test`. Обратите внимание, что эта команда не [сжимает](https://ru.wikipedia.org/wiki/Сжатие_данных) файлы. То есть архив займёт столько же места на диске, сколько и собранные в него файлы.

Операции архивирования и сжатия имеют разные цели. Первая нужна для хранения и переноса большого числа файлов. Сжатие уменьшает объём, занимаемый данными на диске. Часто эти операции совмещают в одну.

Чтобы создать архив и сжать его, добавьте в вызов утилиты опцию `-j`. Например, так:
{line-numbers: false, format: Bash}
```
bsdtar -c -j -f test.tar.bz2 test
```

Опции `-c`, `-j` и `-f` можно объединить в одну группу. Получится следующее:
{line-numbers: false, format: Bash}
```
bsdtar -cjf test.tar.bz2 test
```

Напишем команду для прохода по каталогу фотографий. Для каждого месяца она создаст отдельный архив.

Следующий вызов утилиты find найдёт каталоги с месяцами:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/*
```

Вывод этой команды перенаправим на вход утилиты xargs. Она сформирует вызов утилиты bsdtar. Получится такая команда:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* | xargs -I% bsdtar -cf %.tar %
```

Чтобы выполнять сжатие, добавьте опцию `-j` в вызов bsdtar:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* | xargs -I% bsdtar -cjf %.tar.bz2 %
```

I> Cжатие длится дольше чем архивация.

Мы используем параметр `-I` утилиты xargs. Он указывает место подстановки аргументов в сформированную команду. В вызове утилиты `bsdtar` таких мест два: имя создаваемого архива и путь до обрабатываемого каталога.

Не забывайте про имена файлов с символами перевода строки. Чтобы обработать их корректно, добавим опцию `-print0` в вызов утилиты find:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* -print0 | xargs -0 -I% bsdtar -cjf %.tar.bz2 %
```

Предположим, архивы должны содержать файлы без относительных путей (например `2019/11`). Для этого используйте опцию `--strip-components` утилиты bsdtar. Например, так:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* -print0 | xargs -0 -I% bsdtar --strip-components=3 -cjf %.tar.bz2 %
```

##### Упражнение 2-8. Логические операторы

Реализуем алгоритм шаг за шагом. Первое действие — копирование файла `README` в домашний каталог пользователя. Это делает следующая команда:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~
```

С помощью оператора && и echo выведем результат команды в лог-файл. Получится следующее:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > result.log
```

Для архивации файла вызовем утилиту bsdtar или tar. Например, так:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/README.tar.bz2 ~/README
```

Результат утилиты выведем в лог-файл с помощью echo:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> result.log
```

Теперь команда echo дописывает строку в конец существующего лог-файла.

Объединим вызовы утилит cp и bsdtar в одну команду. Утилита bsdtar вызывается только после успешного копирования файла `README`. Если между командами поставить оператор &&, получим правильное условие. В результате команда копирования и архивации выглядит так:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > result.log && bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> result.log
```

Добавим последнее действие — удаление файла `README`. Получим:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log && bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log && rm ~/README && echo "rm - OK" >> ~/result.log
```

Запустите эту команду. Если она выполнится без ошибок, в лог-файл запишется следующее:
{line-numbers: true}
```
cp - OK
bsdtar - OK
rm - OK
```

Команда с вызовами трёх утилит подряд выглядит громоздко. Её неудобно читать и редактировать. Разобьём её на несколько строк. Для этого есть несколько способов.

Способ первый — перенос строки после логических операторов. Применим его и получим следующее:
{line-numbers: true, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log &&
bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log &&
rm ~/README && echo "rm - OK" >> ~/result.log
```

Попробуйте скопировать эту команду в окно терминала и исполнить. Она выполнится без ошибок.

Второй способ разбить команду на строки — использовать символ обратный слэш \. Сразу после него должен идти идёт перенос строки. Применяйте этот способ, когда в команде нет логических операторов.

Для примера поставим обратные слэши перед операторами && в нашей команде. Получим:
{line-numbers: true, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log \
&& bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log \
&& rm ~/README && echo "rm - OK" >> ~/result.log
```

## Разработка Bash скриптов

##### Упражнение 3-2. Полная форма подстановки параметров

Утилита find ищет файлы рекурсивно, начиная с указанного пути. Используйте параметр `-maxdepth`, чтобы исключить из поиска подкаталоги.

Команда поиска TXT файлов в текущем каталоге выглядит так:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt"
```

Добавим действие для копирования найденных файлов в домашний каталог пользователя. Получим:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt" -exec cp -t ~ {} \;
```

Создайте скрипт с именем `txt-copy.sh`. Скопируйте в него команду поиска.

В скрипт будем передавать параметр. В зависимости от него, выбирается действие: копирование или переименование. В качестве параметра удобнее передать имя утилиты: cp или mv. Скрипт вызовет утилиту по имени для каждого файла, найденного find.

Интерфейс скрипта `txt-copy.sh` выглядит так. Копирование выполняется командой:
{line-numbers: false, format: Bash}
```
./txt-copy.sh cp
```

Команда для переименования файлов такая:
{line-numbers: false, format: Bash}
```
./txt-copy.sh mv
```

Первый параметр скрипта сохраняется в перменной `$1`. Подставим её в вызов утилиты find. Получится следующее:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt" -exec "$1" -t ~ {} \;
```

Если действие не указано, скрипт должен копировать файлы. То есть допустим такой вызов скрипта:
{line-numbers: false, format: Bash}
```
./txt-copy.sh
```

Чтобы это сработало, добавим в подстановку параметра `$1` значение по умолчанию. Получим такой скрипт:
{line-numbers: true, format: Bash}
```
#!/bin/bash
find . -maxdepth 1 -type f -name "*.txt" -exec "${1:-cp}" -t ~ {} \;
```

##### Упражнение 3-4. Оператор if

Исходная команда выглядит так:
{line-numbers: false, format: Bash}
```
( grep -RlZ "123" target | xargs -0 cp -t . && echo "cp - OK" || ! echo "cp - FAILS" ) && ( grep -RLZ "123" target | xargs -0 rm && echo "rm - OK" || echo "rm - FAILS" )
```

Обратите внимание на отрицание вывода "cp - FAILS". Из-за него второй вызов утилиты grep произойдёт только, если первый выполнится успешно. Это означает, что второй вызов утилиты grep зависит от результата первого.

Заменим логический оператор && между вызовами grep на конструкцию if-else. Получится следующее:
{line-numbers: true, format: Bash}
```
if grep -RlZ "123" target | xargs -0 cp -t .
then
    echo "cp - OK"
    grep -RLZ "123" target | xargs -0 rm && echo "rm - OK" || echo "rm - FAILS"
else
    echo "cp - FAILS"
fi
```

Теперь заменим операторы || во втором вызове grep на if-else. Получим:
{line-numbers: true, format: Bash}
```
if grep -RlZ "123" target | xargs -0 cp -t .
then
    echo "cp - OK"
    if grep -RLZ "123" target | xargs -0 rm
    then
        echo "rm - OK"
    else
        echo "rm - FAILS"
    fi
else
    echo "cp - FAILS"
fi
```

Чтобы избежать вложенных конструкций if-else, применим технику раннего возврата. Также добавим в начале скрипта шебанг. Получится следующее:
{line-numbers: true, format: Bash}
```
#!/bin/bash

if ! grep -RlZ "123" target | xargs -0 cp -t .
then
  echo "cp - FAILS"
  exit 1
fi

echo "cp - OK"

if grep -RLZ "123" target | xargs -0 rm
then
  echo "rm - OK"
else
  echo "rm - FAILS"
fi
```

##### Упражнение 3-5. Оператор [[

Чтобы вывести файлы, которыми отличаются два каталога, их сначала нужно найти. Для поиска воспользуемся утилитой find. Тогда поиск файлов в каталоге `dir1` будет выглядеть так:
{line-numbers: false, format: Bash}
```
find dir1 -type f
```

Вывод этой команды может выглядеть например так:
{line-numbers: false}
```
dir1/test3.txt
dir1/test1.txt
dir1/test2.txt
```

Теперь нам нужно добавить действие с помощью параметра `-exec`, в котором мы проверим существование всех найденных файлов в каталоге `dir2`. Но есть одна проблема — каталог `dir1`, который утилита `find` добавляет к именам найденных файлов. Самый простой способ решить эту проблему — перейти в каталог `dir1` и после этого запустить `find`:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f
```

Теперь вывод будет выглядеть так:
{line-numbers: false}
```
./test3.txt
./test1.txt
./test2.txt
```

Добавим действие `-exec` с проверкой того, что найденный файл присутствует в каталоге `dir2`:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test -e ../dir2/{} \;
```

Обратите внимание, что в этом случае мы вынужденны использовать команду `test`, а не `[[`. Дело в том, что встроенный интерпретатор `find` не умеет корректно обрабатывать Bash конструкцию `[[`.

Если проверка не прошла, то есть файла нет, будем выводить его имя. Для этого инвертируем нашу проверку `test` и добавим второе `-exec` действие, связанное логическим И с первым. В результате получим следующий скрипт:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test ! -e ../dir2/{} \; -a -exec echo {} \;
```

Добавим аналогичный вызов `find` для проверки файлов каталога `dir2`:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test ! -e ../dir2/{} \; -a -exec echo {} \;

cd ../dir2
find . -type f -exec test ! -e ../dir1/{} \; -a -exec echo {} \;
```

I> Мы написали скрипт сравнения каталогов исключительно в учебных целях. Не используйте его для реальных задач. Лучше применяйте специальную GNU утилиту `diff`.

##### Упражнение 3-6. Использование конструкции `case`

Реализуем скрипт для переключения между конфигурационными файлами с использованием [символьных ссылок](https://ru.wikipedia.org/wiki/Символическая_ссылка). Символьная ссылка — это файл специального типа, который вместо данных содержит указатель на другой файл или каталог системы.

К сожалению, в Unix-окружении, работающем на OS Windows, вместо создания символьной ссылки будет происходить копирование соответствующего файла или каталога. Однако, они будут создаваться корректно на ОС Linux и macOS. Главное преимущество символьной ссылки заключается в том, что при работе с её содержимым вы на самом деле работаете с файлом или каталогом, на который она указывает. Это значит, что все изменения произойдут над этим файлом или каталогом.

Алгоритм нашего скрипта выглядит следующим образом:

1. Удалить существующую символьную ссылку или файл по пути `~/.bashrc`.

2. Проверить опцию командной строки, переданную в скрипт.

3. В зависимости от опции создать символьную ссылку на файл `.bashrc-home` или `.bashrc-work`.

Следующий скрипт реализует алгоритм с помощью конструкции `case`:
{line-numbers: true, format: Bash}
```
#!/bin/bash

file="$1"

rm ~/.bashrc

case "$file" in
  "h")
    ln -s ~/.bashrc-home ~/.bashrc
    ;;

  "w")
    ln -s ~/.bashrc-work ~/.bashrc
    ;;

  *)
    echo "Указана недопустимая опция"
    ;; 
esac
```

С помощью опции, переданной через позиционный параметр `$1`, выбирается имя файла.

Обратите внимание, что команда создания символьной ссылки остаётся неизменной независимо от опции скрипта. Это верный признак того, что конструкцию `case` можно заменить на ассоциативный массив. Например, следующим образом:
{line-numbers: true, format: Bash}
```
#!/bin/bash

option="$1"

declare -A files=(
  ["h"]="~/.bashrc-home"
  ["w"]="~/.bashrc-work")

if [[ -z "$option" || ! -v files["$option"] ]]
then
  echo "Указана недопустимая опция"
  exit 1
fi

rm ~/.bashrc

ln -s "${files["$option"]}" ~/.bashrc
```

Здесь мы используем двойные кавычки при подстановке элемента массива `files`, потому что он является одним параметром в вызове утилиты `ln`. Таким образом мы решаем возможную проблему с пробелами в путях.

##### Упражнение 3-7. Арифметические действия в дополнительном коде

Результаты сложения однобайтовых целых:
{line-numbers: false}
```
* 79 + (-46) = 0100 1111 + 1101 0010 = 1 0010 0001 -> 0010 0000 = 33

* -97 + 96 = 1001 1111 + 0110 0000 = 1111 1111 -> 1111 1110 -> 1000 0001 = -1
```

Результат сложения двухбайтовых целых:
{line-numbers: false}
```
* 12868 + (-1219) = 0011 0010 0100 0100 + 1111 1011 0011 1101 = 1 0010 1101 1000 0001 -> 0010 1101 1000 0001 = 11649
```

Для проверки корректности перевода чисел в дополнительный код можно использовать [онлайн-калькулятор](https://planetcalc.com/747/)

##### Упражнение 3-8. Вычисление остатка от деления и modulo

{line-numbers: false}
```
* 1697 % 13
q = 1697 / 13 ~ 130.5385 ~ 130
r = 1697 - 13 * 130 = 7

* 1697 modulo 13
q = 1697 / 13 ~ 130.5385 ~ 130
r = 1697 - 13 * 130 = 7

* 772 % -45
q = 772 / -45 ~ -17.15556 ~ -17
r = 772 - (-45) * (-17) = 7

* 772 modulo -45
q = (772 / -45) - 1 ~ -18.15556 ~ -18
r = 772 - (-45) * (-18) = -38

* -568 % 12
q = -568 / 12 ~ -47.33333 ~ -47
r = -568 - 12 * (-47) = -4

* -568 modulo 12
q = (-568 / 12) - 1 ~ -48.33333 ~ -48
r = -568 - 12 * (-48) = 8

* -5437 % -17
q = -5437 / -17 ~ 319.8235 ~ 319
r = -5437 - (-17) * 319 = -14

* -5437 modulo -17
q = -5437 / -17 ~ 319.8235 ~ 319
r = -5437 - (-17) * 319 = -14
```

##### Упражнение 3-9. Вычисление побитового отрицания

Сначала вычислим побитовое отрицание для случая беззнаковых двухбайтовых целых.
{line-numbers: false}
```
 56 = 0000 0000 0011 1000
~56 = 1111 1111 1100 0111 = 65479

 1018 = 0000 0011 1111 1010
~1018 = 1111 1100 0000 0101 = 64517

 58362 = 1110 0011 1111 1010
~58362 = 0001 1100 0000 0101 = 7173
```

Если операция отрицания выполняется над знаковыми двухбайтовыми целыми, результаты будут отличаться.
{line-numbers: false}
```
 56 = 0000 0000 0011 1000
~56 = 1111 1111 1100 0111 -> 1000 0000 0011 1001 = -57

 1018 = 0000 0011 1111 1010
~1018 = 1111 1100 0000 0101 -> 1000 0011 1111 1011 = -1019
```

Число 58362 не может быть представлено в виде знакового двухбайтового целого из-за переполнения. Если записать соответствующие ему биты в переменную такого типа, мы получим -7174. Перевод этого числа в прямой код будет выглядеть следующим образом:
{line-numbers: false}
```
58362 = 1110 0011 1111 1010 -> 1001 1100 0000 0110 = -7174
```

Теперь выполним побитовое отрицание:
{line-numbers: false}
```
  -7174  = 1110 0011 1111 1010
~(-7174) = 0001 1100 0000 0101 = 7173
```

Вы можете проверить результаты побитового отрицания над знаковыми целыми с помощью следующих Bash команд:
{line-numbers: true, format: Bash}
```
$ echo $((~56))
-57
$ echo $((~1018))
-1019
$ echo $((~(-7174)))
7173
```

Проверить отрицание двухбайтового беззнакого целого 58362 с помощью Bash не получится. Интерпретатор сохранит эту переменную в знаковом четырёхбайтовом целом. Тогда в результате отрицания мы получим:
{line-numbers: true, format: Bash}
```
$ echo $((~58362))
-58363
```

##### Упражнение 3-10. Вычисление побитовых И, ИЛИ, исключающего ИЛИ

Вычислим битовые операции для случая беззнаковых двухбайтовый целых:
{line-numbers: false}
```
1122 & 908 = 0000 0100 0110 0010 & 0000 0011 1000 1100 = 0000 0000 000 0000 = 0

1122 | 908 = 0000 0100 0110 0010 | 0000 0011 1000 1100 = 0000 0111 1110 1110 = 2030

1122 ^ 908 = 0000 0100 0110 0010 ^ 0000 0011 1000 1100 = 0000 0111 1110 1110 = 2030


49608 & 33036 = 1100 0001 1100 1000 & 1000 0001 0000 1100 = 1000 0001 0000 1000 = 33032

49608 | 33036 = 1100 0001 1100 1000 | 1000 0001 0000 1100 = 1100 0001 1100 1100 = 49612

49608 ^ 33036 = 1100 0001 1100 1000 ^ 1000 0001 0000 1100 = 0100 0000 1100 0100 = 16580
```

Если целые знаковые, то результаты битовых операций для первой пары чисел 1122 и 908 будут теми же. Для второй пары, вычисление будет отличаться.

Сначала выясним значение обоих чисел в прямом коде:
{line-numbers: false}
```
49608 = 1100 0001 1100 1000 -> 1011 1110 0011 1000 = -15928

33036 = 1000 0001 0000 1100 -> 1111 1110 1111 0100 = -32500

-15928 & -32500 = 1100 0001 1100 1000 & 1000 0001 0000 1100 = 1000 0001 0000 1000 -> 1111 1110 1111 1000 = -32504

-15928 | -32500 = 1100 0001 1100 1000 | 1000 0001 0000 1100 = 1100 0001 1100 1100 -> 1011 1110 0011 0100 = -15924

-15928 ^ -32500 = 1100 0001 1100 1000 ^ 1000 0001 0000 1100 = 0100 0000 1100 0100 = 16580
```

Bash-команды для проверки результатов операций:
{line-numbers: true, format: Bash}
```
$ echo $((1122 & 908))
0
$ echo $((1122 | 908))
2030
$ echo $((1122 ^ 908))
2030

$ echo $((49608 & 33036))
33032
$ echo $((49608 | 33036))
49612
$ echo $((49608 ^ 33036))
16580

$ echo $((-15928 & -32500))
-32504
$ echo $((-15928 | -32500))
-15924
$ echo $((-15928 ^ -32500))
16580
```

##### Упражнение 3-11. Вычисление битовых сдвигов

Вычисление операций:
{line-numbers: false}
```
* 25649 >> 3 = 0110 0100 0011 0001 >> 3 = 0110 0100 0011 0 = 0000 1100 1000 0110 = 3206

* 25649 << 2 = 0110 0100 0011 0001 << 2 = 10 0100 0011 0001 -> 1001 0000 1100 0100 -> 1110 1111 0011 1100 = -28476

* -9154 >> 4 = 1101 1100 0011 1110 >> 4 = 1101 1100 0011 -> 1111 1101 1100 0011 -> 1000 0010 0011 1101 = -573

* -9154 << 3 = 1101 1100 0011 1110 << 3 = 1 1100 0011 1110 -> 1110 0001 1111 0000 -> 1001 1110 0001 0000 = -7696
```

Bash-команды для проверки результатов:
{line-numbers: true, format: Bash}
```
$ echo $((25649 >> 3))
3206
$ echo $((25649 << 2))
102596
$ echo $((-9154 >> 4))
-573
$ echo $((-9154 << 3))
-73232
```

Отличие результатов второй и четвёртой операции связано с восьмибайтовым представлением чисел в Bash.

Вы можете проверить свои расчёты также с помощью [онлайн-калькулятора](https://onlinetoolz.net/bitshift).

##### Упражнение 3-12. Использование операторов цикла

Согласно условию задачи, у игрока есть семь попыток отгадать число. Поэтому применим конструкцию `for` с фиксированным количеством итераций. На каждой итерации будем читать ввод пользователя с помощью команды `read`. Затем сравним введённое число с загаданным. В зависимости от результата будем выводить текст подсказки.

Чтобы загадать случайное число, воспользуемся зарезервированной переменной `RANDOM`. При чтении она возвращает случайное значение от 0 до 32767. В нашем случае требуется число от 1 до 100. Его можно получить из значения `RANDOM` за два шага. Прежде всего рассчитаем остаток от деления `RANDOM` на 100 по следующей формуле:
{line-numbers: false, format: Bash}
```
number=$((RANDOM % 100))
```

Таким образом мы получим случайное число от 0 до 99. Прибавим к нему единицу, чтобы получить нужный нам диапазон от 1 до 100. Конечная формула расчёта выглядит так:
{line-numbers: false, format: Bash}
```
number=$((RANDOM % 100 + 1))
```

Полное решение задачи выглядит следующим образом:
{line-numbers: true, format: Bash}
```
#!/bin/bash

number=$((RANDOM % 100 + 1))

for i in {1..7}
do
  echo "Введите число:"

  read input

  if (( input < number))
  then
    echo "Число $input меньше искомого"
  elif (( number < input))
  then
    echo "Число $input больше искомого"
  else
    echo "Вы отгадали число"
    exit 0
  fi  
done

echo "Вы не отгадали число"
```

Чтобы успешно отгадать число за семь попыток, вам необходимо применить [**алгоритм двоичного поиска**](https://ru.wikipedia.org/wiki/Двоичный_поиск). Его идея заключается в том, чтобы дробить массив чисел на половины. Рассмотрим пример одной игры "Больше-Меньше", в которой будем использовать этот алгоритм.

В самом начале игры мы ищем число в диапазоне от 1 до 100. Серединой этого диапазона является 50. Поэтому вводим это значение первым. Например, программа нам ответила, что 50 меньше искомого числа. Это значит, что оно находится в диапазоне от 50 до 100. Теперь вводим середину этого диапазона, то есть число 75. Получаем ответ, что 75 тоже меньше искомого. Вывод — искомое число находится между 75 и 100. Середина этого диапазона `x` рассчитывается следующим образом:
{line-numbers: false, format: text}
```
x = 75 + (100 - 75) / 2 = 87.5
``` 

Вы можете округлить результат в большую или меньшую сторону. Это неважно. Округлим в меньшую и получим число 87 для следующего ввода. Если число до сих пор не было отгадано, продолжаем делить диапазон возможных чисел пополам. В конце концов семи шагов должно хватить для поиска.

##### Упражнение 3-13. Использование функций

Вариант с оператором `case` уже был рассмотрен в примерах раздела "Функции в скриптах". Если мы объединим код функций `print_error` и `code_to_error` в один файл, то получим следующее:
{line-numbers: true, format: Bash}
```
#!/bin/bash

code_to_error()
{
  case $1 in
    1)
      echo "Не найден файл"
      ;;
    2)
      echo "Нет прав для чтения файла"
      ;;
  esac
}

print_error()
{
  echo "$(code_to_error $1) $2" >> debug.log
}

print_error 1 "readme.txt"
```

Переименуем функцию `code_to_error` на `code_to_error_ru`, чтобы её имя отражало язык возвращаемых сообщений.

Далее дополним скрипт функцией `code_to_error_en`, которая будет возвращать текст на английском языке для соответствующего кода ошибки. Эта функция может выглядеть следующим образом:
{line-numbers: true, format: Bash}
```
code_to_error_en()
{
  case $1 in
    1)
      echo "The following file was not found:"
      ;;
    2)
      echo "You do not have permissions to read the following file:"
      ;;
  esac
}
```

Теперь нам необходимо выбрать, какую функцию `code_to_error_ru` или `code_to_error_en` вызывать в `print_error`. Для этого будем проверять значение переменной окружения `LANG`. Региональные настройки пользовательского интерфейса хранятся в ней. Тогда полный скрипт будет выглядеть следующим образом:
{line-numbers: true, format: Bash}
```
#!/bin/bash

code_to_error_ru()
{
  case $1 in
    1)
      echo "Не найден файл"
      ;;
    2)
      echo "Нет прав для чтения файла"
      ;;
  esac
}

code_to_error_en()
{
  case $1 in
    1)
      echo "The following file was not found:"
      ;;
    2)
      echo "You do not have permissions to read the following file:"
      ;;
  esac
}

print_error()
{
  if [[ "$LANG" == ru_RU* ]]
  then
    echo "$(code_to_error_ru $1) $2" >> debug.log
  else
    echo "$(code_to_error_en $1) $2" >> debug.log
  fi
}

print_error 1 "readme.txt"
```

Если язык системы русский, в переменной `LANG` встретиться шаблон `ru_Ru*`. В этом случае вызывается функция `code_to_error_ru`. В любом другом случае вызывается `code_to_error_en`.

Конструкцию `if` в функции `print_error` можно заменить на `case`. Например, следующим образом:
{line-numbers: true, format: Bash}
```
print_error()
{
  case $LANG in
    ru_RU*)
      echo "$(code_to_error_ru $1) $2" >> debug.log
      ;;
    en_US*)
      echo "$(code_to_error_en $1) $2" >> debug.log
      ;;
    *)
      echo "$(code_to_error_en $1) $2" >> debug.log
      ;;
  esac
}
```

Вариант с `case` будет удобнее, если необходимо поддерживать более двух языков.

В функции `print_error` происходит дублирование кода. В каждом блоке конструкции `case` выполняется одна и та же команда `echo`. Единственное различие между блоками — это вызываемая функция для конвертирования кода ошибки в текст. Чтобы избежать дублирования, воспользуемся переменной `func`, которая будет хранить имя функции для конвертирования. Получим следующий результат:
{line-numbers: true, format: Bash}
```
print_error()
{
  case $LANG in
    ru_RU)
      local func="code_to_error_ru"
      ;;
    en_US)
      local func="code_to_error_en"
      ;;
    *)
      local func="code_to_error_en"
      ;;
  esac

  echo "$($func $1) $2" >> debug.log
}
```

Конструкции `case` в функциях `code_to_error_ru` и `code_to_error_en` можно заменить на индексируемые массивы. Например, следующим образом:
{line-numbers: true, format: Bash}
```
code_to_error_ru()
{
  declare -a messages

  messages[1]="Не найден файл"
  messages[2]="Нет прав для чтения файла"

  echo "${messages[$1]}"
}

code_to_error_en()
{
  declare -a messages

  messages[1]="The following file was not found:"
  messages[2]="You do not have permissions to read the following file:"

  echo "${messages[$1]}"
}
```

На самом деле можно сделать один ассоциативный массив, в котором будут собраны все языки и сообщения. В качестве ключа в таком массиве может использоваться комбинация значения переменной `LANGUAGE` и кода сообщения. В результате мы сможем обойтись только одной функцией `print_error`:
{line-numbers: true, format: Bash}
```
#!/bin/bash

print_error()
{
  declare -A messages

  messages["ru_RU",1]="Не найден файл"
  messages["ru_RU",2]="Нет прав для чтения файла"

  messages["en_US",1]="The following file was not found:"
  messages["en_US",2]="You do not have permissions to read the          following file:"

  echo "${messages[$LANGUAGE,$1]} $2" >> debug.log
}

print_error 1 "readme.txt"
```

##### Упражнение 3-14. Область видимости переменных

После выполнения скрипта из листинга 3-36 на консоль будет выведен следующий текст:
{line-numbers: true, format: text}
```
main1: var =
foo1: var = foo_value
bar1: var = foo_value
bar2: var = bar_value
foo2: var = bar_value
main2: var = 
```

Начнём с самого простого вывода "main1" и "main2". Переменная `var` объявлена в функции `foo`. Поэтому она доступна только в ней и в вызываемой из неё функции `bar`. Следовательно, до и после вызова `foo` переменная считается необъявленной.

В выводе "foo1" мы получили только что присвоенное переменной значение `foo_value`. Далее идёт вывод "bar1". Переменная `var` была объявлена в функции `foo`, а `bar` вызывается из неё. Поэтому тело функции `bar` также является областью видимости `var`.

Затем мы присваиваем `var` новое значение `bar_value`. Обратите внимание, что здесь происходит не объявление новой глобальной переменной с именем `var`, а перезапись уже существующей локальной переменной. Поэтому в выводах "bar2" и в "foo2" мы увидим новое значение `bar_value`. Также именно по этой причине мы не увидим значение переменной в выводе "main2".
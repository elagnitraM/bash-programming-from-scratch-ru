# Ответы

## Общая информация

##### Упражнение 1-1. Перевод чисел из BIN в HEX

{line-numbers: false}
```
* 10100110100110 = 0010 1001 1010 0110 = 2 9 A 6 = 29A6

* 1011000111010100010011 = 0010 1100 0111 0101 0001 0011 = 2 C 7 5 1 3 = 2C7513

* 1111101110001001010100110000000110101101 = 1111 1011 1000 1001 0101 0011 0000 0001 1010 1101 = F B 8 9 5 3 0 1 A D = FB895301AD
```

##### Упражнение 1-2. Перевод чисел из HEX в BIN

{line-numbers: false}
```
* FF00AB02 = F F 0 0 A B 0 2 = 1111 1111 0000 0000 1010 1011 0000 0010 = 11111111000000001010101100000010

* 7854AC1 = 7 8 5 4 A C 1 = 0111 1000 0101 0100 1010 1100 0001 = 111100001010100101011000001

* 1E5340ACB38 = 1 E 5 3 4 0 A C B 3 8 = 0001 1110 0101 0011 0100 0000 1010 1100 1011 0011 1000 = 11110010100110100000010101100101100111000
```

## Командный интерпретатор Bash

##### Упражнение 2-1. Шаблоны поиска

{line-numbers: false}
```
* README.md
```

Строка `00_README.txt` не подходит, потому что шаблон `*ME.??` ожидает два символа после точки. В варианте `README` вообще нет точки, и он тоже не подходит.

##### Упражнение 2-2. Шаблоны поиска

Шаблону поиска удовлетворяют три строки:

* `/usr/share/doc/openssl/IPAddressChoice_new.html`
* `/usr/share/doc_openssl/IPAddressChoice_new.html`
* `/doc/openssl`

Строка `doc/openssl` не соответствует шаблону `*/doc?openssl*`, потому что в ней нет символа `/` перед `doc`.

##### Упражнение 2-3. Использование команды find

Правильный ответ следующий:
{line-numbers: false, format: Bash}
```
find /usr -name "*.txt" -exec wc -l {} +
```

Чтобы найти все TXT файлы, подойдёт также команда:
{line-numbers: false, format: Bash}
```
find / -name "*.txt"
```

Но если вы попробуйте расширить её действием `wc -l`, никакого вывода не будет:
{line-numbers: false, format: Bash}
```
find / -name "*.txt" -exec wc -l {} +
```

Помните сообщение об ошибке, которое выводится при запуске `find` в корневом каталоге? Текст этого сообщения будет передаваться в команду `wc`. Дальше команда будет интерпретировать каждое слово в качестве пути до файла. Очевидно, что эти пути окажутся недействительными и `wc` завершится с ошибкой. Чтобы её избежать, запускать `find` надо в каталоге `/usr`. Все TXT файлы находятся в нём и будут найдены командой.

##### Упражнение 2-4. Использование команды grep

Информацию о лицензии приложений логично искать в системном каталоге с документацией `/usr/share/doc`.

Для поиска приложений с лицензией [GNU General Public License](https://ru.wikipedia.org/wiki/GNU_General_Public_License) воспользуемся строкой "General Public License":
{line-numbers: false, format: Bash}
```
grep -Rl "General Public License" /usr/share/doc
```

Также имеет смысл поискать в каталоге `/usr/share/licenses`:
{line-numbers: false, format: Bash}
```
grep -Rl "General Public License" /usr/share/licenses
```

В окружении MSYS2 есть два неспецифичных для Unix каталога установки `/mingw32` и `/mingw64`. Можно проверить и установленные в них программы:
{line-numbers: true, format: Bash}
```
grep -Rl "General Public License" /mingw32/share/doc
grep -Rl "General Public License" /mingw64/share
```

В случае лицензии MIT можно искать строку "MIT license" в тех же каталогах. Для Apache лицензии подойдёт строка "Apache license", а для BSD - "BSD license".

##### Упражнение 2-6. Использование утилит для работы с файлами и каталогами

Прежде всего создадим каталоги, куда будем копировать фотографии:
{line-numbers: true, format: Bash}
```
mkdir -p ~/photo/2019/11
mkdir -p ~/photo/2019/12
mkdir -p ~/photo/2020/01
```

Предположим, что все ваши фотографии хранятся в каталоге `D:\Photo`. У него могут быть подкаталоги, но для нашего упражнения это несущественно. С помощью команды `find` найдём все файлы, созданные в ноябре 2019 года. Для этого воспользуемся параметром `-newermt`:
{line-numbers: false, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01
```

Эта команда ищет файлы в каталоге `/d/Photo`, который соответствует пути `D:\Photo` в Windows окружении.

Первое выражение `-newermt 2019-11-01` означает выбрать все файлы, модифицированные начиная с 1 ноября 2019 года. Далее идёт выражение `! -newermt 2019-12-01`. Как вы помните, восклицательный знак означает отрицание. По аналогии с предыдущим выражением, `-newermt 2019-12-01` означает все файлы, модифицированные начиная с 1 декабря 2019 года. Между этими выражениями нет условия. В этом случае используется логическое И. В результате получится высказывание: файлы, созданные после 1 ноября 2019 года, но не позднее 30 ноября 2019 года. Другими словами: файлы за ноябрь месяц.

Теперь к нашей команде `find` добавим действие копирования файлов:
{line-numbers: false, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01 -exec cp {} ~/photo/2019/11 \;
```

В результате в каталог `~/photo/2019/11` будут скопированы файлы за ноябрь 2019 года. Выполним аналогичные команды для копирования фотографий за декабрь и январь:
{line-numbers: true, format: Bash}
```
find /d/Photo -type f -newermt 2019-12-01 ! -newermt 2020-01-01 -exec cp {} ~/photo/2019/12 \;
find /d/Photo -type f -newermt 2020-01-01 ! -newermt 2020-02-01 -exec cp {} ~/photo/2020/01 \;
```

Вы можете заменить команду копирования на переименование, если файлы в каталоге `D:\Photo` вам больше не нужны:
{line-numbers: true, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01 -exec mv {} ~/photo/2019/11 \;
find /d/Photo -type f -newermt 2019-12-01 ! -newermt 2020-01-01 -exec mv {} ~/photo/2019/12 \;
find /d/Photo -type f -newermt 2020-01-01 ! -newermt 2020-02-01 -exec mv {} ~/photo/2020/01 \;
```

Обратите внимание на масштабируемость такого решения. Независимо от количества файлов в каталоге `D:\Photo` для разделения их по месяцам, нужно всего три команды.

##### Упражнение 2-7. Использование конвейеров и перенаправления потоков ввода-вывода

Прежде всего разберёмся, как работает утилита `bsdtar`. Согласно её выводу `--help`, для создания [**архива**](https://ru.wikipedia.org/wiki/Архив_(информатика)) каталога необходимо передать опции `-c` и `-f`, а также имя архива. Например:
{line-numbers: false, format: Bash}
```
bsdtar -c -f test.tar test
```

Эта команда создаст архив с именем `test.tar`, в который поместит всё содержимое каталога `test`. Обратите внимание, что [сжатия](https://ru.wikipedia.org/wiki/Сжатие_данных) в результате этой команды не произойдёт. То есть архив будет занимать почти столько же места на диске, сколько и собранные в него файлы. Цели операций архивирования и сжатия различны. Первая нужна для удобства хранения и переноса большого числа файлов. Сжатие позволяет уменьшить объём, занимаемый данными на диске. Часто эти операции совмещают в одну.

Если вы хотите сжать полученный архив, добавьте опцию `-j`:
{line-numbers: false, format: Bash}
```
bsdtar -c -j -f test.tar.bz2 test
```

Обратите внимание, что все опции `-c`, `-j` и `-f` можно записать без пробелов:
{line-numbers: false, format: Bash}
```
bsdtar -cjf test.tar.bz2 test
```

Мы разобрались, как использовать `bsdtar`. Теперь пришло время написать команду для прохода по каталогу фотографий и созданию архива для каждого месяца. Чтобы найти все каталоги с месяцами, воспользуемся командой `find`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/*
```

Теперь перенаправим её вывод утилите `xargs`, которая сформирует вызов `bsdtar`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* | xargs -I% bsdtar -cf %.tar %
```

Если необходимо сжатие, добавьте опцию `-j` в вызов `bsdtar`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* | xargs -I% bsdtar -cjf %.tar.bz2 %
```

I> Учтите, что сжатие — это значительно более долгая операция чем архивация.

В данном случае мы воспользовались параметром `-I` команды `xargs`, чтобы указать место подстановки сформированных ею аргументов. В случае вызова утилиты `bsdtar` этих мест два: имя создаваемого архива и путь до каталога, который следует обработать.

Не забывайте про имена файлов, которые могут содержать символы перевода строки. Чтобы обработать их корректно, добавим опцию `-print0` в вызов утилиты `find`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* -print0 | xargs -0 -I% bsdtar -cjf %.tar.bz2 %
```

Если вы хотите, чтобы архивы содержали только файлы без относительных путей (например `2019/11`), воспользуйтесь опцией `--strip-components` утилиты `bsdtar`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* -print0 | xargs -0 -I% bsdtar --strip-components=3 -cjf %.tar.bz2 %
```

##### Упражнение 2-8. Использование логических операторов

Будем реализовывать наш алгоритм последовательно шаг за шагом. Первое действие — копирование файла README в домашний каталог пользователя:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~
```

Чтобы вывести результат этой команды в лог-файл, воспользуемся оператором `&&` и `echo`:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > result.log
```

Далее необходимо заархивировать скопированный файл. Для этого воспользуемся утилитой `bsdtar` или `tar`:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/README.tar.bz2 ~/README
```

Выведем её результат аналогично с использованием оператора `&&` и команды `echo`:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> result.log
```

Обратите внимание, что в данном случае `echo` дописывает в конец уже существующего лог-файла.

Как объединить получившиеся вызовы `cp` и `bsdtar`? Утилита `bsdtar` должна отработать только в случае успешного выполнения копирования. Значит, надо опять воспользоваться оператором `&&`. В результате получим следующую команду:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > result.log && bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> result.log
```

Добавим к ней последнее действие — удаление файла `README`:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log && bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log && rm ~/README && echo "rm - OK" >> ~/result.log
```

Если вы запустите эту команду и все действия выполнятся корректно, вы получите следующий вывод в файле `result.txt`:
{line-numbers: true}
```
cp - OK
bsdtar - OK
rm - OK
```

Согласитесь, что читать получившуюся команду неудобно. Её можно разбить на несколько строк несколькими способами. Bash разрешает перенос строки сразу после логических операторов:
{line-numbers: true, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log &&
bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log &&
rm ~/README && echo "rm - OK" >> ~/result.log
```

Попробуйте скопировать эту команду в окно терминала и исполнить. Она должна отработать без ошибок.

Если в вашей команде нет логических операторов, вы можете воспользоваться символом обратный слэш `\`. В нашем случае для примера поставим его перед `&&`:
{line-numbers: true, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log \
&& bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log \
&& rm ~/README && echo "rm - OK" >> ~/result.log
```

Обратный слэш вы можете вставлять в любое место команды. Важно, чтобы сразу после него шёл перевод строки.

## Разработка Bash скриптов

##### Упражнение 3-2. Использование полной формы подстановки параметров

Чтобы ограничить утилиту `find` поиском только в текущем каталоге, воспользуемся параметром `-maxdepth`. Тогда команда поиска файлов с расширением TXT будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt"
```

Добавим в неё действие копирования найденных файлов в домашний каталог пользователя:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt" -exec cp -t ~ {} \;
```

Поместим команду в скрипт с именем `txt-copy.sh`. Тогда мы сможем вызвать скрипт и передать ему желаемое действие: копирование или переименование. Проще всего будет передавать имя утилиты (`cp` или `mv`), которую следует вызвать для каждого найденного файла. В таком случае следующая команда будет выполнять копирование:
{line-numbers: false, format: Bash}
```
./txt-copy.sh cp
```

Для перемещения найденных файлов достаточно заменить `cp` на `mv`:
{line-numbers: false, format: Bash}
```
./txt-copy.sh mv
```

Первый параметр, переданный скрипту, сохраняется в перменной `$1`. Подставим её в наш вызов `find`:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt" -exec "$1" -t ~ {} \;
```

Теперь зададим значение по умолчанию. Благодаря этому, будет выполняться копирование, если позиционный параметр `$1` пустой. В итоге наш скрипт будет выглядеть так:
{line-numbers: true, format: Bash}
```
#!/bin/bash
find . -maxdepth 1 -type f -name "*.txt" -exec "${1:-cp}" -t ~ {} \;
```

##### Упражнение 3-4. Использование оператора if

Исходная команда выглядит следующих образом:
{line-numbers: false, format: Bash}
```
( grep -RlZ "123" target | xargs -0 cp -t . && echo "cp - OK" || ! echo "cp - FAILS" ) && ( grep -RLZ "123" target | xargs -0 rm && echo "rm - OK" || echo "rm - FAILS" )
```

Обратите внимание на отрицание вывода "cp - FAILS". Если бы не оно, мы могли бы разбить команду на два отдельных вызова. Но в данном случае выполнение прервётся, если первый `grep` не найдёт ни одного файла и команда `cp` не сможет отработать корректно. Поэтому, нам нужен вложенный `if-else` следующего вида:
{line-numbers: true, format: Bash}
```
if grep -RlZ "123" target | xargs -0 cp -t .
then
  echo "cp - OK"
  if grep -RLZ "123" target | xargs -0 rm
  then
    echo "rm - OK"
  else
    echo "rm - FAILS"
  fi
else
  echo "cp - FAILS"
fi
```

Если применить технику раннего возврата, мы получим следующее:
{line-numbers: true, format: Bash}
```
if ! grep -RlZ "123" target | xargs -0 cp -t .
then
  echo "cp - FAILS"
  exit 1
fi

echo "cp - OK"

if grep -RLZ "123" target | xargs -0 rm
then
  echo "rm - OK"
else
  echo "rm - FAILS"
fi
```

Благодаря отрицанию `!` результата работы первого `grep` и следующего далее в конвейере `cp`, мы можем завершить скрипт сразу же после ошибки.

##### Упражнение 3-5. Использование оператора `[[`

Чтобы вывести файлы, которыми отличаются два каталога, их сначала нужно найти. Для поиска воспользуемся утилитой `find`. Тогда поиск файлов в каталоге `dir1` будет выглядеть так:
{line-numbers: false, format: Bash}
```
find dir1 -type f
```

Вывод этой команды может выглядеть например так:
{line-numbers: false}
```
dir1/test3.txt
dir1/test1.txt
dir1/test2.txt
```

Теперь нам нужно добавить действие с помощью параметра `-exec`, в котором мы проверим существование всех найденных файлов в каталоге `dir2`. Но есть одна проблема — каталог `dir1`, который утилита `find` добавляет к именам найденных файлов. Самый простой способ решить эту проблему — перейти в каталог `dir1` и после этого запустить `find`:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f
```

Теперь вывод будет выглядеть так:
{line-numbers: false}
```
./test3.txt
./test1.txt
./test2.txt
```

Добавим действие `-exec` с проверкой того, что найденный файл присутствует в каталоге `dir2`:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test -e ../dir2/{} \;
```

Обратите внимание, что в этом случае мы вынужденны использовать команду `test`, а не `[[`. Дело в том, что встроенный интерпретатор `find` не умеет корректно обрабатывать Bash конструкцию `[[`.

Если проверка не прошла, то есть файла нет, будем выводить его имя. Для этого инвертируем нашу проверку `test` и добавим второе `-exec` действие, связанное логическим И с первым. В результате получим следующий скрипт:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test ! -e ../dir2/{} \; -a -exec echo {} \;
```

Добавим аналогичный вызов `find` для проверки файлов каталога `dir2`:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test ! -e ../dir2/{} \; -a -exec echo {} \;

cd ../dir2
find . -type f -exec test ! -e ../dir1/{} \; -a -exec echo {} \;
```

I> Мы написали скрипт сравнения каталогов исключительно в учебных целях. Не используйте его для реальных задач. Лучше применяйте специальную GNU утилиту `diff`.

##### Упражнение 3-6. Вычисление остатка от деления и modulo

{line-numbers: false}
```
* 772 % -45
r = 772 - (-45) * (-17) = 7

* 772 modulo -45
r = 772 - (-45) * (-18) = -38

* -568 % 12
r = -568 - 12 * (-47) = -4

* -568 modulo 12
r = -568 - 12 * (-48) = 8
```

##### Упражнение 3-7. Арифметические действия в дополнительном коде

Результаты сложения однобайтовых целых:
{line-numbers: false}
```
* 79 + (-46) = 0100 1111 + 1101 0010 = 1 0010 0001 -> 0010 0000 = 33

* -97 + 96 = 1001 1111 + 0110 0000 = 1111 1111 -> 1111 1110 -> 1000 0001 = -1
```

Результат сложения двухбайтовых целых:
{line-numbers: false}
```
* 12868 + (-1219) = 0011 0010 0100 0100 + 1111 1011 0011 1101 = 1 0010 1101 1000 0001 -> 0010 1101 1000 0001 = 11649
```